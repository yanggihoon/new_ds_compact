/* cmxDeviceServiceC.cpp
   Generated by gSOAP 2.7.6e from ds_intf.h
   Copyright (C) 2000-2005, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "cmxDeviceServiceH.h"

namespace cmxDeviceService {

SOAP_SOURCE_STAMP("@(#) cmxDeviceServiceC.cpp ver 2.7.6e 2010-07-22 06:12:39 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_cmxDeviceService_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_cmxDeviceService_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_cmxDeviceService_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_cmxDeviceService_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_cmxDeviceService_ns__sensorEmerFunc:
		return soap_in_ns__sensorEmerFunc(soap, NULL, NULL, "ns:sensorEmerFunc");
	case SOAP_TYPE_cmxDeviceService_ns__enum_sensorEmer:
		return soap_in_ns__enum_sensorEmer(soap, NULL, NULL, "ns:enum-sensorEmer");
	case SOAP_TYPE_cmxDeviceService_ns__fanSystemFunc:
		return soap_in_ns__fanSystemFunc(soap, NULL, NULL, "ns:fanSystemFunc");
	case SOAP_TYPE_cmxDeviceService_ns__enum_fanSystem:
		return soap_in_ns__enum_fanSystem(soap, NULL, NULL, "ns:enum-fanSystem");
	case SOAP_TYPE_cmxDeviceService_ns__systemAirconFunc:
		return soap_in_ns__systemAirconFunc(soap, NULL, NULL, "ns:systemAirconFunc");
	case SOAP_TYPE_cmxDeviceService_ns__enum_systemAircon:
		return soap_in_ns__enum_systemAircon(soap, NULL, NULL, "ns:enum-systemAircon");
	case SOAP_TYPE_cmxDeviceService_ns__bundleLightFunc:
		return soap_in_ns__bundleLightFunc(soap, NULL, NULL, "ns:bundleLightFunc");
	case SOAP_TYPE_cmxDeviceService_ns__enum_bundleLight:
		return soap_in_ns__enum_bundleLight(soap, NULL, NULL, "ns:enum-bundleLight");
	case SOAP_TYPE_cmxDeviceService_ns__curtainFunc:
		return soap_in_ns__curtainFunc(soap, NULL, NULL, "ns:curtainFunc");
	case SOAP_TYPE_cmxDeviceService_ns__enum_curtain:
		return soap_in_ns__enum_curtain(soap, NULL, NULL, "ns:enum-curtain");
	case SOAP_TYPE_cmxDeviceService_ns__gasValveFunc:
		return soap_in_ns__gasValveFunc(soap, NULL, NULL, "ns:gasValveFunc");
	case SOAP_TYPE_cmxDeviceService_ns__enum_gasValve:
		return soap_in_ns__enum_gasValve(soap, NULL, NULL, "ns:enum-gasValve");
	case SOAP_TYPE_cmxDeviceService_ns__lightFunc:
		return soap_in_ns__lightFunc(soap, NULL, NULL, "ns:lightFunc");
	case SOAP_TYPE_cmxDeviceService_ns__enum_light:
		return soap_in_ns__enum_light(soap, NULL, NULL, "ns:enum-light");
	case SOAP_TYPE_cmxDeviceService_ns__boilerFunc:
		return soap_in_ns__boilerFunc(soap, NULL, NULL, "ns:boilerFunc");
	case SOAP_TYPE_cmxDeviceService_ns__enum_boiler:
		return soap_in_ns__enum_boiler(soap, NULL, NULL, "ns:enum-boiler");
	case SOAP_TYPE_cmxDeviceService_ns__deviceCategoryFunc:
		return soap_in_ns__deviceCategoryFunc(soap, NULL, NULL, "ns:deviceCategoryFunc");
	case SOAP_TYPE_cmxDeviceService_ns__enum_config_Common_Error:
		return soap_in_ns__enum_config_Common_Error(soap, NULL, NULL, "ns:enum-config-Common-Error");
	case SOAP_TYPE_cmxDeviceService_ns__enum_device_connect_check:
		return soap_in_ns__enum_device_connect_check(soap, NULL, NULL, "ns:enum-device-connect-check");
	case SOAP_TYPE_cmxDeviceService_ns__enum_devError:
		return soap_in_ns__enum_devError(soap, NULL, NULL, "ns:enum-devError");
	case SOAP_TYPE_cmxDeviceService_ns__enum_devInfo:
		return soap_in_ns__enum_devInfo(soap, NULL, NULL, "ns:enum-devInfo");
	case SOAP_TYPE_cmxDeviceService_ns__setSensorEmerResponse:
		return soap_in_ns__setSensorEmerResponse(soap, NULL, NULL, "ns:setSensorEmerResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getSensorEmerResponse:
		return soap_in_ns__getSensorEmerResponse(soap, NULL, NULL, "ns:getSensorEmerResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getSensorEmerItemResponse:
		return soap_in_ns__getSensorEmerItemResponse(soap, NULL, NULL, "ns:getSensorEmerItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__sensorEmer:
		return soap_in_ns__sensorEmer(soap, NULL, NULL, "ns:sensorEmer");
	case SOAP_TYPE_cmxDeviceService_ns__setFanSystemResponse:
		return soap_in_ns__setFanSystemResponse(soap, NULL, NULL, "ns:setFanSystemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemResponse:
		return soap_in_ns__getFanSystemResponse(soap, NULL, NULL, "ns:getFanSystemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemItemResponse:
		return soap_in_ns__getFanSystemItemResponse(soap, NULL, NULL, "ns:getFanSystemItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemPropertyItemResponse:
		return soap_in_ns__getFanSystemPropertyItemResponse(soap, NULL, NULL, "ns:getFanSystemPropertyItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__fanSystem:
		return soap_in_ns__fanSystem(soap, NULL, NULL, "ns:fanSystem");
	case SOAP_TYPE_cmxDeviceService_ns__setSystemAirconResponse:
		return soap_in_ns__setSystemAirconResponse(soap, NULL, NULL, "ns:setSystemAirconResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconResponse:
		return soap_in_ns__getSystemAirconResponse(soap, NULL, NULL, "ns:getSystemAirconResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconItemResponse:
		return soap_in_ns__getSystemAirconItemResponse(soap, NULL, NULL, "ns:getSystemAirconItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconPropertyItemResponse:
		return soap_in_ns__getSystemAirconPropertyItemResponse(soap, NULL, NULL, "ns:getSystemAirconPropertyItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__systemAircon:
		return soap_in_ns__systemAircon(soap, NULL, NULL, "ns:systemAircon");
	case SOAP_TYPE_cmxDeviceService_ns__setBundleLightResponse:
		return soap_in_ns__setBundleLightResponse(soap, NULL, NULL, "ns:setBundleLightResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightResponse:
		return soap_in_ns__getBundleLightResponse(soap, NULL, NULL, "ns:getBundleLightResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightItemResponse:
		return soap_in_ns__getBundleLightItemResponse(soap, NULL, NULL, "ns:getBundleLightItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightPropertyItemResponse:
		return soap_in_ns__getBundleLightPropertyItemResponse(soap, NULL, NULL, "ns:getBundleLightPropertyItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__bundleLight:
		return soap_in_ns__bundleLight(soap, NULL, NULL, "ns:bundleLight");
	case SOAP_TYPE_cmxDeviceService_ns__setCurtainResponse:
		return soap_in_ns__setCurtainResponse(soap, NULL, NULL, "ns:setCurtainResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainResponse:
		return soap_in_ns__getCurtainResponse(soap, NULL, NULL, "ns:getCurtainResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainItemResponse:
		return soap_in_ns__getCurtainItemResponse(soap, NULL, NULL, "ns:getCurtainItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainPropertyItemResponse:
		return soap_in_ns__getCurtainPropertyItemResponse(soap, NULL, NULL, "ns:getCurtainPropertyItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__curtain:
		return soap_in_ns__curtain(soap, NULL, NULL, "ns:curtain");
	case SOAP_TYPE_cmxDeviceService_ns__setGasValveResponse:
		return soap_in_ns__setGasValveResponse(soap, NULL, NULL, "ns:setGasValveResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getGasValveResponse:
		return soap_in_ns__getGasValveResponse(soap, NULL, NULL, "ns:getGasValveResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getGasValveItemResponse:
		return soap_in_ns__getGasValveItemResponse(soap, NULL, NULL, "ns:getGasValveItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getGasValvePropertyItemResponse:
		return soap_in_ns__getGasValvePropertyItemResponse(soap, NULL, NULL, "ns:getGasValvePropertyItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__gasValve:
		return soap_in_ns__gasValve(soap, NULL, NULL, "ns:gasValve");
	case SOAP_TYPE_cmxDeviceService_ns__setLightResponse:
		return soap_in_ns__setLightResponse(soap, NULL, NULL, "ns:setLightResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getLightResponse:
		return soap_in_ns__getLightResponse(soap, NULL, NULL, "ns:getLightResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getLightItemResponse:
		return soap_in_ns__getLightItemResponse(soap, NULL, NULL, "ns:getLightItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getLightPropertyItemResponse:
		return soap_in_ns__getLightPropertyItemResponse(soap, NULL, NULL, "ns:getLightPropertyItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__light:
		return soap_in_ns__light(soap, NULL, NULL, "ns:light");
	case SOAP_TYPE_cmxDeviceService_ns__setBoilerResponse:
		return soap_in_ns__setBoilerResponse(soap, NULL, NULL, "ns:setBoilerResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerResponse:
		return soap_in_ns__getBoilerResponse(soap, NULL, NULL, "ns:getBoilerResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerItemResponse:
		return soap_in_ns__getBoilerItemResponse(soap, NULL, NULL, "ns:getBoilerItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerPropertyItemResponse:
		return soap_in_ns__getBoilerPropertyItemResponse(soap, NULL, NULL, "ns:getBoilerPropertyItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__boiler:
		return soap_in_ns__boiler(soap, NULL, NULL, "ns:boiler");
	case SOAP_TYPE_cmxDeviceService_ns__setDeviceCategoryResponse:
		return soap_in_ns__setDeviceCategoryResponse(soap, NULL, NULL, "ns:setDeviceCategoryResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryResponse:
		return soap_in_ns__getDeviceCategoryResponse(soap, NULL, NULL, "ns:getDeviceCategoryResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryItemResponse:
		return soap_in_ns__getDeviceCategoryItemResponse(soap, NULL, NULL, "ns:getDeviceCategoryItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__deviceCategory:
		return soap_in_ns__deviceCategory(soap, NULL, NULL, "ns:deviceCategory");
	case SOAP_TYPE_cmxDeviceService_ns__rootDevice:
		return soap_in_ns__rootDevice(soap, NULL, NULL, "ns:rootDevice");
	case SOAP_TYPE_cmxDeviceService_ns__subcribeEvent:
		return soap_in_ns__subcribeEvent(soap, NULL, NULL, "ns:subcribeEvent");
	case SOAP_TYPE_cmxDeviceService_ns__subcribeEventResponse:
		return soap_in_ns__subcribeEventResponse(soap, NULL, NULL, "ns:subcribeEventResponse");
	case SOAP_TYPE_cmxDeviceService_ns__sensorEmerEvent:
		return soap_in_ns__sensorEmerEvent(soap, NULL, NULL, "ns:sensorEmerEvent");
	case SOAP_TYPE_cmxDeviceService_ns__sensorEmerEventResponse:
		return soap_in_ns__sensorEmerEventResponse(soap, NULL, NULL, "ns:sensorEmerEventResponse");
	case SOAP_TYPE_cmxDeviceService_ns__setSensorEmer:
		return soap_in_ns__setSensorEmer(soap, NULL, NULL, "ns:setSensorEmer");
	case SOAP_TYPE_cmxDeviceService_ns__getSensorEmer:
		return soap_in_ns__getSensorEmer(soap, NULL, NULL, "ns:getSensorEmer");
	case SOAP_TYPE_cmxDeviceService_ns__getSensorEmerItem:
		return soap_in_ns__getSensorEmerItem(soap, NULL, NULL, "ns:getSensorEmerItem");
	case SOAP_TYPE_cmxDeviceService_ns__getSensorEmerCount:
		return soap_in_ns__getSensorEmerCount(soap, NULL, NULL, "ns:getSensorEmerCount");
	case SOAP_TYPE_cmxDeviceService_ns__getSensorEmerCountResponse:
		return soap_in_ns__getSensorEmerCountResponse(soap, NULL, NULL, "ns:getSensorEmerCountResponse");
	case SOAP_TYPE_cmxDeviceService_ns__FanSystemEvent:
		return soap_in_ns__FanSystemEvent(soap, NULL, NULL, "ns:FanSystemEvent");
	case SOAP_TYPE_cmxDeviceService_ns__FanSystemEventResponse:
		return soap_in_ns__FanSystemEventResponse(soap, NULL, NULL, "ns:FanSystemEventResponse");
	case SOAP_TYPE_cmxDeviceService_ns__setFanSystem:
		return soap_in_ns__setFanSystem(soap, NULL, NULL, "ns:setFanSystem");
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystem:
		return soap_in_ns__getFanSystem(soap, NULL, NULL, "ns:getFanSystem");
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemItem:
		return soap_in_ns__getFanSystemItem(soap, NULL, NULL, "ns:getFanSystemItem");
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemPropertyItem:
		return soap_in_ns__getFanSystemPropertyItem(soap, NULL, NULL, "ns:getFanSystemPropertyItem");
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemCount:
		return soap_in_ns__getFanSystemCount(soap, NULL, NULL, "ns:getFanSystemCount");
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemCountResponse:
		return soap_in_ns__getFanSystemCountResponse(soap, NULL, NULL, "ns:getFanSystemCountResponse");
	case SOAP_TYPE_cmxDeviceService_xsd_fanSystemProperty:
		return soap_in_xsd_fanSystemProperty(soap, NULL, NULL, "xsd-fanSystemProperty");
	case SOAP_TYPE_cmxDeviceService_ns__systemAirconEvent:
		return soap_in_ns__systemAirconEvent(soap, NULL, NULL, "ns:systemAirconEvent");
	case SOAP_TYPE_cmxDeviceService_ns__systemAirconEventResponse:
		return soap_in_ns__systemAirconEventResponse(soap, NULL, NULL, "ns:systemAirconEventResponse");
	case SOAP_TYPE_cmxDeviceService_ns__setSystemAircon:
		return soap_in_ns__setSystemAircon(soap, NULL, NULL, "ns:setSystemAircon");
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAircon:
		return soap_in_ns__getSystemAircon(soap, NULL, NULL, "ns:getSystemAircon");
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconItem:
		return soap_in_ns__getSystemAirconItem(soap, NULL, NULL, "ns:getSystemAirconItem");
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconPropertyItem:
		return soap_in_ns__getSystemAirconPropertyItem(soap, NULL, NULL, "ns:getSystemAirconPropertyItem");
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconCount:
		return soap_in_ns__getSystemAirconCount(soap, NULL, NULL, "ns:getSystemAirconCount");
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconCountResponse:
		return soap_in_ns__getSystemAirconCountResponse(soap, NULL, NULL, "ns:getSystemAirconCountResponse");
	case SOAP_TYPE_cmxDeviceService_xsd_systemAirconProperty:
		return soap_in_xsd_systemAirconProperty(soap, NULL, NULL, "xsd-systemAirconProperty");
	case SOAP_TYPE_cmxDeviceService_ns__BundleLightEvent:
		return soap_in_ns__BundleLightEvent(soap, NULL, NULL, "ns:BundleLightEvent");
	case SOAP_TYPE_cmxDeviceService_ns__BundleLightEventResponse:
		return soap_in_ns__BundleLightEventResponse(soap, NULL, NULL, "ns:BundleLightEventResponse");
	case SOAP_TYPE_cmxDeviceService_ns__setBundleLight:
		return soap_in_ns__setBundleLight(soap, NULL, NULL, "ns:setBundleLight");
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLight:
		return soap_in_ns__getBundleLight(soap, NULL, NULL, "ns:getBundleLight");
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightItem:
		return soap_in_ns__getBundleLightItem(soap, NULL, NULL, "ns:getBundleLightItem");
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightPropertyItem:
		return soap_in_ns__getBundleLightPropertyItem(soap, NULL, NULL, "ns:getBundleLightPropertyItem");
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightCount:
		return soap_in_ns__getBundleLightCount(soap, NULL, NULL, "ns:getBundleLightCount");
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightCountResponse:
		return soap_in_ns__getBundleLightCountResponse(soap, NULL, NULL, "ns:getBundleLightCountResponse");
	case SOAP_TYPE_cmxDeviceService_xsd_bundleLightProperty:
		return soap_in_xsd_bundleLightProperty(soap, NULL, NULL, "xsd-bundleLightProperty");
	case SOAP_TYPE_cmxDeviceService_ns__curtainEvent:
		return soap_in_ns__curtainEvent(soap, NULL, NULL, "ns:curtainEvent");
	case SOAP_TYPE_cmxDeviceService_ns__curtainEventResponse:
		return soap_in_ns__curtainEventResponse(soap, NULL, NULL, "ns:curtainEventResponse");
	case SOAP_TYPE_cmxDeviceService_ns__setCurtain:
		return soap_in_ns__setCurtain(soap, NULL, NULL, "ns:setCurtain");
	case SOAP_TYPE_cmxDeviceService_ns__getCurtain:
		return soap_in_ns__getCurtain(soap, NULL, NULL, "ns:getCurtain");
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainItem:
		return soap_in_ns__getCurtainItem(soap, NULL, NULL, "ns:getCurtainItem");
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainPropertyItem:
		return soap_in_ns__getCurtainPropertyItem(soap, NULL, NULL, "ns:getCurtainPropertyItem");
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainCount:
		return soap_in_ns__getCurtainCount(soap, NULL, NULL, "ns:getCurtainCount");
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainCountResponse:
		return soap_in_ns__getCurtainCountResponse(soap, NULL, NULL, "ns:getCurtainCountResponse");
	case SOAP_TYPE_cmxDeviceService_xsd_curtainProperty:
		return soap_in_xsd_curtainProperty(soap, NULL, NULL, "xsd-curtainProperty");
	case SOAP_TYPE_cmxDeviceService_ns__gasValveEvent:
		return soap_in_ns__gasValveEvent(soap, NULL, NULL, "ns:gasValveEvent");
	case SOAP_TYPE_cmxDeviceService_ns__gasValveEventResponse:
		return soap_in_ns__gasValveEventResponse(soap, NULL, NULL, "ns:gasValveEventResponse");
	case SOAP_TYPE_cmxDeviceService_ns__setGasValve:
		return soap_in_ns__setGasValve(soap, NULL, NULL, "ns:setGasValve");
	case SOAP_TYPE_cmxDeviceService_ns__getGasValve:
		return soap_in_ns__getGasValve(soap, NULL, NULL, "ns:getGasValve");
	case SOAP_TYPE_cmxDeviceService_ns__getGasValveItem:
		return soap_in_ns__getGasValveItem(soap, NULL, NULL, "ns:getGasValveItem");
	case SOAP_TYPE_cmxDeviceService_ns__getGasValvePropertyItem:
		return soap_in_ns__getGasValvePropertyItem(soap, NULL, NULL, "ns:getGasValvePropertyItem");
	case SOAP_TYPE_cmxDeviceService_ns__getGasValveCount:
		return soap_in_ns__getGasValveCount(soap, NULL, NULL, "ns:getGasValveCount");
	case SOAP_TYPE_cmxDeviceService_ns__getGasValveCountResponse:
		return soap_in_ns__getGasValveCountResponse(soap, NULL, NULL, "ns:getGasValveCountResponse");
	case SOAP_TYPE_cmxDeviceService_xsd_gasValveProperty:
		return soap_in_xsd_gasValveProperty(soap, NULL, NULL, "xsd-gasValveProperty");
	case SOAP_TYPE_cmxDeviceService_ns__lightEvent:
		return soap_in_ns__lightEvent(soap, NULL, NULL, "ns:lightEvent");
	case SOAP_TYPE_cmxDeviceService_ns__lightEventResponse:
		return soap_in_ns__lightEventResponse(soap, NULL, NULL, "ns:lightEventResponse");
	case SOAP_TYPE_cmxDeviceService_ns__setLight:
		return soap_in_ns__setLight(soap, NULL, NULL, "ns:setLight");
	case SOAP_TYPE_cmxDeviceService_ns__getLight:
		return soap_in_ns__getLight(soap, NULL, NULL, "ns:getLight");
	case SOAP_TYPE_cmxDeviceService_ns__getLightItem:
		return soap_in_ns__getLightItem(soap, NULL, NULL, "ns:getLightItem");
	case SOAP_TYPE_cmxDeviceService_ns__getLightPropertyItem:
		return soap_in_ns__getLightPropertyItem(soap, NULL, NULL, "ns:getLightPropertyItem");
	case SOAP_TYPE_cmxDeviceService_ns__getLightCount:
		return soap_in_ns__getLightCount(soap, NULL, NULL, "ns:getLightCount");
	case SOAP_TYPE_cmxDeviceService_ns__getLightCountResponse:
		return soap_in_ns__getLightCountResponse(soap, NULL, NULL, "ns:getLightCountResponse");
	case SOAP_TYPE_cmxDeviceService_xsd_LightProperty:
		return soap_in_xsd_LightProperty(soap, NULL, NULL, "xsd-LightProperty");
	case SOAP_TYPE_cmxDeviceService_ns__boilerEvent:
		return soap_in_ns__boilerEvent(soap, NULL, NULL, "ns:boilerEvent");
	case SOAP_TYPE_cmxDeviceService_ns__boilerEventResponse:
		return soap_in_ns__boilerEventResponse(soap, NULL, NULL, "ns:boilerEventResponse");
	case SOAP_TYPE_cmxDeviceService_ns__setBoiler:
		return soap_in_ns__setBoiler(soap, NULL, NULL, "ns:setBoiler");
	case SOAP_TYPE_cmxDeviceService_ns__getBoiler:
		return soap_in_ns__getBoiler(soap, NULL, NULL, "ns:getBoiler");
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerItem:
		return soap_in_ns__getBoilerItem(soap, NULL, NULL, "ns:getBoilerItem");
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerPropertyItem:
		return soap_in_ns__getBoilerPropertyItem(soap, NULL, NULL, "ns:getBoilerPropertyItem");
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerCount:
		return soap_in_ns__getBoilerCount(soap, NULL, NULL, "ns:getBoilerCount");
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerCountResponse:
		return soap_in_ns__getBoilerCountResponse(soap, NULL, NULL, "ns:getBoilerCountResponse");
	case SOAP_TYPE_cmxDeviceService_xsd_BoilerProperty:
		return soap_in_xsd_BoilerProperty(soap, NULL, NULL, "xsd-BoilerProperty");
	case SOAP_TYPE_cmxDeviceService_ns__deviceCategoryEvent:
		return soap_in_ns__deviceCategoryEvent(soap, NULL, NULL, "ns:deviceCategoryEvent");
	case SOAP_TYPE_cmxDeviceService_ns__deviceCategoryEventResponse:
		return soap_in_ns__deviceCategoryEventResponse(soap, NULL, NULL, "ns:deviceCategoryEventResponse");
	case SOAP_TYPE_cmxDeviceService_ns__setDeviceCategory:
		return soap_in_ns__setDeviceCategory(soap, NULL, NULL, "ns:setDeviceCategory");
	case SOAP_TYPE_cmxDeviceService_ns__getDeviceCategory:
		return soap_in_ns__getDeviceCategory(soap, NULL, NULL, "ns:getDeviceCategory");
	case SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryItem:
		return soap_in_ns__getDeviceCategoryItem(soap, NULL, NULL, "ns:getDeviceCategoryItem");
	case SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryCount:
		return soap_in_ns__getDeviceCategoryCount(soap, NULL, NULL, "ns:getDeviceCategoryCount");
	case SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryCountResponse:
		return soap_in_ns__getDeviceCategoryCountResponse(soap, NULL, NULL, "ns:getDeviceCategoryCountResponse");
	case SOAP_TYPE_cmxDeviceService_xsd_devCategory:
		return soap_in_xsd_devCategory(soap, NULL, NULL, "xsd-devCategory");
	case SOAP_TYPE_cmxDeviceService_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_cmxDeviceService_PointerTons__setSensorEmerResponse:
		return soap_in_PointerTons__setSensorEmerResponse(soap, NULL, NULL, "ns:setSensorEmerResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getSensorEmerResponse:
		return soap_in_PointerTons__getSensorEmerResponse(soap, NULL, NULL, "ns:getSensorEmerResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getSensorEmerItemResponse:
		return soap_in_PointerTons__getSensorEmerItemResponse(soap, NULL, NULL, "ns:getSensorEmerItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__setFanSystemResponse:
		return soap_in_PointerTons__setFanSystemResponse(soap, NULL, NULL, "ns:setFanSystemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getFanSystemResponse:
		return soap_in_PointerTons__getFanSystemResponse(soap, NULL, NULL, "ns:getFanSystemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getFanSystemItemResponse:
		return soap_in_PointerTons__getFanSystemItemResponse(soap, NULL, NULL, "ns:getFanSystemItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getFanSystemPropertyItemResponse:
		return soap_in_PointerTons__getFanSystemPropertyItemResponse(soap, NULL, NULL, "ns:getFanSystemPropertyItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__setSystemAirconResponse:
		return soap_in_PointerTons__setSystemAirconResponse(soap, NULL, NULL, "ns:setSystemAirconResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getSystemAirconResponse:
		return soap_in_PointerTons__getSystemAirconResponse(soap, NULL, NULL, "ns:getSystemAirconResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getSystemAirconItemResponse:
		return soap_in_PointerTons__getSystemAirconItemResponse(soap, NULL, NULL, "ns:getSystemAirconItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getSystemAirconPropertyItemResponse:
		return soap_in_PointerTons__getSystemAirconPropertyItemResponse(soap, NULL, NULL, "ns:getSystemAirconPropertyItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__setBundleLightResponse:
		return soap_in_PointerTons__setBundleLightResponse(soap, NULL, NULL, "ns:setBundleLightResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getBundleLightResponse:
		return soap_in_PointerTons__getBundleLightResponse(soap, NULL, NULL, "ns:getBundleLightResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getBundleLightItemResponse:
		return soap_in_PointerTons__getBundleLightItemResponse(soap, NULL, NULL, "ns:getBundleLightItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getBundleLightPropertyItemResponse:
		return soap_in_PointerTons__getBundleLightPropertyItemResponse(soap, NULL, NULL, "ns:getBundleLightPropertyItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__setCurtainResponse:
		return soap_in_PointerTons__setCurtainResponse(soap, NULL, NULL, "ns:setCurtainResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getCurtainResponse:
		return soap_in_PointerTons__getCurtainResponse(soap, NULL, NULL, "ns:getCurtainResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getCurtainItemResponse:
		return soap_in_PointerTons__getCurtainItemResponse(soap, NULL, NULL, "ns:getCurtainItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getCurtainPropertyItemResponse:
		return soap_in_PointerTons__getCurtainPropertyItemResponse(soap, NULL, NULL, "ns:getCurtainPropertyItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__setGasValveResponse:
		return soap_in_PointerTons__setGasValveResponse(soap, NULL, NULL, "ns:setGasValveResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getGasValveResponse:
		return soap_in_PointerTons__getGasValveResponse(soap, NULL, NULL, "ns:getGasValveResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getGasValveItemResponse:
		return soap_in_PointerTons__getGasValveItemResponse(soap, NULL, NULL, "ns:getGasValveItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getGasValvePropertyItemResponse:
		return soap_in_PointerTons__getGasValvePropertyItemResponse(soap, NULL, NULL, "ns:getGasValvePropertyItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__setLightResponse:
		return soap_in_PointerTons__setLightResponse(soap, NULL, NULL, "ns:setLightResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getLightResponse:
		return soap_in_PointerTons__getLightResponse(soap, NULL, NULL, "ns:getLightResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getLightItemResponse:
		return soap_in_PointerTons__getLightItemResponse(soap, NULL, NULL, "ns:getLightItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getLightPropertyItemResponse:
		return soap_in_PointerTons__getLightPropertyItemResponse(soap, NULL, NULL, "ns:getLightPropertyItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__setBoilerResponse:
		return soap_in_PointerTons__setBoilerResponse(soap, NULL, NULL, "ns:setBoilerResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getBoilerResponse:
		return soap_in_PointerTons__getBoilerResponse(soap, NULL, NULL, "ns:getBoilerResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getBoilerItemResponse:
		return soap_in_PointerTons__getBoilerItemResponse(soap, NULL, NULL, "ns:getBoilerItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getBoilerPropertyItemResponse:
		return soap_in_PointerTons__getBoilerPropertyItemResponse(soap, NULL, NULL, "ns:getBoilerPropertyItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__setDeviceCategoryResponse:
		return soap_in_PointerTons__setDeviceCategoryResponse(soap, NULL, NULL, "ns:setDeviceCategoryResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getDeviceCategoryResponse:
		return soap_in_PointerTons__getDeviceCategoryResponse(soap, NULL, NULL, "ns:getDeviceCategoryResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getDeviceCategoryItemResponse:
		return soap_in_PointerTons__getDeviceCategoryItemResponse(soap, NULL, NULL, "ns:getDeviceCategoryItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_cmxDeviceService_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_cmxDeviceService__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_cmxDeviceService_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_cmxDeviceService_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_cmxDeviceService_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_cmxDeviceService_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_cmxDeviceService_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:sensorEmerFunc"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__sensorEmerFunc;
			return soap_in_ns__sensorEmerFunc(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:enum-sensorEmer"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__enum_sensorEmer;
			return soap_in_ns__enum_sensorEmer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:fanSystemFunc"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__fanSystemFunc;
			return soap_in_ns__fanSystemFunc(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:enum-fanSystem"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__enum_fanSystem;
			return soap_in_ns__enum_fanSystem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:systemAirconFunc"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__systemAirconFunc;
			return soap_in_ns__systemAirconFunc(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:enum-systemAircon"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__enum_systemAircon;
			return soap_in_ns__enum_systemAircon(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:bundleLightFunc"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__bundleLightFunc;
			return soap_in_ns__bundleLightFunc(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:enum-bundleLight"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__enum_bundleLight;
			return soap_in_ns__enum_bundleLight(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:curtainFunc"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__curtainFunc;
			return soap_in_ns__curtainFunc(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:enum-curtain"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__enum_curtain;
			return soap_in_ns__enum_curtain(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gasValveFunc"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__gasValveFunc;
			return soap_in_ns__gasValveFunc(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:enum-gasValve"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__enum_gasValve;
			return soap_in_ns__enum_gasValve(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:lightFunc"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__lightFunc;
			return soap_in_ns__lightFunc(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:enum-light"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__enum_light;
			return soap_in_ns__enum_light(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:boilerFunc"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__boilerFunc;
			return soap_in_ns__boilerFunc(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:enum-boiler"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__enum_boiler;
			return soap_in_ns__enum_boiler(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:deviceCategoryFunc"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__deviceCategoryFunc;
			return soap_in_ns__deviceCategoryFunc(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:enum-config-Common-Error"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__enum_config_Common_Error;
			return soap_in_ns__enum_config_Common_Error(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:enum-device-connect-check"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__enum_device_connect_check;
			return soap_in_ns__enum_device_connect_check(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:enum-devError"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__enum_devError;
			return soap_in_ns__enum_devError(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:enum-devInfo"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__enum_devInfo;
			return soap_in_ns__enum_devInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setSensorEmerResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__setSensorEmerResponse;
			return soap_in_ns__setSensorEmerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getSensorEmerResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getSensorEmerResponse;
			return soap_in_ns__getSensorEmerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getSensorEmerItemResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getSensorEmerItemResponse;
			return soap_in_ns__getSensorEmerItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:sensorEmer"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__sensorEmer;
			return soap_in_ns__sensorEmer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setFanSystemResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__setFanSystemResponse;
			return soap_in_ns__setFanSystemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getFanSystemResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getFanSystemResponse;
			return soap_in_ns__getFanSystemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getFanSystemItemResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getFanSystemItemResponse;
			return soap_in_ns__getFanSystemItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getFanSystemPropertyItemResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getFanSystemPropertyItemResponse;
			return soap_in_ns__getFanSystemPropertyItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:fanSystem"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__fanSystem;
			return soap_in_ns__fanSystem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setSystemAirconResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__setSystemAirconResponse;
			return soap_in_ns__setSystemAirconResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getSystemAirconResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getSystemAirconResponse;
			return soap_in_ns__getSystemAirconResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getSystemAirconItemResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getSystemAirconItemResponse;
			return soap_in_ns__getSystemAirconItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getSystemAirconPropertyItemResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getSystemAirconPropertyItemResponse;
			return soap_in_ns__getSystemAirconPropertyItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:systemAircon"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__systemAircon;
			return soap_in_ns__systemAircon(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setBundleLightResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__setBundleLightResponse;
			return soap_in_ns__setBundleLightResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getBundleLightResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getBundleLightResponse;
			return soap_in_ns__getBundleLightResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getBundleLightItemResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getBundleLightItemResponse;
			return soap_in_ns__getBundleLightItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getBundleLightPropertyItemResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getBundleLightPropertyItemResponse;
			return soap_in_ns__getBundleLightPropertyItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:bundleLight"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__bundleLight;
			return soap_in_ns__bundleLight(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setCurtainResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__setCurtainResponse;
			return soap_in_ns__setCurtainResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getCurtainResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getCurtainResponse;
			return soap_in_ns__getCurtainResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getCurtainItemResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getCurtainItemResponse;
			return soap_in_ns__getCurtainItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getCurtainPropertyItemResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getCurtainPropertyItemResponse;
			return soap_in_ns__getCurtainPropertyItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:curtain"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__curtain;
			return soap_in_ns__curtain(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setGasValveResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__setGasValveResponse;
			return soap_in_ns__setGasValveResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getGasValveResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getGasValveResponse;
			return soap_in_ns__getGasValveResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getGasValveItemResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getGasValveItemResponse;
			return soap_in_ns__getGasValveItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getGasValvePropertyItemResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getGasValvePropertyItemResponse;
			return soap_in_ns__getGasValvePropertyItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gasValve"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__gasValve;
			return soap_in_ns__gasValve(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setLightResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__setLightResponse;
			return soap_in_ns__setLightResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getLightResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getLightResponse;
			return soap_in_ns__getLightResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getLightItemResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getLightItemResponse;
			return soap_in_ns__getLightItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getLightPropertyItemResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getLightPropertyItemResponse;
			return soap_in_ns__getLightPropertyItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:light"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__light;
			return soap_in_ns__light(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setBoilerResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__setBoilerResponse;
			return soap_in_ns__setBoilerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getBoilerResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getBoilerResponse;
			return soap_in_ns__getBoilerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getBoilerItemResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getBoilerItemResponse;
			return soap_in_ns__getBoilerItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getBoilerPropertyItemResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getBoilerPropertyItemResponse;
			return soap_in_ns__getBoilerPropertyItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:boiler"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__boiler;
			return soap_in_ns__boiler(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setDeviceCategoryResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__setDeviceCategoryResponse;
			return soap_in_ns__setDeviceCategoryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getDeviceCategoryResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryResponse;
			return soap_in_ns__getDeviceCategoryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getDeviceCategoryItemResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryItemResponse;
			return soap_in_ns__getDeviceCategoryItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:deviceCategory"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__deviceCategory;
			return soap_in_ns__deviceCategory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:rootDevice"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__rootDevice;
			return soap_in_ns__rootDevice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:subcribeEvent"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__subcribeEvent;
			return soap_in_ns__subcribeEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:subcribeEventResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__subcribeEventResponse;
			return soap_in_ns__subcribeEventResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:sensorEmerEvent"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__sensorEmerEvent;
			return soap_in_ns__sensorEmerEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:sensorEmerEventResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__sensorEmerEventResponse;
			return soap_in_ns__sensorEmerEventResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setSensorEmer"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__setSensorEmer;
			return soap_in_ns__setSensorEmer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getSensorEmer"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getSensorEmer;
			return soap_in_ns__getSensorEmer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getSensorEmerItem"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getSensorEmerItem;
			return soap_in_ns__getSensorEmerItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getSensorEmerCount"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getSensorEmerCount;
			return soap_in_ns__getSensorEmerCount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getSensorEmerCountResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getSensorEmerCountResponse;
			return soap_in_ns__getSensorEmerCountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:FanSystemEvent"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__FanSystemEvent;
			return soap_in_ns__FanSystemEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:FanSystemEventResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__FanSystemEventResponse;
			return soap_in_ns__FanSystemEventResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setFanSystem"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__setFanSystem;
			return soap_in_ns__setFanSystem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getFanSystem"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getFanSystem;
			return soap_in_ns__getFanSystem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getFanSystemItem"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getFanSystemItem;
			return soap_in_ns__getFanSystemItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getFanSystemPropertyItem"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getFanSystemPropertyItem;
			return soap_in_ns__getFanSystemPropertyItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getFanSystemCount"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getFanSystemCount;
			return soap_in_ns__getFanSystemCount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getFanSystemCountResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getFanSystemCountResponse;
			return soap_in_ns__getFanSystemCountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd-fanSystemProperty"))
		{	*type = SOAP_TYPE_cmxDeviceService_xsd_fanSystemProperty;
			return soap_in_xsd_fanSystemProperty(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:systemAirconEvent"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__systemAirconEvent;
			return soap_in_ns__systemAirconEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:systemAirconEventResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__systemAirconEventResponse;
			return soap_in_ns__systemAirconEventResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setSystemAircon"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__setSystemAircon;
			return soap_in_ns__setSystemAircon(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getSystemAircon"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getSystemAircon;
			return soap_in_ns__getSystemAircon(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getSystemAirconItem"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getSystemAirconItem;
			return soap_in_ns__getSystemAirconItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getSystemAirconPropertyItem"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getSystemAirconPropertyItem;
			return soap_in_ns__getSystemAirconPropertyItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getSystemAirconCount"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getSystemAirconCount;
			return soap_in_ns__getSystemAirconCount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getSystemAirconCountResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getSystemAirconCountResponse;
			return soap_in_ns__getSystemAirconCountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd-systemAirconProperty"))
		{	*type = SOAP_TYPE_cmxDeviceService_xsd_systemAirconProperty;
			return soap_in_xsd_systemAirconProperty(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:BundleLightEvent"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__BundleLightEvent;
			return soap_in_ns__BundleLightEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:BundleLightEventResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__BundleLightEventResponse;
			return soap_in_ns__BundleLightEventResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setBundleLight"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__setBundleLight;
			return soap_in_ns__setBundleLight(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getBundleLight"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getBundleLight;
			return soap_in_ns__getBundleLight(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getBundleLightItem"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getBundleLightItem;
			return soap_in_ns__getBundleLightItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getBundleLightPropertyItem"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getBundleLightPropertyItem;
			return soap_in_ns__getBundleLightPropertyItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getBundleLightCount"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getBundleLightCount;
			return soap_in_ns__getBundleLightCount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getBundleLightCountResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getBundleLightCountResponse;
			return soap_in_ns__getBundleLightCountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd-bundleLightProperty"))
		{	*type = SOAP_TYPE_cmxDeviceService_xsd_bundleLightProperty;
			return soap_in_xsd_bundleLightProperty(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:curtainEvent"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__curtainEvent;
			return soap_in_ns__curtainEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:curtainEventResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__curtainEventResponse;
			return soap_in_ns__curtainEventResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setCurtain"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__setCurtain;
			return soap_in_ns__setCurtain(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getCurtain"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getCurtain;
			return soap_in_ns__getCurtain(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getCurtainItem"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getCurtainItem;
			return soap_in_ns__getCurtainItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getCurtainPropertyItem"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getCurtainPropertyItem;
			return soap_in_ns__getCurtainPropertyItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getCurtainCount"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getCurtainCount;
			return soap_in_ns__getCurtainCount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getCurtainCountResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getCurtainCountResponse;
			return soap_in_ns__getCurtainCountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd-curtainProperty"))
		{	*type = SOAP_TYPE_cmxDeviceService_xsd_curtainProperty;
			return soap_in_xsd_curtainProperty(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gasValveEvent"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__gasValveEvent;
			return soap_in_ns__gasValveEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:gasValveEventResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__gasValveEventResponse;
			return soap_in_ns__gasValveEventResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setGasValve"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__setGasValve;
			return soap_in_ns__setGasValve(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getGasValve"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getGasValve;
			return soap_in_ns__getGasValve(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getGasValveItem"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getGasValveItem;
			return soap_in_ns__getGasValveItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getGasValvePropertyItem"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getGasValvePropertyItem;
			return soap_in_ns__getGasValvePropertyItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getGasValveCount"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getGasValveCount;
			return soap_in_ns__getGasValveCount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getGasValveCountResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getGasValveCountResponse;
			return soap_in_ns__getGasValveCountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd-gasValveProperty"))
		{	*type = SOAP_TYPE_cmxDeviceService_xsd_gasValveProperty;
			return soap_in_xsd_gasValveProperty(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:lightEvent"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__lightEvent;
			return soap_in_ns__lightEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:lightEventResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__lightEventResponse;
			return soap_in_ns__lightEventResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setLight"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__setLight;
			return soap_in_ns__setLight(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getLight"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getLight;
			return soap_in_ns__getLight(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getLightItem"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getLightItem;
			return soap_in_ns__getLightItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getLightPropertyItem"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getLightPropertyItem;
			return soap_in_ns__getLightPropertyItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getLightCount"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getLightCount;
			return soap_in_ns__getLightCount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getLightCountResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getLightCountResponse;
			return soap_in_ns__getLightCountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd-LightProperty"))
		{	*type = SOAP_TYPE_cmxDeviceService_xsd_LightProperty;
			return soap_in_xsd_LightProperty(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:boilerEvent"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__boilerEvent;
			return soap_in_ns__boilerEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:boilerEventResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__boilerEventResponse;
			return soap_in_ns__boilerEventResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setBoiler"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__setBoiler;
			return soap_in_ns__setBoiler(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getBoiler"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getBoiler;
			return soap_in_ns__getBoiler(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getBoilerItem"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getBoilerItem;
			return soap_in_ns__getBoilerItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getBoilerPropertyItem"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getBoilerPropertyItem;
			return soap_in_ns__getBoilerPropertyItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getBoilerCount"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getBoilerCount;
			return soap_in_ns__getBoilerCount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getBoilerCountResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getBoilerCountResponse;
			return soap_in_ns__getBoilerCountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd-BoilerProperty"))
		{	*type = SOAP_TYPE_cmxDeviceService_xsd_BoilerProperty;
			return soap_in_xsd_BoilerProperty(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:deviceCategoryEvent"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__deviceCategoryEvent;
			return soap_in_ns__deviceCategoryEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:deviceCategoryEventResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__deviceCategoryEventResponse;
			return soap_in_ns__deviceCategoryEventResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:setDeviceCategory"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__setDeviceCategory;
			return soap_in_ns__setDeviceCategory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getDeviceCategory"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getDeviceCategory;
			return soap_in_ns__getDeviceCategory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getDeviceCategoryItem"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryItem;
			return soap_in_ns__getDeviceCategoryItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getDeviceCategoryCount"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryCount;
			return soap_in_ns__getDeviceCategoryCount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getDeviceCategoryCountResponse"))
		{	*type = SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryCountResponse;
			return soap_in_ns__getDeviceCategoryCountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd-devCategory"))
		{	*type = SOAP_TYPE_cmxDeviceService_xsd_devCategory;
			return soap_in_xsd_devCategory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_cmxDeviceService_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "QName"))
		{	char **s;
			*type = SOAP_TYPE_cmxDeviceService__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_cmxDeviceService_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
			return soap->error = SOAP_TAG_MISMATCH;
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n", soap->tag, soap->level, soap->body));
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_cmxDeviceService_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_cmxDeviceService_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_cmxDeviceService_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_cmxDeviceService_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_cmxDeviceService_ns__sensorEmerFunc:
		return soap_out_ns__sensorEmerFunc(soap, tag, id, (const enum ns__sensorEmerFunc *)ptr, "ns:sensorEmerFunc");
	case SOAP_TYPE_cmxDeviceService_ns__enum_sensorEmer:
		return soap_out_ns__enum_sensorEmer(soap, tag, id, (const enum ns__enum_sensorEmer *)ptr, "ns:enum-sensorEmer");
	case SOAP_TYPE_cmxDeviceService_ns__fanSystemFunc:
		return soap_out_ns__fanSystemFunc(soap, tag, id, (const enum ns__fanSystemFunc *)ptr, "ns:fanSystemFunc");
	case SOAP_TYPE_cmxDeviceService_ns__enum_fanSystem:
		return soap_out_ns__enum_fanSystem(soap, tag, id, (const enum ns__enum_fanSystem *)ptr, "ns:enum-fanSystem");
	case SOAP_TYPE_cmxDeviceService_ns__systemAirconFunc:
		return soap_out_ns__systemAirconFunc(soap, tag, id, (const enum ns__systemAirconFunc *)ptr, "ns:systemAirconFunc");
	case SOAP_TYPE_cmxDeviceService_ns__enum_systemAircon:
		return soap_out_ns__enum_systemAircon(soap, tag, id, (const enum ns__enum_systemAircon *)ptr, "ns:enum-systemAircon");
	case SOAP_TYPE_cmxDeviceService_ns__bundleLightFunc:
		return soap_out_ns__bundleLightFunc(soap, tag, id, (const enum ns__bundleLightFunc *)ptr, "ns:bundleLightFunc");
	case SOAP_TYPE_cmxDeviceService_ns__enum_bundleLight:
		return soap_out_ns__enum_bundleLight(soap, tag, id, (const enum ns__enum_bundleLight *)ptr, "ns:enum-bundleLight");
	case SOAP_TYPE_cmxDeviceService_ns__curtainFunc:
		return soap_out_ns__curtainFunc(soap, tag, id, (const enum ns__curtainFunc *)ptr, "ns:curtainFunc");
	case SOAP_TYPE_cmxDeviceService_ns__enum_curtain:
		return soap_out_ns__enum_curtain(soap, tag, id, (const enum ns__enum_curtain *)ptr, "ns:enum-curtain");
	case SOAP_TYPE_cmxDeviceService_ns__gasValveFunc:
		return soap_out_ns__gasValveFunc(soap, tag, id, (const enum ns__gasValveFunc *)ptr, "ns:gasValveFunc");
	case SOAP_TYPE_cmxDeviceService_ns__enum_gasValve:
		return soap_out_ns__enum_gasValve(soap, tag, id, (const enum ns__enum_gasValve *)ptr, "ns:enum-gasValve");
	case SOAP_TYPE_cmxDeviceService_ns__lightFunc:
		return soap_out_ns__lightFunc(soap, tag, id, (const enum ns__lightFunc *)ptr, "ns:lightFunc");
	case SOAP_TYPE_cmxDeviceService_ns__enum_light:
		return soap_out_ns__enum_light(soap, tag, id, (const enum ns__enum_light *)ptr, "ns:enum-light");
	case SOAP_TYPE_cmxDeviceService_ns__boilerFunc:
		return soap_out_ns__boilerFunc(soap, tag, id, (const enum ns__boilerFunc *)ptr, "ns:boilerFunc");
	case SOAP_TYPE_cmxDeviceService_ns__enum_boiler:
		return soap_out_ns__enum_boiler(soap, tag, id, (const enum ns__enum_boiler *)ptr, "ns:enum-boiler");
	case SOAP_TYPE_cmxDeviceService_ns__deviceCategoryFunc:
		return soap_out_ns__deviceCategoryFunc(soap, tag, id, (const enum ns__deviceCategoryFunc *)ptr, "ns:deviceCategoryFunc");
	case SOAP_TYPE_cmxDeviceService_ns__enum_config_Common_Error:
		return soap_out_ns__enum_config_Common_Error(soap, tag, id, (const enum ns__enum_config_Common_Error *)ptr, "ns:enum-config-Common-Error");
	case SOAP_TYPE_cmxDeviceService_ns__enum_device_connect_check:
		return soap_out_ns__enum_device_connect_check(soap, tag, id, (const enum ns__enum_device_connect_check *)ptr, "ns:enum-device-connect-check");
	case SOAP_TYPE_cmxDeviceService_ns__enum_devError:
		return soap_out_ns__enum_devError(soap, tag, id, (const enum ns__enum_devError *)ptr, "ns:enum-devError");
	case SOAP_TYPE_cmxDeviceService_ns__enum_devInfo:
		return soap_out_ns__enum_devInfo(soap, tag, id, (const enum ns__enum_devInfo *)ptr, "ns:enum-devInfo");
	case SOAP_TYPE_cmxDeviceService_ns__setSensorEmerResponse:
		return ((ns__setSensorEmerResponse *)ptr)->soap_out(soap, tag, id, "ns:setSensorEmerResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getSensorEmerResponse:
		return ((ns__getSensorEmerResponse *)ptr)->soap_out(soap, tag, id, "ns:getSensorEmerResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getSensorEmerItemResponse:
		return ((ns__getSensorEmerItemResponse *)ptr)->soap_out(soap, tag, id, "ns:getSensorEmerItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__sensorEmer:
		return ((ns__sensorEmer *)ptr)->soap_out(soap, tag, id, "ns:sensorEmer");
	case SOAP_TYPE_cmxDeviceService_ns__setFanSystemResponse:
		return ((ns__setFanSystemResponse *)ptr)->soap_out(soap, tag, id, "ns:setFanSystemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemResponse:
		return ((ns__getFanSystemResponse *)ptr)->soap_out(soap, tag, id, "ns:getFanSystemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemItemResponse:
		return ((ns__getFanSystemItemResponse *)ptr)->soap_out(soap, tag, id, "ns:getFanSystemItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemPropertyItemResponse:
		return ((ns__getFanSystemPropertyItemResponse *)ptr)->soap_out(soap, tag, id, "ns:getFanSystemPropertyItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__fanSystem:
		return ((ns__fanSystem *)ptr)->soap_out(soap, tag, id, "ns:fanSystem");
	case SOAP_TYPE_cmxDeviceService_ns__setSystemAirconResponse:
		return ((ns__setSystemAirconResponse *)ptr)->soap_out(soap, tag, id, "ns:setSystemAirconResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconResponse:
		return ((ns__getSystemAirconResponse *)ptr)->soap_out(soap, tag, id, "ns:getSystemAirconResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconItemResponse:
		return ((ns__getSystemAirconItemResponse *)ptr)->soap_out(soap, tag, id, "ns:getSystemAirconItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconPropertyItemResponse:
		return ((ns__getSystemAirconPropertyItemResponse *)ptr)->soap_out(soap, tag, id, "ns:getSystemAirconPropertyItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__systemAircon:
		return ((ns__systemAircon *)ptr)->soap_out(soap, tag, id, "ns:systemAircon");
	case SOAP_TYPE_cmxDeviceService_ns__setBundleLightResponse:
		return ((ns__setBundleLightResponse *)ptr)->soap_out(soap, tag, id, "ns:setBundleLightResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightResponse:
		return ((ns__getBundleLightResponse *)ptr)->soap_out(soap, tag, id, "ns:getBundleLightResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightItemResponse:
		return ((ns__getBundleLightItemResponse *)ptr)->soap_out(soap, tag, id, "ns:getBundleLightItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightPropertyItemResponse:
		return ((ns__getBundleLightPropertyItemResponse *)ptr)->soap_out(soap, tag, id, "ns:getBundleLightPropertyItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__bundleLight:
		return ((ns__bundleLight *)ptr)->soap_out(soap, tag, id, "ns:bundleLight");
	case SOAP_TYPE_cmxDeviceService_ns__setCurtainResponse:
		return ((ns__setCurtainResponse *)ptr)->soap_out(soap, tag, id, "ns:setCurtainResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainResponse:
		return ((ns__getCurtainResponse *)ptr)->soap_out(soap, tag, id, "ns:getCurtainResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainItemResponse:
		return ((ns__getCurtainItemResponse *)ptr)->soap_out(soap, tag, id, "ns:getCurtainItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainPropertyItemResponse:
		return ((ns__getCurtainPropertyItemResponse *)ptr)->soap_out(soap, tag, id, "ns:getCurtainPropertyItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__curtain:
		return ((ns__curtain *)ptr)->soap_out(soap, tag, id, "ns:curtain");
	case SOAP_TYPE_cmxDeviceService_ns__setGasValveResponse:
		return ((ns__setGasValveResponse *)ptr)->soap_out(soap, tag, id, "ns:setGasValveResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getGasValveResponse:
		return ((ns__getGasValveResponse *)ptr)->soap_out(soap, tag, id, "ns:getGasValveResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getGasValveItemResponse:
		return ((ns__getGasValveItemResponse *)ptr)->soap_out(soap, tag, id, "ns:getGasValveItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getGasValvePropertyItemResponse:
		return ((ns__getGasValvePropertyItemResponse *)ptr)->soap_out(soap, tag, id, "ns:getGasValvePropertyItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__gasValve:
		return ((ns__gasValve *)ptr)->soap_out(soap, tag, id, "ns:gasValve");
	case SOAP_TYPE_cmxDeviceService_ns__setLightResponse:
		return ((ns__setLightResponse *)ptr)->soap_out(soap, tag, id, "ns:setLightResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getLightResponse:
		return ((ns__getLightResponse *)ptr)->soap_out(soap, tag, id, "ns:getLightResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getLightItemResponse:
		return ((ns__getLightItemResponse *)ptr)->soap_out(soap, tag, id, "ns:getLightItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getLightPropertyItemResponse:
		return ((ns__getLightPropertyItemResponse *)ptr)->soap_out(soap, tag, id, "ns:getLightPropertyItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__light:
		return ((ns__light *)ptr)->soap_out(soap, tag, id, "ns:light");
	case SOAP_TYPE_cmxDeviceService_ns__setBoilerResponse:
		return ((ns__setBoilerResponse *)ptr)->soap_out(soap, tag, id, "ns:setBoilerResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerResponse:
		return ((ns__getBoilerResponse *)ptr)->soap_out(soap, tag, id, "ns:getBoilerResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerItemResponse:
		return ((ns__getBoilerItemResponse *)ptr)->soap_out(soap, tag, id, "ns:getBoilerItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerPropertyItemResponse:
		return ((ns__getBoilerPropertyItemResponse *)ptr)->soap_out(soap, tag, id, "ns:getBoilerPropertyItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__boiler:
		return ((ns__boiler *)ptr)->soap_out(soap, tag, id, "ns:boiler");
	case SOAP_TYPE_cmxDeviceService_ns__setDeviceCategoryResponse:
		return ((ns__setDeviceCategoryResponse *)ptr)->soap_out(soap, tag, id, "ns:setDeviceCategoryResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryResponse:
		return ((ns__getDeviceCategoryResponse *)ptr)->soap_out(soap, tag, id, "ns:getDeviceCategoryResponse");
	case SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryItemResponse:
		return ((ns__getDeviceCategoryItemResponse *)ptr)->soap_out(soap, tag, id, "ns:getDeviceCategoryItemResponse");
	case SOAP_TYPE_cmxDeviceService_ns__deviceCategory:
		return ((ns__deviceCategory *)ptr)->soap_out(soap, tag, id, "ns:deviceCategory");
	case SOAP_TYPE_cmxDeviceService_ns__rootDevice:
		return ((ns__rootDevice *)ptr)->soap_out(soap, tag, id, "ns:rootDevice");
	case SOAP_TYPE_cmxDeviceService_ns__subcribeEvent:
		return soap_out_ns__subcribeEvent(soap, tag, id, (const struct ns__subcribeEvent *)ptr, "ns:subcribeEvent");
	case SOAP_TYPE_cmxDeviceService_ns__subcribeEventResponse:
		return soap_out_ns__subcribeEventResponse(soap, tag, id, (const struct ns__subcribeEventResponse *)ptr, "ns:subcribeEventResponse");
	case SOAP_TYPE_cmxDeviceService_ns__sensorEmerEvent:
		return soap_out_ns__sensorEmerEvent(soap, tag, id, (const struct ns__sensorEmerEvent *)ptr, "ns:sensorEmerEvent");
	case SOAP_TYPE_cmxDeviceService_ns__sensorEmerEventResponse:
		return soap_out_ns__sensorEmerEventResponse(soap, tag, id, (const struct ns__sensorEmerEventResponse *)ptr, "ns:sensorEmerEventResponse");
	case SOAP_TYPE_cmxDeviceService_ns__setSensorEmer:
		return soap_out_ns__setSensorEmer(soap, tag, id, (const struct ns__setSensorEmer *)ptr, "ns:setSensorEmer");
	case SOAP_TYPE_cmxDeviceService_ns__getSensorEmer:
		return soap_out_ns__getSensorEmer(soap, tag, id, (const struct ns__getSensorEmer *)ptr, "ns:getSensorEmer");
	case SOAP_TYPE_cmxDeviceService_ns__getSensorEmerItem:
		return soap_out_ns__getSensorEmerItem(soap, tag, id, (const struct ns__getSensorEmerItem *)ptr, "ns:getSensorEmerItem");
	case SOAP_TYPE_cmxDeviceService_ns__getSensorEmerCount:
		return soap_out_ns__getSensorEmerCount(soap, tag, id, (const struct ns__getSensorEmerCount *)ptr, "ns:getSensorEmerCount");
	case SOAP_TYPE_cmxDeviceService_ns__getSensorEmerCountResponse:
		return soap_out_ns__getSensorEmerCountResponse(soap, tag, id, (const struct ns__getSensorEmerCountResponse *)ptr, "ns:getSensorEmerCountResponse");
	case SOAP_TYPE_cmxDeviceService_ns__FanSystemEvent:
		return soap_out_ns__FanSystemEvent(soap, tag, id, (const struct ns__FanSystemEvent *)ptr, "ns:FanSystemEvent");
	case SOAP_TYPE_cmxDeviceService_ns__FanSystemEventResponse:
		return soap_out_ns__FanSystemEventResponse(soap, tag, id, (const struct ns__FanSystemEventResponse *)ptr, "ns:FanSystemEventResponse");
	case SOAP_TYPE_cmxDeviceService_ns__setFanSystem:
		return soap_out_ns__setFanSystem(soap, tag, id, (const struct ns__setFanSystem *)ptr, "ns:setFanSystem");
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystem:
		return soap_out_ns__getFanSystem(soap, tag, id, (const struct ns__getFanSystem *)ptr, "ns:getFanSystem");
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemItem:
		return soap_out_ns__getFanSystemItem(soap, tag, id, (const struct ns__getFanSystemItem *)ptr, "ns:getFanSystemItem");
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemPropertyItem:
		return soap_out_ns__getFanSystemPropertyItem(soap, tag, id, (const struct ns__getFanSystemPropertyItem *)ptr, "ns:getFanSystemPropertyItem");
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemCount:
		return soap_out_ns__getFanSystemCount(soap, tag, id, (const struct ns__getFanSystemCount *)ptr, "ns:getFanSystemCount");
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemCountResponse:
		return soap_out_ns__getFanSystemCountResponse(soap, tag, id, (const struct ns__getFanSystemCountResponse *)ptr, "ns:getFanSystemCountResponse");
	case SOAP_TYPE_cmxDeviceService_xsd_fanSystemProperty:
		return soap_out_xsd_fanSystemProperty(soap, tag, id, (const struct xsd_fanSystemProperty *)ptr, "xsd-fanSystemProperty");
	case SOAP_TYPE_cmxDeviceService_ns__systemAirconEvent:
		return soap_out_ns__systemAirconEvent(soap, tag, id, (const struct ns__systemAirconEvent *)ptr, "ns:systemAirconEvent");
	case SOAP_TYPE_cmxDeviceService_ns__systemAirconEventResponse:
		return soap_out_ns__systemAirconEventResponse(soap, tag, id, (const struct ns__systemAirconEventResponse *)ptr, "ns:systemAirconEventResponse");
	case SOAP_TYPE_cmxDeviceService_ns__setSystemAircon:
		return soap_out_ns__setSystemAircon(soap, tag, id, (const struct ns__setSystemAircon *)ptr, "ns:setSystemAircon");
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAircon:
		return soap_out_ns__getSystemAircon(soap, tag, id, (const struct ns__getSystemAircon *)ptr, "ns:getSystemAircon");
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconItem:
		return soap_out_ns__getSystemAirconItem(soap, tag, id, (const struct ns__getSystemAirconItem *)ptr, "ns:getSystemAirconItem");
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconPropertyItem:
		return soap_out_ns__getSystemAirconPropertyItem(soap, tag, id, (const struct ns__getSystemAirconPropertyItem *)ptr, "ns:getSystemAirconPropertyItem");
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconCount:
		return soap_out_ns__getSystemAirconCount(soap, tag, id, (const struct ns__getSystemAirconCount *)ptr, "ns:getSystemAirconCount");
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconCountResponse:
		return soap_out_ns__getSystemAirconCountResponse(soap, tag, id, (const struct ns__getSystemAirconCountResponse *)ptr, "ns:getSystemAirconCountResponse");
	case SOAP_TYPE_cmxDeviceService_xsd_systemAirconProperty:
		return soap_out_xsd_systemAirconProperty(soap, tag, id, (const struct xsd_systemAirconProperty *)ptr, "xsd-systemAirconProperty");
	case SOAP_TYPE_cmxDeviceService_ns__BundleLightEvent:
		return soap_out_ns__BundleLightEvent(soap, tag, id, (const struct ns__BundleLightEvent *)ptr, "ns:BundleLightEvent");
	case SOAP_TYPE_cmxDeviceService_ns__BundleLightEventResponse:
		return soap_out_ns__BundleLightEventResponse(soap, tag, id, (const struct ns__BundleLightEventResponse *)ptr, "ns:BundleLightEventResponse");
	case SOAP_TYPE_cmxDeviceService_ns__setBundleLight:
		return soap_out_ns__setBundleLight(soap, tag, id, (const struct ns__setBundleLight *)ptr, "ns:setBundleLight");
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLight:
		return soap_out_ns__getBundleLight(soap, tag, id, (const struct ns__getBundleLight *)ptr, "ns:getBundleLight");
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightItem:
		return soap_out_ns__getBundleLightItem(soap, tag, id, (const struct ns__getBundleLightItem *)ptr, "ns:getBundleLightItem");
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightPropertyItem:
		return soap_out_ns__getBundleLightPropertyItem(soap, tag, id, (const struct ns__getBundleLightPropertyItem *)ptr, "ns:getBundleLightPropertyItem");
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightCount:
		return soap_out_ns__getBundleLightCount(soap, tag, id, (const struct ns__getBundleLightCount *)ptr, "ns:getBundleLightCount");
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightCountResponse:
		return soap_out_ns__getBundleLightCountResponse(soap, tag, id, (const struct ns__getBundleLightCountResponse *)ptr, "ns:getBundleLightCountResponse");
	case SOAP_TYPE_cmxDeviceService_xsd_bundleLightProperty:
		return soap_out_xsd_bundleLightProperty(soap, tag, id, (const struct xsd_bundleLightProperty *)ptr, "xsd-bundleLightProperty");
	case SOAP_TYPE_cmxDeviceService_ns__curtainEvent:
		return soap_out_ns__curtainEvent(soap, tag, id, (const struct ns__curtainEvent *)ptr, "ns:curtainEvent");
	case SOAP_TYPE_cmxDeviceService_ns__curtainEventResponse:
		return soap_out_ns__curtainEventResponse(soap, tag, id, (const struct ns__curtainEventResponse *)ptr, "ns:curtainEventResponse");
	case SOAP_TYPE_cmxDeviceService_ns__setCurtain:
		return soap_out_ns__setCurtain(soap, tag, id, (const struct ns__setCurtain *)ptr, "ns:setCurtain");
	case SOAP_TYPE_cmxDeviceService_ns__getCurtain:
		return soap_out_ns__getCurtain(soap, tag, id, (const struct ns__getCurtain *)ptr, "ns:getCurtain");
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainItem:
		return soap_out_ns__getCurtainItem(soap, tag, id, (const struct ns__getCurtainItem *)ptr, "ns:getCurtainItem");
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainPropertyItem:
		return soap_out_ns__getCurtainPropertyItem(soap, tag, id, (const struct ns__getCurtainPropertyItem *)ptr, "ns:getCurtainPropertyItem");
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainCount:
		return soap_out_ns__getCurtainCount(soap, tag, id, (const struct ns__getCurtainCount *)ptr, "ns:getCurtainCount");
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainCountResponse:
		return soap_out_ns__getCurtainCountResponse(soap, tag, id, (const struct ns__getCurtainCountResponse *)ptr, "ns:getCurtainCountResponse");
	case SOAP_TYPE_cmxDeviceService_xsd_curtainProperty:
		return soap_out_xsd_curtainProperty(soap, tag, id, (const struct xsd_curtainProperty *)ptr, "xsd-curtainProperty");
	case SOAP_TYPE_cmxDeviceService_ns__gasValveEvent:
		return soap_out_ns__gasValveEvent(soap, tag, id, (const struct ns__gasValveEvent *)ptr, "ns:gasValveEvent");
	case SOAP_TYPE_cmxDeviceService_ns__gasValveEventResponse:
		return soap_out_ns__gasValveEventResponse(soap, tag, id, (const struct ns__gasValveEventResponse *)ptr, "ns:gasValveEventResponse");
	case SOAP_TYPE_cmxDeviceService_ns__setGasValve:
		return soap_out_ns__setGasValve(soap, tag, id, (const struct ns__setGasValve *)ptr, "ns:setGasValve");
	case SOAP_TYPE_cmxDeviceService_ns__getGasValve:
		return soap_out_ns__getGasValve(soap, tag, id, (const struct ns__getGasValve *)ptr, "ns:getGasValve");
	case SOAP_TYPE_cmxDeviceService_ns__getGasValveItem:
		return soap_out_ns__getGasValveItem(soap, tag, id, (const struct ns__getGasValveItem *)ptr, "ns:getGasValveItem");
	case SOAP_TYPE_cmxDeviceService_ns__getGasValvePropertyItem:
		return soap_out_ns__getGasValvePropertyItem(soap, tag, id, (const struct ns__getGasValvePropertyItem *)ptr, "ns:getGasValvePropertyItem");
	case SOAP_TYPE_cmxDeviceService_ns__getGasValveCount:
		return soap_out_ns__getGasValveCount(soap, tag, id, (const struct ns__getGasValveCount *)ptr, "ns:getGasValveCount");
	case SOAP_TYPE_cmxDeviceService_ns__getGasValveCountResponse:
		return soap_out_ns__getGasValveCountResponse(soap, tag, id, (const struct ns__getGasValveCountResponse *)ptr, "ns:getGasValveCountResponse");
	case SOAP_TYPE_cmxDeviceService_xsd_gasValveProperty:
		return soap_out_xsd_gasValveProperty(soap, tag, id, (const struct xsd_gasValveProperty *)ptr, "xsd-gasValveProperty");
	case SOAP_TYPE_cmxDeviceService_ns__lightEvent:
		return soap_out_ns__lightEvent(soap, tag, id, (const struct ns__lightEvent *)ptr, "ns:lightEvent");
	case SOAP_TYPE_cmxDeviceService_ns__lightEventResponse:
		return soap_out_ns__lightEventResponse(soap, tag, id, (const struct ns__lightEventResponse *)ptr, "ns:lightEventResponse");
	case SOAP_TYPE_cmxDeviceService_ns__setLight:
		return soap_out_ns__setLight(soap, tag, id, (const struct ns__setLight *)ptr, "ns:setLight");
	case SOAP_TYPE_cmxDeviceService_ns__getLight:
		return soap_out_ns__getLight(soap, tag, id, (const struct ns__getLight *)ptr, "ns:getLight");
	case SOAP_TYPE_cmxDeviceService_ns__getLightItem:
		return soap_out_ns__getLightItem(soap, tag, id, (const struct ns__getLightItem *)ptr, "ns:getLightItem");
	case SOAP_TYPE_cmxDeviceService_ns__getLightPropertyItem:
		return soap_out_ns__getLightPropertyItem(soap, tag, id, (const struct ns__getLightPropertyItem *)ptr, "ns:getLightPropertyItem");
	case SOAP_TYPE_cmxDeviceService_ns__getLightCount:
		return soap_out_ns__getLightCount(soap, tag, id, (const struct ns__getLightCount *)ptr, "ns:getLightCount");
	case SOAP_TYPE_cmxDeviceService_ns__getLightCountResponse:
		return soap_out_ns__getLightCountResponse(soap, tag, id, (const struct ns__getLightCountResponse *)ptr, "ns:getLightCountResponse");
	case SOAP_TYPE_cmxDeviceService_xsd_LightProperty:
		return soap_out_xsd_LightProperty(soap, tag, id, (const struct xsd_LightProperty *)ptr, "xsd-LightProperty");
	case SOAP_TYPE_cmxDeviceService_ns__boilerEvent:
		return soap_out_ns__boilerEvent(soap, tag, id, (const struct ns__boilerEvent *)ptr, "ns:boilerEvent");
	case SOAP_TYPE_cmxDeviceService_ns__boilerEventResponse:
		return soap_out_ns__boilerEventResponse(soap, tag, id, (const struct ns__boilerEventResponse *)ptr, "ns:boilerEventResponse");
	case SOAP_TYPE_cmxDeviceService_ns__setBoiler:
		return soap_out_ns__setBoiler(soap, tag, id, (const struct ns__setBoiler *)ptr, "ns:setBoiler");
	case SOAP_TYPE_cmxDeviceService_ns__getBoiler:
		return soap_out_ns__getBoiler(soap, tag, id, (const struct ns__getBoiler *)ptr, "ns:getBoiler");
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerItem:
		return soap_out_ns__getBoilerItem(soap, tag, id, (const struct ns__getBoilerItem *)ptr, "ns:getBoilerItem");
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerPropertyItem:
		return soap_out_ns__getBoilerPropertyItem(soap, tag, id, (const struct ns__getBoilerPropertyItem *)ptr, "ns:getBoilerPropertyItem");
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerCount:
		return soap_out_ns__getBoilerCount(soap, tag, id, (const struct ns__getBoilerCount *)ptr, "ns:getBoilerCount");
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerCountResponse:
		return soap_out_ns__getBoilerCountResponse(soap, tag, id, (const struct ns__getBoilerCountResponse *)ptr, "ns:getBoilerCountResponse");
	case SOAP_TYPE_cmxDeviceService_xsd_BoilerProperty:
		return soap_out_xsd_BoilerProperty(soap, tag, id, (const struct xsd_BoilerProperty *)ptr, "xsd-BoilerProperty");
	case SOAP_TYPE_cmxDeviceService_ns__deviceCategoryEvent:
		return soap_out_ns__deviceCategoryEvent(soap, tag, id, (const struct ns__deviceCategoryEvent *)ptr, "ns:deviceCategoryEvent");
	case SOAP_TYPE_cmxDeviceService_ns__deviceCategoryEventResponse:
		return soap_out_ns__deviceCategoryEventResponse(soap, tag, id, (const struct ns__deviceCategoryEventResponse *)ptr, "ns:deviceCategoryEventResponse");
	case SOAP_TYPE_cmxDeviceService_ns__setDeviceCategory:
		return soap_out_ns__setDeviceCategory(soap, tag, id, (const struct ns__setDeviceCategory *)ptr, "ns:setDeviceCategory");
	case SOAP_TYPE_cmxDeviceService_ns__getDeviceCategory:
		return soap_out_ns__getDeviceCategory(soap, tag, id, (const struct ns__getDeviceCategory *)ptr, "ns:getDeviceCategory");
	case SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryItem:
		return soap_out_ns__getDeviceCategoryItem(soap, tag, id, (const struct ns__getDeviceCategoryItem *)ptr, "ns:getDeviceCategoryItem");
	case SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryCount:
		return soap_out_ns__getDeviceCategoryCount(soap, tag, id, (const struct ns__getDeviceCategoryCount *)ptr, "ns:getDeviceCategoryCount");
	case SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryCountResponse:
		return soap_out_ns__getDeviceCategoryCountResponse(soap, tag, id, (const struct ns__getDeviceCategoryCountResponse *)ptr, "ns:getDeviceCategoryCountResponse");
	case SOAP_TYPE_cmxDeviceService_xsd_devCategory:
		return soap_out_xsd_devCategory(soap, tag, id, (const struct xsd_devCategory *)ptr, "xsd-devCategory");
	case SOAP_TYPE_cmxDeviceService_xsd__base64Binary:
		return soap_out_xsd__base64Binary(soap, tag, id, (const struct xsd__base64Binary *)ptr, "xsd:base64Binary");
	case SOAP_TYPE_cmxDeviceService_PointerTons__setSensorEmerResponse:
		return soap_out_PointerTons__setSensorEmerResponse(soap, tag, id, (ns__setSensorEmerResponse *const*)ptr, "ns:setSensorEmerResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getSensorEmerResponse:
		return soap_out_PointerTons__getSensorEmerResponse(soap, tag, id, (ns__getSensorEmerResponse *const*)ptr, "ns:getSensorEmerResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getSensorEmerItemResponse:
		return soap_out_PointerTons__getSensorEmerItemResponse(soap, tag, id, (ns__getSensorEmerItemResponse *const*)ptr, "ns:getSensorEmerItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__setFanSystemResponse:
		return soap_out_PointerTons__setFanSystemResponse(soap, tag, id, (ns__setFanSystemResponse *const*)ptr, "ns:setFanSystemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getFanSystemResponse:
		return soap_out_PointerTons__getFanSystemResponse(soap, tag, id, (ns__getFanSystemResponse *const*)ptr, "ns:getFanSystemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getFanSystemItemResponse:
		return soap_out_PointerTons__getFanSystemItemResponse(soap, tag, id, (ns__getFanSystemItemResponse *const*)ptr, "ns:getFanSystemItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getFanSystemPropertyItemResponse:
		return soap_out_PointerTons__getFanSystemPropertyItemResponse(soap, tag, id, (ns__getFanSystemPropertyItemResponse *const*)ptr, "ns:getFanSystemPropertyItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__setSystemAirconResponse:
		return soap_out_PointerTons__setSystemAirconResponse(soap, tag, id, (ns__setSystemAirconResponse *const*)ptr, "ns:setSystemAirconResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getSystemAirconResponse:
		return soap_out_PointerTons__getSystemAirconResponse(soap, tag, id, (ns__getSystemAirconResponse *const*)ptr, "ns:getSystemAirconResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getSystemAirconItemResponse:
		return soap_out_PointerTons__getSystemAirconItemResponse(soap, tag, id, (ns__getSystemAirconItemResponse *const*)ptr, "ns:getSystemAirconItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getSystemAirconPropertyItemResponse:
		return soap_out_PointerTons__getSystemAirconPropertyItemResponse(soap, tag, id, (ns__getSystemAirconPropertyItemResponse *const*)ptr, "ns:getSystemAirconPropertyItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__setBundleLightResponse:
		return soap_out_PointerTons__setBundleLightResponse(soap, tag, id, (ns__setBundleLightResponse *const*)ptr, "ns:setBundleLightResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getBundleLightResponse:
		return soap_out_PointerTons__getBundleLightResponse(soap, tag, id, (ns__getBundleLightResponse *const*)ptr, "ns:getBundleLightResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getBundleLightItemResponse:
		return soap_out_PointerTons__getBundleLightItemResponse(soap, tag, id, (ns__getBundleLightItemResponse *const*)ptr, "ns:getBundleLightItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getBundleLightPropertyItemResponse:
		return soap_out_PointerTons__getBundleLightPropertyItemResponse(soap, tag, id, (ns__getBundleLightPropertyItemResponse *const*)ptr, "ns:getBundleLightPropertyItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__setCurtainResponse:
		return soap_out_PointerTons__setCurtainResponse(soap, tag, id, (ns__setCurtainResponse *const*)ptr, "ns:setCurtainResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getCurtainResponse:
		return soap_out_PointerTons__getCurtainResponse(soap, tag, id, (ns__getCurtainResponse *const*)ptr, "ns:getCurtainResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getCurtainItemResponse:
		return soap_out_PointerTons__getCurtainItemResponse(soap, tag, id, (ns__getCurtainItemResponse *const*)ptr, "ns:getCurtainItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getCurtainPropertyItemResponse:
		return soap_out_PointerTons__getCurtainPropertyItemResponse(soap, tag, id, (ns__getCurtainPropertyItemResponse *const*)ptr, "ns:getCurtainPropertyItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__setGasValveResponse:
		return soap_out_PointerTons__setGasValveResponse(soap, tag, id, (ns__setGasValveResponse *const*)ptr, "ns:setGasValveResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getGasValveResponse:
		return soap_out_PointerTons__getGasValveResponse(soap, tag, id, (ns__getGasValveResponse *const*)ptr, "ns:getGasValveResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getGasValveItemResponse:
		return soap_out_PointerTons__getGasValveItemResponse(soap, tag, id, (ns__getGasValveItemResponse *const*)ptr, "ns:getGasValveItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getGasValvePropertyItemResponse:
		return soap_out_PointerTons__getGasValvePropertyItemResponse(soap, tag, id, (ns__getGasValvePropertyItemResponse *const*)ptr, "ns:getGasValvePropertyItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__setLightResponse:
		return soap_out_PointerTons__setLightResponse(soap, tag, id, (ns__setLightResponse *const*)ptr, "ns:setLightResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getLightResponse:
		return soap_out_PointerTons__getLightResponse(soap, tag, id, (ns__getLightResponse *const*)ptr, "ns:getLightResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getLightItemResponse:
		return soap_out_PointerTons__getLightItemResponse(soap, tag, id, (ns__getLightItemResponse *const*)ptr, "ns:getLightItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getLightPropertyItemResponse:
		return soap_out_PointerTons__getLightPropertyItemResponse(soap, tag, id, (ns__getLightPropertyItemResponse *const*)ptr, "ns:getLightPropertyItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__setBoilerResponse:
		return soap_out_PointerTons__setBoilerResponse(soap, tag, id, (ns__setBoilerResponse *const*)ptr, "ns:setBoilerResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getBoilerResponse:
		return soap_out_PointerTons__getBoilerResponse(soap, tag, id, (ns__getBoilerResponse *const*)ptr, "ns:getBoilerResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getBoilerItemResponse:
		return soap_out_PointerTons__getBoilerItemResponse(soap, tag, id, (ns__getBoilerItemResponse *const*)ptr, "ns:getBoilerItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getBoilerPropertyItemResponse:
		return soap_out_PointerTons__getBoilerPropertyItemResponse(soap, tag, id, (ns__getBoilerPropertyItemResponse *const*)ptr, "ns:getBoilerPropertyItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__setDeviceCategoryResponse:
		return soap_out_PointerTons__setDeviceCategoryResponse(soap, tag, id, (ns__setDeviceCategoryResponse *const*)ptr, "ns:setDeviceCategoryResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getDeviceCategoryResponse:
		return soap_out_PointerTons__getDeviceCategoryResponse(soap, tag, id, (ns__getDeviceCategoryResponse *const*)ptr, "ns:getDeviceCategoryResponse");
	case SOAP_TYPE_cmxDeviceService_PointerTons__getDeviceCategoryItemResponse:
		return soap_out_PointerTons__getDeviceCategoryItemResponse(soap, tag, id, (ns__getDeviceCategoryItemResponse *const*)ptr, "ns:getDeviceCategoryItemResponse");
	case SOAP_TYPE_cmxDeviceService_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_cmxDeviceService_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_cmxDeviceService__QName:
		return soap_out_string(soap, "QName", id, (char**)&ptr, NULL);
	case SOAP_TYPE_cmxDeviceService_string:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_cmxDeviceService_ns__setSensorEmerResponse:
		((ns__setSensorEmerResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getSensorEmerResponse:
		((ns__getSensorEmerResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getSensorEmerItemResponse:
		((ns__getSensorEmerItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__sensorEmer:
		((ns__sensorEmer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setFanSystemResponse:
		((ns__setFanSystemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemResponse:
		((ns__getFanSystemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemItemResponse:
		((ns__getFanSystemItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemPropertyItemResponse:
		((ns__getFanSystemPropertyItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__fanSystem:
		((ns__fanSystem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setSystemAirconResponse:
		((ns__setSystemAirconResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconResponse:
		((ns__getSystemAirconResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconItemResponse:
		((ns__getSystemAirconItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconPropertyItemResponse:
		((ns__getSystemAirconPropertyItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__systemAircon:
		((ns__systemAircon *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setBundleLightResponse:
		((ns__setBundleLightResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightResponse:
		((ns__getBundleLightResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightItemResponse:
		((ns__getBundleLightItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightPropertyItemResponse:
		((ns__getBundleLightPropertyItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__bundleLight:
		((ns__bundleLight *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setCurtainResponse:
		((ns__setCurtainResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainResponse:
		((ns__getCurtainResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainItemResponse:
		((ns__getCurtainItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainPropertyItemResponse:
		((ns__getCurtainPropertyItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__curtain:
		((ns__curtain *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setGasValveResponse:
		((ns__setGasValveResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getGasValveResponse:
		((ns__getGasValveResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getGasValveItemResponse:
		((ns__getGasValveItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getGasValvePropertyItemResponse:
		((ns__getGasValvePropertyItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__gasValve:
		((ns__gasValve *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setLightResponse:
		((ns__setLightResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getLightResponse:
		((ns__getLightResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getLightItemResponse:
		((ns__getLightItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getLightPropertyItemResponse:
		((ns__getLightPropertyItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__light:
		((ns__light *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setBoilerResponse:
		((ns__setBoilerResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerResponse:
		((ns__getBoilerResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerItemResponse:
		((ns__getBoilerItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerPropertyItemResponse:
		((ns__getBoilerPropertyItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__boiler:
		((ns__boiler *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setDeviceCategoryResponse:
		((ns__setDeviceCategoryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryResponse:
		((ns__getDeviceCategoryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryItemResponse:
		((ns__getDeviceCategoryItemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__deviceCategory:
		((ns__deviceCategory *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__rootDevice:
		((ns__rootDevice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__subcribeEvent:
		soap_serialize_ns__subcribeEvent(soap, (const struct ns__subcribeEvent *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__subcribeEventResponse:
		soap_serialize_ns__subcribeEventResponse(soap, (const struct ns__subcribeEventResponse *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__sensorEmerEvent:
		soap_serialize_ns__sensorEmerEvent(soap, (const struct ns__sensorEmerEvent *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__sensorEmerEventResponse:
		soap_serialize_ns__sensorEmerEventResponse(soap, (const struct ns__sensorEmerEventResponse *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setSensorEmer:
		soap_serialize_ns__setSensorEmer(soap, (const struct ns__setSensorEmer *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getSensorEmer:
		soap_serialize_ns__getSensorEmer(soap, (const struct ns__getSensorEmer *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getSensorEmerItem:
		soap_serialize_ns__getSensorEmerItem(soap, (const struct ns__getSensorEmerItem *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getSensorEmerCount:
		soap_serialize_ns__getSensorEmerCount(soap, (const struct ns__getSensorEmerCount *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getSensorEmerCountResponse:
		soap_serialize_ns__getSensorEmerCountResponse(soap, (const struct ns__getSensorEmerCountResponse *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__FanSystemEvent:
		soap_serialize_ns__FanSystemEvent(soap, (const struct ns__FanSystemEvent *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__FanSystemEventResponse:
		soap_serialize_ns__FanSystemEventResponse(soap, (const struct ns__FanSystemEventResponse *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setFanSystem:
		soap_serialize_ns__setFanSystem(soap, (const struct ns__setFanSystem *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystem:
		soap_serialize_ns__getFanSystem(soap, (const struct ns__getFanSystem *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemItem:
		soap_serialize_ns__getFanSystemItem(soap, (const struct ns__getFanSystemItem *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemPropertyItem:
		soap_serialize_ns__getFanSystemPropertyItem(soap, (const struct ns__getFanSystemPropertyItem *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemCount:
		soap_serialize_ns__getFanSystemCount(soap, (const struct ns__getFanSystemCount *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemCountResponse:
		soap_serialize_ns__getFanSystemCountResponse(soap, (const struct ns__getFanSystemCountResponse *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_xsd_fanSystemProperty:
		soap_serialize_xsd_fanSystemProperty(soap, (const struct xsd_fanSystemProperty *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__systemAirconEvent:
		soap_serialize_ns__systemAirconEvent(soap, (const struct ns__systemAirconEvent *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__systemAirconEventResponse:
		soap_serialize_ns__systemAirconEventResponse(soap, (const struct ns__systemAirconEventResponse *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setSystemAircon:
		soap_serialize_ns__setSystemAircon(soap, (const struct ns__setSystemAircon *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAircon:
		soap_serialize_ns__getSystemAircon(soap, (const struct ns__getSystemAircon *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconItem:
		soap_serialize_ns__getSystemAirconItem(soap, (const struct ns__getSystemAirconItem *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconPropertyItem:
		soap_serialize_ns__getSystemAirconPropertyItem(soap, (const struct ns__getSystemAirconPropertyItem *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconCount:
		soap_serialize_ns__getSystemAirconCount(soap, (const struct ns__getSystemAirconCount *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconCountResponse:
		soap_serialize_ns__getSystemAirconCountResponse(soap, (const struct ns__getSystemAirconCountResponse *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_xsd_systemAirconProperty:
		soap_serialize_xsd_systemAirconProperty(soap, (const struct xsd_systemAirconProperty *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__BundleLightEvent:
		soap_serialize_ns__BundleLightEvent(soap, (const struct ns__BundleLightEvent *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__BundleLightEventResponse:
		soap_serialize_ns__BundleLightEventResponse(soap, (const struct ns__BundleLightEventResponse *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setBundleLight:
		soap_serialize_ns__setBundleLight(soap, (const struct ns__setBundleLight *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLight:
		soap_serialize_ns__getBundleLight(soap, (const struct ns__getBundleLight *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightItem:
		soap_serialize_ns__getBundleLightItem(soap, (const struct ns__getBundleLightItem *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightPropertyItem:
		soap_serialize_ns__getBundleLightPropertyItem(soap, (const struct ns__getBundleLightPropertyItem *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightCount:
		soap_serialize_ns__getBundleLightCount(soap, (const struct ns__getBundleLightCount *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightCountResponse:
		soap_serialize_ns__getBundleLightCountResponse(soap, (const struct ns__getBundleLightCountResponse *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_xsd_bundleLightProperty:
		soap_serialize_xsd_bundleLightProperty(soap, (const struct xsd_bundleLightProperty *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__curtainEvent:
		soap_serialize_ns__curtainEvent(soap, (const struct ns__curtainEvent *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__curtainEventResponse:
		soap_serialize_ns__curtainEventResponse(soap, (const struct ns__curtainEventResponse *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setCurtain:
		soap_serialize_ns__setCurtain(soap, (const struct ns__setCurtain *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getCurtain:
		soap_serialize_ns__getCurtain(soap, (const struct ns__getCurtain *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainItem:
		soap_serialize_ns__getCurtainItem(soap, (const struct ns__getCurtainItem *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainPropertyItem:
		soap_serialize_ns__getCurtainPropertyItem(soap, (const struct ns__getCurtainPropertyItem *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainCount:
		soap_serialize_ns__getCurtainCount(soap, (const struct ns__getCurtainCount *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainCountResponse:
		soap_serialize_ns__getCurtainCountResponse(soap, (const struct ns__getCurtainCountResponse *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_xsd_curtainProperty:
		soap_serialize_xsd_curtainProperty(soap, (const struct xsd_curtainProperty *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__gasValveEvent:
		soap_serialize_ns__gasValveEvent(soap, (const struct ns__gasValveEvent *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__gasValveEventResponse:
		soap_serialize_ns__gasValveEventResponse(soap, (const struct ns__gasValveEventResponse *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setGasValve:
		soap_serialize_ns__setGasValve(soap, (const struct ns__setGasValve *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getGasValve:
		soap_serialize_ns__getGasValve(soap, (const struct ns__getGasValve *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getGasValveItem:
		soap_serialize_ns__getGasValveItem(soap, (const struct ns__getGasValveItem *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getGasValvePropertyItem:
		soap_serialize_ns__getGasValvePropertyItem(soap, (const struct ns__getGasValvePropertyItem *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getGasValveCount:
		soap_serialize_ns__getGasValveCount(soap, (const struct ns__getGasValveCount *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getGasValveCountResponse:
		soap_serialize_ns__getGasValveCountResponse(soap, (const struct ns__getGasValveCountResponse *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_xsd_gasValveProperty:
		soap_serialize_xsd_gasValveProperty(soap, (const struct xsd_gasValveProperty *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__lightEvent:
		soap_serialize_ns__lightEvent(soap, (const struct ns__lightEvent *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__lightEventResponse:
		soap_serialize_ns__lightEventResponse(soap, (const struct ns__lightEventResponse *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setLight:
		soap_serialize_ns__setLight(soap, (const struct ns__setLight *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getLight:
		soap_serialize_ns__getLight(soap, (const struct ns__getLight *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getLightItem:
		soap_serialize_ns__getLightItem(soap, (const struct ns__getLightItem *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getLightPropertyItem:
		soap_serialize_ns__getLightPropertyItem(soap, (const struct ns__getLightPropertyItem *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getLightCount:
		soap_serialize_ns__getLightCount(soap, (const struct ns__getLightCount *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getLightCountResponse:
		soap_serialize_ns__getLightCountResponse(soap, (const struct ns__getLightCountResponse *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_xsd_LightProperty:
		soap_serialize_xsd_LightProperty(soap, (const struct xsd_LightProperty *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__boilerEvent:
		soap_serialize_ns__boilerEvent(soap, (const struct ns__boilerEvent *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__boilerEventResponse:
		soap_serialize_ns__boilerEventResponse(soap, (const struct ns__boilerEventResponse *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setBoiler:
		soap_serialize_ns__setBoiler(soap, (const struct ns__setBoiler *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBoiler:
		soap_serialize_ns__getBoiler(soap, (const struct ns__getBoiler *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerItem:
		soap_serialize_ns__getBoilerItem(soap, (const struct ns__getBoilerItem *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerPropertyItem:
		soap_serialize_ns__getBoilerPropertyItem(soap, (const struct ns__getBoilerPropertyItem *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerCount:
		soap_serialize_ns__getBoilerCount(soap, (const struct ns__getBoilerCount *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerCountResponse:
		soap_serialize_ns__getBoilerCountResponse(soap, (const struct ns__getBoilerCountResponse *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_xsd_BoilerProperty:
		soap_serialize_xsd_BoilerProperty(soap, (const struct xsd_BoilerProperty *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__deviceCategoryEvent:
		soap_serialize_ns__deviceCategoryEvent(soap, (const struct ns__deviceCategoryEvent *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__deviceCategoryEventResponse:
		soap_serialize_ns__deviceCategoryEventResponse(soap, (const struct ns__deviceCategoryEventResponse *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setDeviceCategory:
		soap_serialize_ns__setDeviceCategory(soap, (const struct ns__setDeviceCategory *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getDeviceCategory:
		soap_serialize_ns__getDeviceCategory(soap, (const struct ns__getDeviceCategory *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryItem:
		soap_serialize_ns__getDeviceCategoryItem(soap, (const struct ns__getDeviceCategoryItem *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryCount:
		soap_serialize_ns__getDeviceCategoryCount(soap, (const struct ns__getDeviceCategoryCount *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryCountResponse:
		soap_serialize_ns__getDeviceCategoryCountResponse(soap, (const struct ns__getDeviceCategoryCountResponse *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_xsd_devCategory:
		soap_serialize_xsd_devCategory(soap, (const struct xsd_devCategory *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_xsd__base64Binary:
		soap_serialize_xsd__base64Binary(soap, (const struct xsd__base64Binary *)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__setSensorEmerResponse:
		soap_serialize_PointerTons__setSensorEmerResponse(soap, (ns__setSensorEmerResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__getSensorEmerResponse:
		soap_serialize_PointerTons__getSensorEmerResponse(soap, (ns__getSensorEmerResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__getSensorEmerItemResponse:
		soap_serialize_PointerTons__getSensorEmerItemResponse(soap, (ns__getSensorEmerItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__setFanSystemResponse:
		soap_serialize_PointerTons__setFanSystemResponse(soap, (ns__setFanSystemResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__getFanSystemResponse:
		soap_serialize_PointerTons__getFanSystemResponse(soap, (ns__getFanSystemResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__getFanSystemItemResponse:
		soap_serialize_PointerTons__getFanSystemItemResponse(soap, (ns__getFanSystemItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__getFanSystemPropertyItemResponse:
		soap_serialize_PointerTons__getFanSystemPropertyItemResponse(soap, (ns__getFanSystemPropertyItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__setSystemAirconResponse:
		soap_serialize_PointerTons__setSystemAirconResponse(soap, (ns__setSystemAirconResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__getSystemAirconResponse:
		soap_serialize_PointerTons__getSystemAirconResponse(soap, (ns__getSystemAirconResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__getSystemAirconItemResponse:
		soap_serialize_PointerTons__getSystemAirconItemResponse(soap, (ns__getSystemAirconItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__getSystemAirconPropertyItemResponse:
		soap_serialize_PointerTons__getSystemAirconPropertyItemResponse(soap, (ns__getSystemAirconPropertyItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__setBundleLightResponse:
		soap_serialize_PointerTons__setBundleLightResponse(soap, (ns__setBundleLightResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__getBundleLightResponse:
		soap_serialize_PointerTons__getBundleLightResponse(soap, (ns__getBundleLightResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__getBundleLightItemResponse:
		soap_serialize_PointerTons__getBundleLightItemResponse(soap, (ns__getBundleLightItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__getBundleLightPropertyItemResponse:
		soap_serialize_PointerTons__getBundleLightPropertyItemResponse(soap, (ns__getBundleLightPropertyItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__setCurtainResponse:
		soap_serialize_PointerTons__setCurtainResponse(soap, (ns__setCurtainResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__getCurtainResponse:
		soap_serialize_PointerTons__getCurtainResponse(soap, (ns__getCurtainResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__getCurtainItemResponse:
		soap_serialize_PointerTons__getCurtainItemResponse(soap, (ns__getCurtainItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__getCurtainPropertyItemResponse:
		soap_serialize_PointerTons__getCurtainPropertyItemResponse(soap, (ns__getCurtainPropertyItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__setGasValveResponse:
		soap_serialize_PointerTons__setGasValveResponse(soap, (ns__setGasValveResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__getGasValveResponse:
		soap_serialize_PointerTons__getGasValveResponse(soap, (ns__getGasValveResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__getGasValveItemResponse:
		soap_serialize_PointerTons__getGasValveItemResponse(soap, (ns__getGasValveItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__getGasValvePropertyItemResponse:
		soap_serialize_PointerTons__getGasValvePropertyItemResponse(soap, (ns__getGasValvePropertyItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__setLightResponse:
		soap_serialize_PointerTons__setLightResponse(soap, (ns__setLightResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__getLightResponse:
		soap_serialize_PointerTons__getLightResponse(soap, (ns__getLightResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__getLightItemResponse:
		soap_serialize_PointerTons__getLightItemResponse(soap, (ns__getLightItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__getLightPropertyItemResponse:
		soap_serialize_PointerTons__getLightPropertyItemResponse(soap, (ns__getLightPropertyItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__setBoilerResponse:
		soap_serialize_PointerTons__setBoilerResponse(soap, (ns__setBoilerResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__getBoilerResponse:
		soap_serialize_PointerTons__getBoilerResponse(soap, (ns__getBoilerResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__getBoilerItemResponse:
		soap_serialize_PointerTons__getBoilerItemResponse(soap, (ns__getBoilerItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__getBoilerPropertyItemResponse:
		soap_serialize_PointerTons__getBoilerPropertyItemResponse(soap, (ns__getBoilerPropertyItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__setDeviceCategoryResponse:
		soap_serialize_PointerTons__setDeviceCategoryResponse(soap, (ns__setDeviceCategoryResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__getDeviceCategoryResponse:
		soap_serialize_PointerTons__getDeviceCategoryResponse(soap, (ns__getDeviceCategoryResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTons__getDeviceCategoryItemResponse:
		soap_serialize_PointerTons__getDeviceCategoryItemResponse(soap, (ns__getDeviceCategoryItemResponse *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE_cmxDeviceService__QName:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_cmxDeviceService_string:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_cmxDeviceService_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__rootDevice:
		return (void*)soap_instantiate_ns__rootDevice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_xsd_devCategory:
		return (void*)soap_instantiate_xsd_devCategory(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__deviceCategory:
		return (void*)soap_instantiate_ns__deviceCategory(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryItemResponse:
		return (void*)soap_instantiate_ns__getDeviceCategoryItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryResponse:
		return (void*)soap_instantiate_ns__getDeviceCategoryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryCountResponse:
		return (void*)soap_instantiate_ns__getDeviceCategoryCountResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryCount:
		return (void*)soap_instantiate_ns__getDeviceCategoryCount(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryItem:
		return (void*)soap_instantiate_ns__getDeviceCategoryItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getDeviceCategory:
		return (void*)soap_instantiate_ns__getDeviceCategory(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__setDeviceCategoryResponse:
		return (void*)soap_instantiate_ns__setDeviceCategoryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__setDeviceCategory:
		return (void*)soap_instantiate_ns__setDeviceCategory(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__deviceCategoryEventResponse:
		return (void*)soap_instantiate_ns__deviceCategoryEventResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__deviceCategoryEvent:
		return (void*)soap_instantiate_ns__deviceCategoryEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_xsd_BoilerProperty:
		return (void*)soap_instantiate_xsd_BoilerProperty(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__boiler:
		return (void*)soap_instantiate_ns__boiler(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerPropertyItemResponse:
		return (void*)soap_instantiate_ns__getBoilerPropertyItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerItemResponse:
		return (void*)soap_instantiate_ns__getBoilerItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerResponse:
		return (void*)soap_instantiate_ns__getBoilerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerCountResponse:
		return (void*)soap_instantiate_ns__getBoilerCountResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerCount:
		return (void*)soap_instantiate_ns__getBoilerCount(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerPropertyItem:
		return (void*)soap_instantiate_ns__getBoilerPropertyItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerItem:
		return (void*)soap_instantiate_ns__getBoilerItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getBoiler:
		return (void*)soap_instantiate_ns__getBoiler(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__setBoilerResponse:
		return (void*)soap_instantiate_ns__setBoilerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__setBoiler:
		return (void*)soap_instantiate_ns__setBoiler(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__boilerEventResponse:
		return (void*)soap_instantiate_ns__boilerEventResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__boilerEvent:
		return (void*)soap_instantiate_ns__boilerEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_xsd_LightProperty:
		return (void*)soap_instantiate_xsd_LightProperty(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__light:
		return (void*)soap_instantiate_ns__light(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getLightPropertyItemResponse:
		return (void*)soap_instantiate_ns__getLightPropertyItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getLightItemResponse:
		return (void*)soap_instantiate_ns__getLightItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getLightResponse:
		return (void*)soap_instantiate_ns__getLightResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getLightCountResponse:
		return (void*)soap_instantiate_ns__getLightCountResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getLightCount:
		return (void*)soap_instantiate_ns__getLightCount(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getLightPropertyItem:
		return (void*)soap_instantiate_ns__getLightPropertyItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getLightItem:
		return (void*)soap_instantiate_ns__getLightItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getLight:
		return (void*)soap_instantiate_ns__getLight(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__setLightResponse:
		return (void*)soap_instantiate_ns__setLightResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__setLight:
		return (void*)soap_instantiate_ns__setLight(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__lightEventResponse:
		return (void*)soap_instantiate_ns__lightEventResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__lightEvent:
		return (void*)soap_instantiate_ns__lightEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_xsd_gasValveProperty:
		return (void*)soap_instantiate_xsd_gasValveProperty(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__gasValve:
		return (void*)soap_instantiate_ns__gasValve(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getGasValvePropertyItemResponse:
		return (void*)soap_instantiate_ns__getGasValvePropertyItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getGasValveItemResponse:
		return (void*)soap_instantiate_ns__getGasValveItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getGasValveResponse:
		return (void*)soap_instantiate_ns__getGasValveResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getGasValveCountResponse:
		return (void*)soap_instantiate_ns__getGasValveCountResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getGasValveCount:
		return (void*)soap_instantiate_ns__getGasValveCount(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getGasValvePropertyItem:
		return (void*)soap_instantiate_ns__getGasValvePropertyItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getGasValveItem:
		return (void*)soap_instantiate_ns__getGasValveItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getGasValve:
		return (void*)soap_instantiate_ns__getGasValve(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__setGasValveResponse:
		return (void*)soap_instantiate_ns__setGasValveResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__setGasValve:
		return (void*)soap_instantiate_ns__setGasValve(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__gasValveEventResponse:
		return (void*)soap_instantiate_ns__gasValveEventResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__gasValveEvent:
		return (void*)soap_instantiate_ns__gasValveEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_xsd_curtainProperty:
		return (void*)soap_instantiate_xsd_curtainProperty(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__curtain:
		return (void*)soap_instantiate_ns__curtain(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainPropertyItemResponse:
		return (void*)soap_instantiate_ns__getCurtainPropertyItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainItemResponse:
		return (void*)soap_instantiate_ns__getCurtainItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainResponse:
		return (void*)soap_instantiate_ns__getCurtainResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainCountResponse:
		return (void*)soap_instantiate_ns__getCurtainCountResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainCount:
		return (void*)soap_instantiate_ns__getCurtainCount(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainPropertyItem:
		return (void*)soap_instantiate_ns__getCurtainPropertyItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainItem:
		return (void*)soap_instantiate_ns__getCurtainItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getCurtain:
		return (void*)soap_instantiate_ns__getCurtain(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__setCurtainResponse:
		return (void*)soap_instantiate_ns__setCurtainResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__setCurtain:
		return (void*)soap_instantiate_ns__setCurtain(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__curtainEventResponse:
		return (void*)soap_instantiate_ns__curtainEventResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__curtainEvent:
		return (void*)soap_instantiate_ns__curtainEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_xsd_bundleLightProperty:
		return (void*)soap_instantiate_xsd_bundleLightProperty(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__bundleLight:
		return (void*)soap_instantiate_ns__bundleLight(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightPropertyItemResponse:
		return (void*)soap_instantiate_ns__getBundleLightPropertyItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightItemResponse:
		return (void*)soap_instantiate_ns__getBundleLightItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightResponse:
		return (void*)soap_instantiate_ns__getBundleLightResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightCountResponse:
		return (void*)soap_instantiate_ns__getBundleLightCountResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightCount:
		return (void*)soap_instantiate_ns__getBundleLightCount(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightPropertyItem:
		return (void*)soap_instantiate_ns__getBundleLightPropertyItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightItem:
		return (void*)soap_instantiate_ns__getBundleLightItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLight:
		return (void*)soap_instantiate_ns__getBundleLight(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__setBundleLightResponse:
		return (void*)soap_instantiate_ns__setBundleLightResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__setBundleLight:
		return (void*)soap_instantiate_ns__setBundleLight(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__BundleLightEventResponse:
		return (void*)soap_instantiate_ns__BundleLightEventResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__BundleLightEvent:
		return (void*)soap_instantiate_ns__BundleLightEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_xsd_systemAirconProperty:
		return (void*)soap_instantiate_xsd_systemAirconProperty(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__systemAircon:
		return (void*)soap_instantiate_ns__systemAircon(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconPropertyItemResponse:
		return (void*)soap_instantiate_ns__getSystemAirconPropertyItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconItemResponse:
		return (void*)soap_instantiate_ns__getSystemAirconItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconResponse:
		return (void*)soap_instantiate_ns__getSystemAirconResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconCountResponse:
		return (void*)soap_instantiate_ns__getSystemAirconCountResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconCount:
		return (void*)soap_instantiate_ns__getSystemAirconCount(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconPropertyItem:
		return (void*)soap_instantiate_ns__getSystemAirconPropertyItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconItem:
		return (void*)soap_instantiate_ns__getSystemAirconItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAircon:
		return (void*)soap_instantiate_ns__getSystemAircon(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__setSystemAirconResponse:
		return (void*)soap_instantiate_ns__setSystemAirconResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__setSystemAircon:
		return (void*)soap_instantiate_ns__setSystemAircon(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__systemAirconEventResponse:
		return (void*)soap_instantiate_ns__systemAirconEventResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__systemAirconEvent:
		return (void*)soap_instantiate_ns__systemAirconEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_xsd_fanSystemProperty:
		return (void*)soap_instantiate_xsd_fanSystemProperty(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__fanSystem:
		return (void*)soap_instantiate_ns__fanSystem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemPropertyItemResponse:
		return (void*)soap_instantiate_ns__getFanSystemPropertyItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemItemResponse:
		return (void*)soap_instantiate_ns__getFanSystemItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemResponse:
		return (void*)soap_instantiate_ns__getFanSystemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemCountResponse:
		return (void*)soap_instantiate_ns__getFanSystemCountResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemCount:
		return (void*)soap_instantiate_ns__getFanSystemCount(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemPropertyItem:
		return (void*)soap_instantiate_ns__getFanSystemPropertyItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemItem:
		return (void*)soap_instantiate_ns__getFanSystemItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystem:
		return (void*)soap_instantiate_ns__getFanSystem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__setFanSystemResponse:
		return (void*)soap_instantiate_ns__setFanSystemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__setFanSystem:
		return (void*)soap_instantiate_ns__setFanSystem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__FanSystemEventResponse:
		return (void*)soap_instantiate_ns__FanSystemEventResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__FanSystemEvent:
		return (void*)soap_instantiate_ns__FanSystemEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__sensorEmer:
		return (void*)soap_instantiate_ns__sensorEmer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getSensorEmerItemResponse:
		return (void*)soap_instantiate_ns__getSensorEmerItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getSensorEmerResponse:
		return (void*)soap_instantiate_ns__getSensorEmerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getSensorEmerCountResponse:
		return (void*)soap_instantiate_ns__getSensorEmerCountResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getSensorEmerCount:
		return (void*)soap_instantiate_ns__getSensorEmerCount(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getSensorEmerItem:
		return (void*)soap_instantiate_ns__getSensorEmerItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__getSensorEmer:
		return (void*)soap_instantiate_ns__getSensorEmer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__setSensorEmerResponse:
		return (void*)soap_instantiate_ns__setSensorEmerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__setSensorEmer:
		return (void*)soap_instantiate_ns__setSensorEmer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__sensorEmerEventResponse:
		return (void*)soap_instantiate_ns__sensorEmerEventResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__sensorEmerEvent:
		return (void*)soap_instantiate_ns__sensorEmerEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__subcribeEventResponse:
		return (void*)soap_instantiate_ns__subcribeEventResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cmxDeviceService_ns__subcribeEvent:
		return (void*)soap_instantiate_ns__subcribeEvent(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_cmxDeviceService_xsd__base64Binary:
		if (p->size < 0)
			delete (struct xsd__base64Binary*)p->ptr;
		else
			delete[] (struct xsd__base64Binary*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__rootDevice:
		if (p->size < 0)
			delete (ns__rootDevice*)p->ptr;
		else
			delete[] (ns__rootDevice*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_xsd_devCategory:
		if (p->size < 0)
			delete (struct xsd_devCategory*)p->ptr;
		else
			delete[] (struct xsd_devCategory*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__deviceCategory:
		if (p->size < 0)
			delete (ns__deviceCategory*)p->ptr;
		else
			delete[] (ns__deviceCategory*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryItemResponse:
		if (p->size < 0)
			delete (ns__getDeviceCategoryItemResponse*)p->ptr;
		else
			delete[] (ns__getDeviceCategoryItemResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryResponse:
		if (p->size < 0)
			delete (ns__getDeviceCategoryResponse*)p->ptr;
		else
			delete[] (ns__getDeviceCategoryResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryCountResponse:
		if (p->size < 0)
			delete (struct ns__getDeviceCategoryCountResponse*)p->ptr;
		else
			delete[] (struct ns__getDeviceCategoryCountResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryCount:
		if (p->size < 0)
			delete (struct ns__getDeviceCategoryCount*)p->ptr;
		else
			delete[] (struct ns__getDeviceCategoryCount*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryItem:
		if (p->size < 0)
			delete (struct ns__getDeviceCategoryItem*)p->ptr;
		else
			delete[] (struct ns__getDeviceCategoryItem*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getDeviceCategory:
		if (p->size < 0)
			delete (struct ns__getDeviceCategory*)p->ptr;
		else
			delete[] (struct ns__getDeviceCategory*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setDeviceCategoryResponse:
		if (p->size < 0)
			delete (ns__setDeviceCategoryResponse*)p->ptr;
		else
			delete[] (ns__setDeviceCategoryResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setDeviceCategory:
		if (p->size < 0)
			delete (struct ns__setDeviceCategory*)p->ptr;
		else
			delete[] (struct ns__setDeviceCategory*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__deviceCategoryEventResponse:
		if (p->size < 0)
			delete (struct ns__deviceCategoryEventResponse*)p->ptr;
		else
			delete[] (struct ns__deviceCategoryEventResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__deviceCategoryEvent:
		if (p->size < 0)
			delete (struct ns__deviceCategoryEvent*)p->ptr;
		else
			delete[] (struct ns__deviceCategoryEvent*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_xsd_BoilerProperty:
		if (p->size < 0)
			delete (struct xsd_BoilerProperty*)p->ptr;
		else
			delete[] (struct xsd_BoilerProperty*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__boiler:
		if (p->size < 0)
			delete (ns__boiler*)p->ptr;
		else
			delete[] (ns__boiler*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerPropertyItemResponse:
		if (p->size < 0)
			delete (ns__getBoilerPropertyItemResponse*)p->ptr;
		else
			delete[] (ns__getBoilerPropertyItemResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerItemResponse:
		if (p->size < 0)
			delete (ns__getBoilerItemResponse*)p->ptr;
		else
			delete[] (ns__getBoilerItemResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerResponse:
		if (p->size < 0)
			delete (ns__getBoilerResponse*)p->ptr;
		else
			delete[] (ns__getBoilerResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerCountResponse:
		if (p->size < 0)
			delete (struct ns__getBoilerCountResponse*)p->ptr;
		else
			delete[] (struct ns__getBoilerCountResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerCount:
		if (p->size < 0)
			delete (struct ns__getBoilerCount*)p->ptr;
		else
			delete[] (struct ns__getBoilerCount*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerPropertyItem:
		if (p->size < 0)
			delete (struct ns__getBoilerPropertyItem*)p->ptr;
		else
			delete[] (struct ns__getBoilerPropertyItem*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBoilerItem:
		if (p->size < 0)
			delete (struct ns__getBoilerItem*)p->ptr;
		else
			delete[] (struct ns__getBoilerItem*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBoiler:
		if (p->size < 0)
			delete (struct ns__getBoiler*)p->ptr;
		else
			delete[] (struct ns__getBoiler*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setBoilerResponse:
		if (p->size < 0)
			delete (ns__setBoilerResponse*)p->ptr;
		else
			delete[] (ns__setBoilerResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setBoiler:
		if (p->size < 0)
			delete (struct ns__setBoiler*)p->ptr;
		else
			delete[] (struct ns__setBoiler*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__boilerEventResponse:
		if (p->size < 0)
			delete (struct ns__boilerEventResponse*)p->ptr;
		else
			delete[] (struct ns__boilerEventResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__boilerEvent:
		if (p->size < 0)
			delete (struct ns__boilerEvent*)p->ptr;
		else
			delete[] (struct ns__boilerEvent*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_xsd_LightProperty:
		if (p->size < 0)
			delete (struct xsd_LightProperty*)p->ptr;
		else
			delete[] (struct xsd_LightProperty*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__light:
		if (p->size < 0)
			delete (ns__light*)p->ptr;
		else
			delete[] (ns__light*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getLightPropertyItemResponse:
		if (p->size < 0)
			delete (ns__getLightPropertyItemResponse*)p->ptr;
		else
			delete[] (ns__getLightPropertyItemResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getLightItemResponse:
		if (p->size < 0)
			delete (ns__getLightItemResponse*)p->ptr;
		else
			delete[] (ns__getLightItemResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getLightResponse:
		if (p->size < 0)
			delete (ns__getLightResponse*)p->ptr;
		else
			delete[] (ns__getLightResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getLightCountResponse:
		if (p->size < 0)
			delete (struct ns__getLightCountResponse*)p->ptr;
		else
			delete[] (struct ns__getLightCountResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getLightCount:
		if (p->size < 0)
			delete (struct ns__getLightCount*)p->ptr;
		else
			delete[] (struct ns__getLightCount*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getLightPropertyItem:
		if (p->size < 0)
			delete (struct ns__getLightPropertyItem*)p->ptr;
		else
			delete[] (struct ns__getLightPropertyItem*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getLightItem:
		if (p->size < 0)
			delete (struct ns__getLightItem*)p->ptr;
		else
			delete[] (struct ns__getLightItem*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getLight:
		if (p->size < 0)
			delete (struct ns__getLight*)p->ptr;
		else
			delete[] (struct ns__getLight*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setLightResponse:
		if (p->size < 0)
			delete (ns__setLightResponse*)p->ptr;
		else
			delete[] (ns__setLightResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setLight:
		if (p->size < 0)
			delete (struct ns__setLight*)p->ptr;
		else
			delete[] (struct ns__setLight*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__lightEventResponse:
		if (p->size < 0)
			delete (struct ns__lightEventResponse*)p->ptr;
		else
			delete[] (struct ns__lightEventResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__lightEvent:
		if (p->size < 0)
			delete (struct ns__lightEvent*)p->ptr;
		else
			delete[] (struct ns__lightEvent*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_xsd_gasValveProperty:
		if (p->size < 0)
			delete (struct xsd_gasValveProperty*)p->ptr;
		else
			delete[] (struct xsd_gasValveProperty*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__gasValve:
		if (p->size < 0)
			delete (ns__gasValve*)p->ptr;
		else
			delete[] (ns__gasValve*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getGasValvePropertyItemResponse:
		if (p->size < 0)
			delete (ns__getGasValvePropertyItemResponse*)p->ptr;
		else
			delete[] (ns__getGasValvePropertyItemResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getGasValveItemResponse:
		if (p->size < 0)
			delete (ns__getGasValveItemResponse*)p->ptr;
		else
			delete[] (ns__getGasValveItemResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getGasValveResponse:
		if (p->size < 0)
			delete (ns__getGasValveResponse*)p->ptr;
		else
			delete[] (ns__getGasValveResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getGasValveCountResponse:
		if (p->size < 0)
			delete (struct ns__getGasValveCountResponse*)p->ptr;
		else
			delete[] (struct ns__getGasValveCountResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getGasValveCount:
		if (p->size < 0)
			delete (struct ns__getGasValveCount*)p->ptr;
		else
			delete[] (struct ns__getGasValveCount*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getGasValvePropertyItem:
		if (p->size < 0)
			delete (struct ns__getGasValvePropertyItem*)p->ptr;
		else
			delete[] (struct ns__getGasValvePropertyItem*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getGasValveItem:
		if (p->size < 0)
			delete (struct ns__getGasValveItem*)p->ptr;
		else
			delete[] (struct ns__getGasValveItem*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getGasValve:
		if (p->size < 0)
			delete (struct ns__getGasValve*)p->ptr;
		else
			delete[] (struct ns__getGasValve*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setGasValveResponse:
		if (p->size < 0)
			delete (ns__setGasValveResponse*)p->ptr;
		else
			delete[] (ns__setGasValveResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setGasValve:
		if (p->size < 0)
			delete (struct ns__setGasValve*)p->ptr;
		else
			delete[] (struct ns__setGasValve*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__gasValveEventResponse:
		if (p->size < 0)
			delete (struct ns__gasValveEventResponse*)p->ptr;
		else
			delete[] (struct ns__gasValveEventResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__gasValveEvent:
		if (p->size < 0)
			delete (struct ns__gasValveEvent*)p->ptr;
		else
			delete[] (struct ns__gasValveEvent*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_xsd_curtainProperty:
		if (p->size < 0)
			delete (struct xsd_curtainProperty*)p->ptr;
		else
			delete[] (struct xsd_curtainProperty*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__curtain:
		if (p->size < 0)
			delete (ns__curtain*)p->ptr;
		else
			delete[] (ns__curtain*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainPropertyItemResponse:
		if (p->size < 0)
			delete (ns__getCurtainPropertyItemResponse*)p->ptr;
		else
			delete[] (ns__getCurtainPropertyItemResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainItemResponse:
		if (p->size < 0)
			delete (ns__getCurtainItemResponse*)p->ptr;
		else
			delete[] (ns__getCurtainItemResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainResponse:
		if (p->size < 0)
			delete (ns__getCurtainResponse*)p->ptr;
		else
			delete[] (ns__getCurtainResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainCountResponse:
		if (p->size < 0)
			delete (struct ns__getCurtainCountResponse*)p->ptr;
		else
			delete[] (struct ns__getCurtainCountResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainCount:
		if (p->size < 0)
			delete (struct ns__getCurtainCount*)p->ptr;
		else
			delete[] (struct ns__getCurtainCount*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainPropertyItem:
		if (p->size < 0)
			delete (struct ns__getCurtainPropertyItem*)p->ptr;
		else
			delete[] (struct ns__getCurtainPropertyItem*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getCurtainItem:
		if (p->size < 0)
			delete (struct ns__getCurtainItem*)p->ptr;
		else
			delete[] (struct ns__getCurtainItem*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getCurtain:
		if (p->size < 0)
			delete (struct ns__getCurtain*)p->ptr;
		else
			delete[] (struct ns__getCurtain*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setCurtainResponse:
		if (p->size < 0)
			delete (ns__setCurtainResponse*)p->ptr;
		else
			delete[] (ns__setCurtainResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setCurtain:
		if (p->size < 0)
			delete (struct ns__setCurtain*)p->ptr;
		else
			delete[] (struct ns__setCurtain*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__curtainEventResponse:
		if (p->size < 0)
			delete (struct ns__curtainEventResponse*)p->ptr;
		else
			delete[] (struct ns__curtainEventResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__curtainEvent:
		if (p->size < 0)
			delete (struct ns__curtainEvent*)p->ptr;
		else
			delete[] (struct ns__curtainEvent*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_xsd_bundleLightProperty:
		if (p->size < 0)
			delete (struct xsd_bundleLightProperty*)p->ptr;
		else
			delete[] (struct xsd_bundleLightProperty*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__bundleLight:
		if (p->size < 0)
			delete (ns__bundleLight*)p->ptr;
		else
			delete[] (ns__bundleLight*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightPropertyItemResponse:
		if (p->size < 0)
			delete (ns__getBundleLightPropertyItemResponse*)p->ptr;
		else
			delete[] (ns__getBundleLightPropertyItemResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightItemResponse:
		if (p->size < 0)
			delete (ns__getBundleLightItemResponse*)p->ptr;
		else
			delete[] (ns__getBundleLightItemResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightResponse:
		if (p->size < 0)
			delete (ns__getBundleLightResponse*)p->ptr;
		else
			delete[] (ns__getBundleLightResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightCountResponse:
		if (p->size < 0)
			delete (struct ns__getBundleLightCountResponse*)p->ptr;
		else
			delete[] (struct ns__getBundleLightCountResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightCount:
		if (p->size < 0)
			delete (struct ns__getBundleLightCount*)p->ptr;
		else
			delete[] (struct ns__getBundleLightCount*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightPropertyItem:
		if (p->size < 0)
			delete (struct ns__getBundleLightPropertyItem*)p->ptr;
		else
			delete[] (struct ns__getBundleLightPropertyItem*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLightItem:
		if (p->size < 0)
			delete (struct ns__getBundleLightItem*)p->ptr;
		else
			delete[] (struct ns__getBundleLightItem*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getBundleLight:
		if (p->size < 0)
			delete (struct ns__getBundleLight*)p->ptr;
		else
			delete[] (struct ns__getBundleLight*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setBundleLightResponse:
		if (p->size < 0)
			delete (ns__setBundleLightResponse*)p->ptr;
		else
			delete[] (ns__setBundleLightResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setBundleLight:
		if (p->size < 0)
			delete (struct ns__setBundleLight*)p->ptr;
		else
			delete[] (struct ns__setBundleLight*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__BundleLightEventResponse:
		if (p->size < 0)
			delete (struct ns__BundleLightEventResponse*)p->ptr;
		else
			delete[] (struct ns__BundleLightEventResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__BundleLightEvent:
		if (p->size < 0)
			delete (struct ns__BundleLightEvent*)p->ptr;
		else
			delete[] (struct ns__BundleLightEvent*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_xsd_systemAirconProperty:
		if (p->size < 0)
			delete (struct xsd_systemAirconProperty*)p->ptr;
		else
			delete[] (struct xsd_systemAirconProperty*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__systemAircon:
		if (p->size < 0)
			delete (ns__systemAircon*)p->ptr;
		else
			delete[] (ns__systemAircon*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconPropertyItemResponse:
		if (p->size < 0)
			delete (ns__getSystemAirconPropertyItemResponse*)p->ptr;
		else
			delete[] (ns__getSystemAirconPropertyItemResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconItemResponse:
		if (p->size < 0)
			delete (ns__getSystemAirconItemResponse*)p->ptr;
		else
			delete[] (ns__getSystemAirconItemResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconResponse:
		if (p->size < 0)
			delete (ns__getSystemAirconResponse*)p->ptr;
		else
			delete[] (ns__getSystemAirconResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconCountResponse:
		if (p->size < 0)
			delete (struct ns__getSystemAirconCountResponse*)p->ptr;
		else
			delete[] (struct ns__getSystemAirconCountResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconCount:
		if (p->size < 0)
			delete (struct ns__getSystemAirconCount*)p->ptr;
		else
			delete[] (struct ns__getSystemAirconCount*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconPropertyItem:
		if (p->size < 0)
			delete (struct ns__getSystemAirconPropertyItem*)p->ptr;
		else
			delete[] (struct ns__getSystemAirconPropertyItem*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAirconItem:
		if (p->size < 0)
			delete (struct ns__getSystemAirconItem*)p->ptr;
		else
			delete[] (struct ns__getSystemAirconItem*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getSystemAircon:
		if (p->size < 0)
			delete (struct ns__getSystemAircon*)p->ptr;
		else
			delete[] (struct ns__getSystemAircon*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setSystemAirconResponse:
		if (p->size < 0)
			delete (ns__setSystemAirconResponse*)p->ptr;
		else
			delete[] (ns__setSystemAirconResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setSystemAircon:
		if (p->size < 0)
			delete (struct ns__setSystemAircon*)p->ptr;
		else
			delete[] (struct ns__setSystemAircon*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__systemAirconEventResponse:
		if (p->size < 0)
			delete (struct ns__systemAirconEventResponse*)p->ptr;
		else
			delete[] (struct ns__systemAirconEventResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__systemAirconEvent:
		if (p->size < 0)
			delete (struct ns__systemAirconEvent*)p->ptr;
		else
			delete[] (struct ns__systemAirconEvent*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_xsd_fanSystemProperty:
		if (p->size < 0)
			delete (struct xsd_fanSystemProperty*)p->ptr;
		else
			delete[] (struct xsd_fanSystemProperty*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__fanSystem:
		if (p->size < 0)
			delete (ns__fanSystem*)p->ptr;
		else
			delete[] (ns__fanSystem*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemPropertyItemResponse:
		if (p->size < 0)
			delete (ns__getFanSystemPropertyItemResponse*)p->ptr;
		else
			delete[] (ns__getFanSystemPropertyItemResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemItemResponse:
		if (p->size < 0)
			delete (ns__getFanSystemItemResponse*)p->ptr;
		else
			delete[] (ns__getFanSystemItemResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemResponse:
		if (p->size < 0)
			delete (ns__getFanSystemResponse*)p->ptr;
		else
			delete[] (ns__getFanSystemResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemCountResponse:
		if (p->size < 0)
			delete (struct ns__getFanSystemCountResponse*)p->ptr;
		else
			delete[] (struct ns__getFanSystemCountResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemCount:
		if (p->size < 0)
			delete (struct ns__getFanSystemCount*)p->ptr;
		else
			delete[] (struct ns__getFanSystemCount*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemPropertyItem:
		if (p->size < 0)
			delete (struct ns__getFanSystemPropertyItem*)p->ptr;
		else
			delete[] (struct ns__getFanSystemPropertyItem*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystemItem:
		if (p->size < 0)
			delete (struct ns__getFanSystemItem*)p->ptr;
		else
			delete[] (struct ns__getFanSystemItem*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getFanSystem:
		if (p->size < 0)
			delete (struct ns__getFanSystem*)p->ptr;
		else
			delete[] (struct ns__getFanSystem*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setFanSystemResponse:
		if (p->size < 0)
			delete (ns__setFanSystemResponse*)p->ptr;
		else
			delete[] (ns__setFanSystemResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setFanSystem:
		if (p->size < 0)
			delete (struct ns__setFanSystem*)p->ptr;
		else
			delete[] (struct ns__setFanSystem*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__FanSystemEventResponse:
		if (p->size < 0)
			delete (struct ns__FanSystemEventResponse*)p->ptr;
		else
			delete[] (struct ns__FanSystemEventResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__FanSystemEvent:
		if (p->size < 0)
			delete (struct ns__FanSystemEvent*)p->ptr;
		else
			delete[] (struct ns__FanSystemEvent*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__sensorEmer:
		if (p->size < 0)
			delete (ns__sensorEmer*)p->ptr;
		else
			delete[] (ns__sensorEmer*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getSensorEmerItemResponse:
		if (p->size < 0)
			delete (ns__getSensorEmerItemResponse*)p->ptr;
		else
			delete[] (ns__getSensorEmerItemResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getSensorEmerResponse:
		if (p->size < 0)
			delete (ns__getSensorEmerResponse*)p->ptr;
		else
			delete[] (ns__getSensorEmerResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getSensorEmerCountResponse:
		if (p->size < 0)
			delete (struct ns__getSensorEmerCountResponse*)p->ptr;
		else
			delete[] (struct ns__getSensorEmerCountResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getSensorEmerCount:
		if (p->size < 0)
			delete (struct ns__getSensorEmerCount*)p->ptr;
		else
			delete[] (struct ns__getSensorEmerCount*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getSensorEmerItem:
		if (p->size < 0)
			delete (struct ns__getSensorEmerItem*)p->ptr;
		else
			delete[] (struct ns__getSensorEmerItem*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__getSensorEmer:
		if (p->size < 0)
			delete (struct ns__getSensorEmer*)p->ptr;
		else
			delete[] (struct ns__getSensorEmer*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setSensorEmerResponse:
		if (p->size < 0)
			delete (ns__setSensorEmerResponse*)p->ptr;
		else
			delete[] (ns__setSensorEmerResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__setSensorEmer:
		if (p->size < 0)
			delete (struct ns__setSensorEmer*)p->ptr;
		else
			delete[] (struct ns__setSensorEmer*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__sensorEmerEventResponse:
		if (p->size < 0)
			delete (struct ns__sensorEmerEventResponse*)p->ptr;
		else
			delete[] (struct ns__sensorEmerEventResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__sensorEmerEvent:
		if (p->size < 0)
			delete (struct ns__sensorEmerEvent*)p->ptr;
		else
			delete[] (struct ns__sensorEmerEvent*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__subcribeEventResponse:
		if (p->size < 0)
			delete (struct ns__subcribeEventResponse*)p->ptr;
		else
			delete[] (struct ns__subcribeEventResponse*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_ns__subcribeEvent:
		if (p->size < 0)
			delete (struct ns__subcribeEvent*)p->ptr;
		else
			delete[] (struct ns__subcribeEvent*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_cmxDeviceService_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	}
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_cmxDeviceService_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_cmxDeviceService_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_cmxDeviceService_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_cmxDeviceService_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_unsignedByte);
	if (soap_out_unsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_cmxDeviceService_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	return soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_cmxDeviceService_unsignedByte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_unsignedInt);
	if (soap_out_unsignedInt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_cmxDeviceService_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	return soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_cmxDeviceService_unsignedInt);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__sensorEmerFunc(struct soap *soap, enum ns__sensorEmerFunc *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__sensorEmerFunc
	*a = SOAP_DEFAULT_ns__sensorEmerFunc;
#else
	*a = (enum ns__sensorEmerFunc)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__sensorEmerFunc(struct soap *soap, const enum ns__sensorEmerFunc *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__sensorEmerFunc);
	if (soap_out_ns__sensorEmerFunc(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns__sensorEmerFunc[] =
{	{ (long)f_seMode, "f-seMode" },
	{ (long)f_seDevError, "f-seDevError" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__sensorEmerFunc2s(struct soap *soap, enum ns__sensorEmerFunc n)
{	const char *s = soap_str_code(soap_codes_ns__sensorEmerFunc, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__sensorEmerFunc(struct soap *soap, const char *tag, int id, const enum ns__sensorEmerFunc *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__sensorEmerFunc), type);
	soap_send(soap, soap_ns__sensorEmerFunc2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns__sensorEmerFunc * SOAP_FMAC4 soap_get_ns__sensorEmerFunc(struct soap *soap, enum ns__sensorEmerFunc *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__sensorEmerFunc(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__sensorEmerFunc(struct soap *soap, const char *s, enum ns__sensorEmerFunc *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns__sensorEmerFunc, s);
	if (map)
		*a = (enum ns__sensorEmerFunc)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__sensorEmerFunc)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__sensorEmerFunc * SOAP_FMAC4 soap_in_ns__sensorEmerFunc(struct soap *soap, const char *tag, enum ns__sensorEmerFunc *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ns__sensorEmerFunc *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__sensorEmerFunc, sizeof(enum ns__sensorEmerFunc), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__sensorEmerFunc(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__sensorEmerFunc *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__sensorEmerFunc, 0, sizeof(enum ns__sensorEmerFunc), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__enum_sensorEmer(struct soap *soap, enum ns__enum_sensorEmer *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__enum_sensorEmer
	*a = SOAP_DEFAULT_ns__enum_sensorEmer;
#else
	*a = (enum ns__enum_sensorEmer)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__enum_sensorEmer(struct soap *soap, const enum ns__enum_sensorEmer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__enum_sensorEmer);
	if (soap_out_ns__enum_sensorEmer(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns__enum_sensorEmer[] =
{	{ (long)_seMode_Release, "seMode-Release" },
	{ (long)_seMode_Set, "seMode-Set" },
	{ (long)_seMode_Alarm, "seMode-Alarm" },
	{ (long)_model_sensorEmer_Menix, "model-sensorEmer-Menix" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__enum_sensorEmer2s(struct soap *soap, enum ns__enum_sensorEmer n)
{	const char *s = soap_str_code(soap_codes_ns__enum_sensorEmer, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__enum_sensorEmer(struct soap *soap, const char *tag, int id, const enum ns__enum_sensorEmer *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__enum_sensorEmer), type);
	soap_send(soap, soap_ns__enum_sensorEmer2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns__enum_sensorEmer * SOAP_FMAC4 soap_get_ns__enum_sensorEmer(struct soap *soap, enum ns__enum_sensorEmer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__enum_sensorEmer(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__enum_sensorEmer(struct soap *soap, const char *s, enum ns__enum_sensorEmer *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns__enum_sensorEmer, s);
	if (map)
		*a = (enum ns__enum_sensorEmer)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__enum_sensorEmer)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__enum_sensorEmer * SOAP_FMAC4 soap_in_ns__enum_sensorEmer(struct soap *soap, const char *tag, enum ns__enum_sensorEmer *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ns__enum_sensorEmer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__enum_sensorEmer, sizeof(enum ns__enum_sensorEmer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__enum_sensorEmer(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__enum_sensorEmer *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__enum_sensorEmer, 0, sizeof(enum ns__enum_sensorEmer), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__fanSystemFunc(struct soap *soap, enum ns__fanSystemFunc *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__fanSystemFunc
	*a = SOAP_DEFAULT_ns__fanSystemFunc;
#else
	*a = (enum ns__fanSystemFunc)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__fanSystemFunc(struct soap *soap, const enum ns__fanSystemFunc *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__fanSystemFunc);
	if (soap_out_ns__fanSystemFunc(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns__fanSystemFunc[] =
{	{ (long)f_fanSystemDo_Power, "f-fanSystemDo-Power" },
	{ (long)f_fanSystemDo_AutoFan, "f-fanSystemDo-AutoFan" },
	{ (long)f_fanSystemDo_FanMode, "f-fanSystemDo-FanMode" },
	{ (long)f_fanSystemDo_FanWind, "f-fanSystemDo-FanWind" },
	{ (long)f_fanSystemDo_FanReservationSet, "f-fanSystemDo-FanReservationSet" },
	{ (long)f_fanSystemSt_Power, "f-fanSystemSt-Power" },
	{ (long)f_fanSystemSt_AutoFan, "f-fanSystemSt-AutoFan" },
	{ (long)f_fanSystemSt_FanMode, "f-fanSystemSt-FanMode" },
	{ (long)f_fanSystemSt_FanWind, "f-fanSystemSt-FanWind" },
	{ (long)f_fanSystemSt_FanReservationSet, "f-fanSystemSt-FanReservationSet" },
	{ (long)f_fanSystemSt_SensorMode, "f-fanSystemSt-SensorMode" },
	{ (long)f_fanSystemSt_DamperMode, "f-fanSystemSt-DamperMode" },
	{ (long)f_fanSystemSt_FilterEmpress, "f-fanSystemSt-FilterEmpress" },
	{ (long)f_fanSystemSt_AlarmMode, "f-fanSystemSt-AlarmMode" },
	{ (long)f_fanSystemSt_Temperature, "f-fanSystemSt-Temperature" },
	{ (long)f_fanSystemSt_CO2_Density, "f-fanSystemSt-CO2-Density" },
	{ (long)f_fanSystemSt_GAS_Density, "f-fanSystemSt-GAS-Density" },
	{ (long)f_fanSystemDevError, "f-fanSystemDevError" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__fanSystemFunc2s(struct soap *soap, enum ns__fanSystemFunc n)
{	const char *s = soap_str_code(soap_codes_ns__fanSystemFunc, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__fanSystemFunc(struct soap *soap, const char *tag, int id, const enum ns__fanSystemFunc *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__fanSystemFunc), type);
	soap_send(soap, soap_ns__fanSystemFunc2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns__fanSystemFunc * SOAP_FMAC4 soap_get_ns__fanSystemFunc(struct soap *soap, enum ns__fanSystemFunc *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__fanSystemFunc(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__fanSystemFunc(struct soap *soap, const char *s, enum ns__fanSystemFunc *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns__fanSystemFunc, s);
	if (map)
		*a = (enum ns__fanSystemFunc)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 17)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__fanSystemFunc)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__fanSystemFunc * SOAP_FMAC4 soap_in_ns__fanSystemFunc(struct soap *soap, const char *tag, enum ns__fanSystemFunc *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ns__fanSystemFunc *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__fanSystemFunc, sizeof(enum ns__fanSystemFunc), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__fanSystemFunc(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__fanSystemFunc *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__fanSystemFunc, 0, sizeof(enum ns__fanSystemFunc), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__enum_fanSystem(struct soap *soap, enum ns__enum_fanSystem *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__enum_fanSystem
	*a = SOAP_DEFAULT_ns__enum_fanSystem;
#else
	*a = (enum ns__enum_fanSystem)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__enum_fanSystem(struct soap *soap, const enum ns__enum_fanSystem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__enum_fanSystem);
	if (soap_out_ns__enum_fanSystem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns__enum_fanSystem[] =
{	{ (long)_fanSystemDo_Power_Off, "fanSystemDo-Power-Off" },
	{ (long)_fanSystemDo_Power_On, "fanSystemDo-Power-On" },
	{ (long)_fanSystemDo_AutoFan_ElectricHeat, "fanSystemDo-AutoFan-ElectricHeat" },
	{ (long)_fanSystemDo_AutoFan_GeneralFan, "fanSystemDo-AutoFan-GeneralFan" },
	{ (long)_fanSystemDo_FanMode_ElectricHeat, "fanSystemDo-FanMode-ElectricHeat" },
	{ (long)_fanSystemDo_FanMode_GeneralFan, "fanSystemDo-FanMode-GeneralFan" },
	{ (long)_fanSystemDo_FanMode_Schedule, "fanSystemDo-FanMode-Schedule" },
	{ (long)_fanSystemDo_FanMode_SleepingMode, "fanSystemDo-FanMode-SleepingMode" },
	{ (long)_fanSystemDo_Wind_Off, "fanSystemDo-Wind-Off" },
	{ (long)_fanSystemDo_Wind_Low, "fanSystemDo-Wind-Low" },
	{ (long)_fanSystemDo_Wind_Middle, "fanSystemDo-Wind-Middle" },
	{ (long)_fanSystemDo_Wind_High, "fanSystemDo-Wind-High" },
	{ (long)_fanSystemDo_ReservationSet_Set, "fanSystemDo-ReservationSet-Set" },
	{ (long)_fanSystemDo_ReservationSet_Release, "fanSystemDo-ReservationSet-Release" },
	{ (long)_fanSystemDo_ReservationSet_Running, "fanSystemDo-ReservationSet-Running" },
	{ (long)_fanSystemDo_ReservationSet_NotRunning, "fanSystemDo-ReservationSet-NotRunning" },
	{ (long)_fanSystemSt_Power_Off, "fanSystemSt-Power-Off" },
	{ (long)_fanSystemSt_Power_On, "fanSystemSt-Power-On" },
	{ (long)_fanSystemSt_AutoFan_ElectricHeat, "fanSystemSt-AutoFan-ElectricHeat" },
	{ (long)_fanSystemSt_AutoFan_GeneralFan, "fanSystemSt-AutoFan-GeneralFan" },
	{ (long)_fanSystemSt_CurrentFanMode_AutoFan, "fanSystemSt-CurrentFanMode-AutoFan" },
	{ (long)_fanSystemSt_FanMode_ElectricHeat, "fanSystemSt-FanMode-ElectricHeat" },
	{ (long)_fanSystemSt_FanMode_GeneralFan, "fanSystemSt-FanMode-GeneralFan" },
	{ (long)_fanSystemSt_FanMode_Schedule, "fanSystemSt-FanMode-Schedule" },
	{ (long)_fanSystemSt_FanMode_SleepingMode, "fanSystemSt-FanMode-SleepingMode" },
	{ (long)_fanSystemSt_CurrentFanMode_Manual, "fanSystemSt-CurrentFanMode-Manual" },
	{ (long)_fanSystemSt_Wind_Off, "fanSystemSt-Wind-Off" },
	{ (long)_fanSystemSt_Wind_Low, "fanSystemSt-Wind-Low" },
	{ (long)_fanSystemSt_Wind_Middle, "fanSystemSt-Wind-Middle" },
	{ (long)_fanSystemSt_Wind_High, "fanSystemSt-Wind-High" },
	{ (long)_fanSystemSt_FanReservationSetMode_Hour, "fanSystemSt-FanReservationSetMode-Hour" },
	{ (long)_fanSystemSt_FanReservationSetMode_Minute, "fanSystemSt-FanReservationSetMode-Minute" },
	{ (long)_fanSystemSt_ReservationSet_Set, "fanSystemSt-ReservationSet-Set" },
	{ (long)_fanSystemSt_ReservationSet_Release, "fanSystemSt-ReservationSet-Release" },
	{ (long)_fanSystemSt_ReservationSet_Running, "fanSystemSt-ReservationSet-Running" },
	{ (long)_fanSystemSt_ReservationSet_NotRunning, "fanSystemSt-ReservationSet-NotRunning" },
	{ (long)_fanSystemSt_SensorMode_NotExistSenosr, "fanSystemSt-SensorMode-NotExistSenosr" },
	{ (long)_fanSystemSt_SensorMode_GasSenosr, "fanSystemSt-SensorMode-GasSenosr" },
	{ (long)_fanSystemSt_SensorMode_CO2Senosr, "fanSystemSt-SensorMode-CO2Senosr" },
	{ (long)_fanSystemSt_DamperMode_NotExist, "fanSystemSt-DamperMode-NotExist" },
	{ (long)_fanSystemSt_DamperMode_Exist, "fanSystemSt-DamperMode-Exist" },
	{ (long)_fanSystemSt_FilterEmpressMode_Normal, "fanSystemSt-FilterEmpressMode-Normal" },
	{ (long)_fanSystemSt_FilterEmpressMode_Clean, "fanSystemSt-FilterEmpressMode-Clean" },
	{ (long)_fanSystemSt_FilterEmpressMode_Change, "fanSystemSt-FilterEmpressMode-Change" },
	{ (long)_fanSystemSt_FilterEmpressMode_FEChange, "fanSystemSt-FilterEmpressMode-FEChange" },
	{ (long)_fanSystemSt_AlarmMode_Normal, "fanSystemSt-AlarmMode-Normal" },
	{ (long)_fanSystemSt_AlarmMode_HighSpeedMotor, "fanSystemSt-AlarmMode-HighSpeedMotor" },
	{ (long)_fanSystemSt_AlarmMode_VentilationMotor, "fanSystemSt-AlarmMode-VentilationMotor" },
	{ (long)_fanSystemSt_AlarmMode_DamperMotor, "fanSystemSt-AlarmMode-DamperMotor" },
	{ (long)_fanSystemSt_AlarmMode_CO2, "fanSystemSt-AlarmMode-CO2" },
	{ (long)_fanSystemSt_AlarmMode_TemperatureMotor, "fanSystemSt-AlarmMode-TemperatureMotor" },
	{ (long)_fanSystemSt_AlarmMode_OverHeating, "fanSystemSt-AlarmMode-OverHeating" },
	{ (long)_fanSystemSt_AlarmMode_DeviceProtect, "fanSystemSt-AlarmMode-DeviceProtect" },
	{ (long)_fanSystemSt_CO2_DensityMode_CO2High, "fanSystemSt-CO2-DensityMode-CO2High" },
	{ (long)_fanSystemSt_CO2_DensityMode_CO2Low, "fanSystemSt-CO2-DensityMode-CO2Low" },
	{ (long)_fanSystemSt_GAS_Density_Low, "fanSystemSt-GAS-Density-Low" },
	{ (long)_fanSystemSt_GAS_Density_Middle, "fanSystemSt-GAS-Density-Middle" },
	{ (long)_fanSystemSt_GAS_Density_High, "fanSystemSt-GAS-Density-High" },
	{ (long)_model_fanSystem_KoKomTech, "model-fanSystem-KoKomTech" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__enum_fanSystem2s(struct soap *soap, enum ns__enum_fanSystem n)
{	const char *s = soap_str_code(soap_codes_ns__enum_fanSystem, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__enum_fanSystem(struct soap *soap, const char *tag, int id, const enum ns__enum_fanSystem *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__enum_fanSystem), type);
	soap_send(soap, soap_ns__enum_fanSystem2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns__enum_fanSystem * SOAP_FMAC4 soap_get_ns__enum_fanSystem(struct soap *soap, enum ns__enum_fanSystem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__enum_fanSystem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__enum_fanSystem(struct soap *soap, const char *s, enum ns__enum_fanSystem *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns__enum_fanSystem, s);
	if (map)
		*a = (enum ns__enum_fanSystem)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 58)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__enum_fanSystem)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__enum_fanSystem * SOAP_FMAC4 soap_in_ns__enum_fanSystem(struct soap *soap, const char *tag, enum ns__enum_fanSystem *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ns__enum_fanSystem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__enum_fanSystem, sizeof(enum ns__enum_fanSystem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__enum_fanSystem(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__enum_fanSystem *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__enum_fanSystem, 0, sizeof(enum ns__enum_fanSystem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__systemAirconFunc(struct soap *soap, enum ns__systemAirconFunc *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__systemAirconFunc
	*a = SOAP_DEFAULT_ns__systemAirconFunc;
#else
	*a = (enum ns__systemAirconFunc)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__systemAirconFunc(struct soap *soap, const enum ns__systemAirconFunc *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__systemAirconFunc);
	if (soap_out_ns__systemAirconFunc(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns__systemAirconFunc[] =
{	{ (long)f_systemAirconDo_Power, "f-systemAirconDo-Power" },
	{ (long)f_systemAirconDo_WindDirection, "f-systemAirconDo-WindDirection" },
	{ (long)f_systemAirconDo_WindPower, "f-systemAirconDo-WindPower" },
	{ (long)f_systemAirconDo_Temperature, "f-systemAirconDo-Temperature" },
	{ (long)f_systemAirconDo_Drive, "f-systemAirconDo-Drive" },
	{ (long)f_systemAirconDo_StatusQuery, "f-systemAirconDo-StatusQuery" },
	{ (long)f_systemAirconSt_Power, "f-systemAirconSt-Power" },
	{ (long)f_systemAirconSt_WindDirection, "f-systemAirconSt-WindDirection" },
	{ (long)f_systemAirconSt_WindPower, "f-systemAirconSt-WindPower" },
	{ (long)f_systemAirconSt_Temperature_Set, "f-systemAirconSt-Temperature-Set" },
	{ (long)f_systemAirconSt_Temperature_Current, "f-systemAirconSt-Temperature-Current" },
	{ (long)f_systemAirconSt_Drive, "f-systemAirconSt-Drive" },
	{ (long)f_systemAirconSt_Tracking, "f-systemAirconSt-Tracking" },
	{ (long)f_systemAirconSt_InnerRoom_Error, "f-systemAirconSt-InnerRoom-Error" },
	{ (long)f_systemAirconSt_OutRoom_Error, "f-systemAirconSt-OutRoom-Error" },
	{ (long)f_systemAirconSt_Installation, "f-systemAirconSt-Installation" },
	{ (long)f_systemAirconDevError, "f-systemAirconDevError" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__systemAirconFunc2s(struct soap *soap, enum ns__systemAirconFunc n)
{	const char *s = soap_str_code(soap_codes_ns__systemAirconFunc, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__systemAirconFunc(struct soap *soap, const char *tag, int id, const enum ns__systemAirconFunc *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__systemAirconFunc), type);
	soap_send(soap, soap_ns__systemAirconFunc2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns__systemAirconFunc * SOAP_FMAC4 soap_get_ns__systemAirconFunc(struct soap *soap, enum ns__systemAirconFunc *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__systemAirconFunc(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__systemAirconFunc(struct soap *soap, const char *s, enum ns__systemAirconFunc *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns__systemAirconFunc, s);
	if (map)
		*a = (enum ns__systemAirconFunc)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 16)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__systemAirconFunc)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__systemAirconFunc * SOAP_FMAC4 soap_in_ns__systemAirconFunc(struct soap *soap, const char *tag, enum ns__systemAirconFunc *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ns__systemAirconFunc *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__systemAirconFunc, sizeof(enum ns__systemAirconFunc), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__systemAirconFunc(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__systemAirconFunc *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__systemAirconFunc, 0, sizeof(enum ns__systemAirconFunc), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__enum_systemAircon(struct soap *soap, enum ns__enum_systemAircon *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__enum_systemAircon
	*a = SOAP_DEFAULT_ns__enum_systemAircon;
#else
	*a = (enum ns__enum_systemAircon)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__enum_systemAircon(struct soap *soap, const enum ns__enum_systemAircon *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__enum_systemAircon);
	if (soap_out_ns__enum_systemAircon(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns__enum_systemAircon[] =
{	{ (long)_systemAirconDo_Power_Off, "systemAirconDo-Power-Off" },
	{ (long)_systemAirconDo_Power_On, "systemAirconDo-Power-On" },
	{ (long)_systemAirconDo_Power_AllOff, "systemAirconDo-Power-AllOff" },
	{ (long)_systemAirconDo_Power_AllOn, "systemAirconDo-Power-AllOn" },
	{ (long)_systemAirconDo_WindDirection_UpDown, "systemAirconDo-WindDirection-UpDown" },
	{ (long)_systemAirconDo_WindDirection_LeftRight, "systemAirconDo-WindDirection-LeftRight" },
	{ (long)_systemAirconDo_WindDirection_UpDownLeftRight, "systemAirconDo-WindDirection-UpDownLeftRight" },
	{ (long)_systemAirconDo_WindDirection_Stop, "systemAirconDo-WindDirection-Stop" },
	{ (long)_systemAirconDo_Drive_Auto, "systemAirconDo-Drive-Auto" },
	{ (long)_systemAirconDo_Drive_Cooling, "systemAirconDo-Drive-Cooling" },
	{ (long)_systemAirconDo_Drive_Humidity, "systemAirconDo-Drive-Humidity" },
	{ (long)_systemAirconDo_Drive_Ventilation, "systemAirconDo-Drive-Ventilation" },
	{ (long)_systemAirconDo_Drive_Heating, "systemAirconDo-Drive-Heating" },
	{ (long)_systemAirconDo_WindPower_Auto, "systemAirconDo-WindPower-Auto" },
	{ (long)_systemAirconDo_WindPower_Breeze, "systemAirconDo-WindPower-Breeze" },
	{ (long)_systemAirconDo_WindPower_Middle, "systemAirconDo-WindPower-Middle" },
	{ (long)_systemAirconDo_WindPower_Super, "systemAirconDo-WindPower-Super" },
	{ (long)_systemAirconDo_WindPower_Natural, "systemAirconDo-WindPower-Natural" },
	{ (long)_systemAirconDo_StatusQuery_Start, "systemAirconDo-StatusQuery-Start" },
	{ (long)_systemAirconDo_StatusQuery_Stop, "systemAirconDo-StatusQuery-Stop" },
	{ (long)_systemAirconSt_Power_Start, "systemAirconSt-Power-Start" },
	{ (long)_systemAirconSt_Power_Stop, "systemAirconSt-Power-Stop" },
	{ (long)_systemAirconSt_WindDirection_UpDown, "systemAirconSt-WindDirection-UpDown" },
	{ (long)_systemAirconSt_WindDirection_LeftRight, "systemAirconSt-WindDirection-LeftRight" },
	{ (long)_systemAirconSt_WindDirection_UpDownLeftRight, "systemAirconSt-WindDirection-UpDownLeftRight" },
	{ (long)_systemAirconSt_WindDirection_Stop, "systemAirconSt-WindDirection-Stop" },
	{ (long)_systemAirconSt_WindPower_Auto, "systemAirconSt-WindPower-Auto" },
	{ (long)_systemAirconSt_WindPower_Breeze, "systemAirconSt-WindPower-Breeze" },
	{ (long)_systemAirconSt_WindPower_Middle, "systemAirconSt-WindPower-Middle" },
	{ (long)_systemAirconSt_WindPower_Super, "systemAirconSt-WindPower-Super" },
	{ (long)_systemAirconSt_WindPower_Natural, "systemAirconSt-WindPower-Natural" },
	{ (long)_systemAirconSt_Drive_Driving, "systemAirconSt-Drive-Driving" },
	{ (long)_systemAirconSt_Drive_EventRelease, "systemAirconSt-Drive-EventRelease" },
	{ (long)_systemAirconSt_Drive_Auto, "systemAirconSt-Drive-Auto" },
	{ (long)_systemAirconSt_Drive_JaeSang, "systemAirconSt-Drive-JaeSang" },
	{ (long)_systemAirconSt_Drive_Ventilation, "systemAirconSt-Drive-Ventilation" },
	{ (long)_systemAirconSt_Drive_Humidity, "systemAirconSt-Drive-Humidity" },
	{ (long)_systemAirconSt_Drive_Cooling, "systemAirconSt-Drive-Cooling" },
	{ (long)_systemAirconSt_Drive_Heating, "systemAirconSt-Drive-Heating" },
	{ (long)_systemAirconSt_Tracking_Success, "systemAirconSt-Tracking-Success" },
	{ (long)_systemAirconSt_Tracking_Fail, "systemAirconSt-Tracking-Fail" },
	{ (long)_systemAirconSt_Tracking_Searching, "systemAirconSt-Tracking-Searching" },
	{ (long)_systemAirconSt_Tracking_End, "systemAirconSt-Tracking-End" },
	{ (long)_systemAirconSt_Installation_Not_Exist, "systemAirconSt-Installation-Not-Exist" },
	{ (long)_systemAirconSt_InnerRoom_Error_Normal, "systemAirconSt-InnerRoom-Error-Normal" },
	{ (long)_systemAirconSt_InnerRoom_Error_InnerTemperature, "systemAirconSt-InnerRoom-Error-InnerTemperature" },
	{ (long)_systemAirconSt_InnerRoom_Error_EVA_IN, "systemAirconSt-InnerRoom-Error-EVA-IN" },
	{ (long)_systemAirconSt_InnerRoom_Error_FAN, "systemAirconSt-InnerRoom-Error-FAN" },
	{ (long)_systemAirconSt_InnerRoom_Error_Communication, "systemAirconSt-InnerRoom-Error-Communication" },
	{ (long)_systemAirconSt_InnerRoom_Error_Floating_Switch, "systemAirconSt-InnerRoom-Error-Floating-Switch" },
	{ (long)_systemAirconSt_InnerRoom_Error_Open_Two, "systemAirconSt-InnerRoom-Error-Open-Two" },
	{ (long)_systemAirconSt_InnerRoom_Error_EVA_OUT, "systemAirconSt-InnerRoom-Error-EVA-OUT" },
	{ (long)_systemAirconSt_OutRoom_Error_Normal, "systemAirconSt-OutRoom-Error-Normal" },
	{ (long)_systemAirconSt_OutRoom_Error_Temp, "systemAirconSt-OutRoom-Error-Temp" },
	{ (long)_systemAirconSt_OutRoom_Error_Sensor, "systemAirconSt-OutRoom-Error-Sensor" },
	{ (long)_systemAirconSt_OutRoom_Error_Cond, "systemAirconSt-OutRoom-Error-Cond" },
	{ (long)_systemAirconSt_OutRoom_Error_Commnuication, "systemAirconSt-OutRoom-Error-Commnuication" },
	{ (long)_systemAirconSt_OutRoom_Error_Error, "systemAirconSt-OutRoom-Error-Error" },
	{ (long)_systemAirconSt_OutRoom_Error_lowPower, "systemAirconSt-OutRoom-Error-lowPower" },
	{ (long)_systemAirconSt_OutRoom_Error_MagicalPower, "systemAirconSt-OutRoom-Error-MagicalPower" },
	{ (long)_systemAirconSt_OutRoom_Error_InitCommunication, "systemAirconSt-OutRoom-Error-InitCommunication" },
	{ (long)_model_systemAircon_SamSung, "model-systemAircon-SamSung" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__enum_systemAircon2s(struct soap *soap, enum ns__enum_systemAircon n)
{	const char *s = soap_str_code(soap_codes_ns__enum_systemAircon, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__enum_systemAircon(struct soap *soap, const char *tag, int id, const enum ns__enum_systemAircon *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__enum_systemAircon), type);
	soap_send(soap, soap_ns__enum_systemAircon2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns__enum_systemAircon * SOAP_FMAC4 soap_get_ns__enum_systemAircon(struct soap *soap, enum ns__enum_systemAircon *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__enum_systemAircon(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__enum_systemAircon(struct soap *soap, const char *s, enum ns__enum_systemAircon *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns__enum_systemAircon, s);
	if (map)
		*a = (enum ns__enum_systemAircon)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 61)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__enum_systemAircon)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__enum_systemAircon * SOAP_FMAC4 soap_in_ns__enum_systemAircon(struct soap *soap, const char *tag, enum ns__enum_systemAircon *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ns__enum_systemAircon *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__enum_systemAircon, sizeof(enum ns__enum_systemAircon), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__enum_systemAircon(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__enum_systemAircon *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__enum_systemAircon, 0, sizeof(enum ns__enum_systemAircon), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__bundleLightFunc(struct soap *soap, enum ns__bundleLightFunc *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__bundleLightFunc
	*a = SOAP_DEFAULT_ns__bundleLightFunc;
#else
	*a = (enum ns__bundleLightFunc)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__bundleLightFunc(struct soap *soap, const enum ns__bundleLightFunc *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__bundleLightFunc);
	if (soap_out_ns__bundleLightFunc(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns__bundleLightFunc[] =
{	{ (long)f_bundleLightPower, "f-bundleLightPower" },
	{ (long)f_bundleLightExit, "f-bundleLightExit" },
	{ (long)f_readyEnergyPower, "f-readyEnergyPower" },
	{ (long)f_gasValve, "f-gasValve" },
	{ (long)f_bundleLightElevator, "f-bundleLightElevator" },
	{ (long)f_bundleLightDevError, "f-bundleLightDevError" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__bundleLightFunc2s(struct soap *soap, enum ns__bundleLightFunc n)
{	const char *s = soap_str_code(soap_codes_ns__bundleLightFunc, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__bundleLightFunc(struct soap *soap, const char *tag, int id, const enum ns__bundleLightFunc *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__bundleLightFunc), type);
	soap_send(soap, soap_ns__bundleLightFunc2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns__bundleLightFunc * SOAP_FMAC4 soap_get_ns__bundleLightFunc(struct soap *soap, enum ns__bundleLightFunc *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__bundleLightFunc(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__bundleLightFunc(struct soap *soap, const char *s, enum ns__bundleLightFunc *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns__bundleLightFunc, s);
	if (map)
		*a = (enum ns__bundleLightFunc)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__bundleLightFunc)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__bundleLightFunc * SOAP_FMAC4 soap_in_ns__bundleLightFunc(struct soap *soap, const char *tag, enum ns__bundleLightFunc *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ns__bundleLightFunc *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__bundleLightFunc, sizeof(enum ns__bundleLightFunc), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__bundleLightFunc(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__bundleLightFunc *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__bundleLightFunc, 0, sizeof(enum ns__bundleLightFunc), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__enum_bundleLight(struct soap *soap, enum ns__enum_bundleLight *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__enum_bundleLight
	*a = SOAP_DEFAULT_ns__enum_bundleLight;
#else
	*a = (enum ns__enum_bundleLight)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__enum_bundleLight(struct soap *soap, const enum ns__enum_bundleLight *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__enum_bundleLight);
	if (soap_out_ns__enum_bundleLight(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns__enum_bundleLight[] =
{	{ (long)_bundleLightPower_Off, "bundleLightPower-Off" },
	{ (long)_bundleLightPower_On, "bundleLightPower-On" },
	{ (long)_bundleLightPower_AllOff, "bundleLightPower-AllOff" },
	{ (long)_bundleLightPower_AllOn, "bundleLightPower-AllOn" },
	{ (long)_readyEnergyPower_Off, "readyEnergyPower-Off" },
	{ (long)_readyEnergyPower_On, "readyEnergyPower-On" },
	{ (long)_readyEnergyPower_AllOff, "readyEnergyPower-AllOff" },
	{ (long)_readyEnergyPower_AllOn, "readyEnergyPower-AllOn" },
	{ (long)_bundleLightExit_Notify, "bundleLightExit-Notify" },
	{ (long)_bundleLightExit_Entry_Accept, "bundleLightExit-Entry-Accept" },
	{ (long)_bundleLightExit_Entry_Deny, "bundleLightExit-Entry-Deny" },
	{ (long)_bundleLightExit_Setting, "bundleLightExit-Setting" },
	{ (long)_bundleLightExit_Release, "bundleLightExit-Release" },
	{ (long)_bundleLightElevator_Up, "bundleLightElevator-Up" },
	{ (long)_bundleLightElevator_Down, "bundleLightElevator-Down" },
	{ (long)_bundleLightElevator_Fail, "bundleLightElevator-Fail" },
	{ (long)_bundleLightElevator_Success, "bundleLightElevator-Success" },
	{ (long)_gasValve_Entry_Accept, "gasValve-Entry-Accept" },
	{ (long)_gasValve_Entry_Deny, "gasValve-Entry-Deny" },
	{ (long)_model_BundleLight_icom, "model-BundleLight-icom" },
	{ (long)_model_BundleLight_Clio, "model-BundleLight-Clio" },
	{ (long)_model_BundleLight_Anam, "model-BundleLight-Anam" },
	{ (long)_model_BundleLight_Speel, "model-BundleLight-Speel" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__enum_bundleLight2s(struct soap *soap, enum ns__enum_bundleLight n)
{	const char *s = soap_str_code(soap_codes_ns__enum_bundleLight, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__enum_bundleLight(struct soap *soap, const char *tag, int id, const enum ns__enum_bundleLight *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__enum_bundleLight), type);
	soap_send(soap, soap_ns__enum_bundleLight2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns__enum_bundleLight * SOAP_FMAC4 soap_get_ns__enum_bundleLight(struct soap *soap, enum ns__enum_bundleLight *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__enum_bundleLight(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__enum_bundleLight(struct soap *soap, const char *s, enum ns__enum_bundleLight *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns__enum_bundleLight, s);
	if (map)
		*a = (enum ns__enum_bundleLight)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 22)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__enum_bundleLight)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__enum_bundleLight * SOAP_FMAC4 soap_in_ns__enum_bundleLight(struct soap *soap, const char *tag, enum ns__enum_bundleLight *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ns__enum_bundleLight *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__enum_bundleLight, sizeof(enum ns__enum_bundleLight), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__enum_bundleLight(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__enum_bundleLight *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__enum_bundleLight, 0, sizeof(enum ns__enum_bundleLight), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__curtainFunc(struct soap *soap, enum ns__curtainFunc *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__curtainFunc
	*a = SOAP_DEFAULT_ns__curtainFunc;
#else
	*a = (enum ns__curtainFunc)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__curtainFunc(struct soap *soap, const enum ns__curtainFunc *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__curtainFunc);
	if (soap_out_ns__curtainFunc(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns__curtainFunc[] =
{	{ (long)f_curtainDo, "f-curtainDo" },
	{ (long)f_curtainAngular, "f-curtainAngular" },
	{ (long)f_curtainDevError, "f-curtainDevError" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__curtainFunc2s(struct soap *soap, enum ns__curtainFunc n)
{	const char *s = soap_str_code(soap_codes_ns__curtainFunc, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__curtainFunc(struct soap *soap, const char *tag, int id, const enum ns__curtainFunc *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__curtainFunc), type);
	soap_send(soap, soap_ns__curtainFunc2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns__curtainFunc * SOAP_FMAC4 soap_get_ns__curtainFunc(struct soap *soap, enum ns__curtainFunc *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__curtainFunc(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__curtainFunc(struct soap *soap, const char *s, enum ns__curtainFunc *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns__curtainFunc, s);
	if (map)
		*a = (enum ns__curtainFunc)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__curtainFunc)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__curtainFunc * SOAP_FMAC4 soap_in_ns__curtainFunc(struct soap *soap, const char *tag, enum ns__curtainFunc *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ns__curtainFunc *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__curtainFunc, sizeof(enum ns__curtainFunc), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__curtainFunc(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__curtainFunc *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__curtainFunc, 0, sizeof(enum ns__curtainFunc), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__enum_curtain(struct soap *soap, enum ns__enum_curtain *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__enum_curtain
	*a = SOAP_DEFAULT_ns__enum_curtain;
#else
	*a = (enum ns__enum_curtain)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__enum_curtain(struct soap *soap, const enum ns__enum_curtain *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__enum_curtain);
	if (soap_out_ns__enum_curtain(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns__enum_curtain[] =
{	{ (long)_curtainDo_Close, "curtainDo-Close" },
	{ (long)_curtainDo_Open, "curtainDo-Open" },
	{ (long)_curtainDo_Stop, "curtainDo-Stop" },
	{ (long)_model_curtain_PlanetInt, "model-curtain-PlanetInt" },
	{ (long)_model_curtain_CLIO, "model-curtain-CLIO" },
	{ (long)_model_curtain_HaMun, "model-curtain-HaMun" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__enum_curtain2s(struct soap *soap, enum ns__enum_curtain n)
{	const char *s = soap_str_code(soap_codes_ns__enum_curtain, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__enum_curtain(struct soap *soap, const char *tag, int id, const enum ns__enum_curtain *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__enum_curtain), type);
	soap_send(soap, soap_ns__enum_curtain2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns__enum_curtain * SOAP_FMAC4 soap_get_ns__enum_curtain(struct soap *soap, enum ns__enum_curtain *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__enum_curtain(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__enum_curtain(struct soap *soap, const char *s, enum ns__enum_curtain *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns__enum_curtain, s);
	if (map)
		*a = (enum ns__enum_curtain)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__enum_curtain)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__enum_curtain * SOAP_FMAC4 soap_in_ns__enum_curtain(struct soap *soap, const char *tag, enum ns__enum_curtain *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ns__enum_curtain *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__enum_curtain, sizeof(enum ns__enum_curtain), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__enum_curtain(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__enum_curtain *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__enum_curtain, 0, sizeof(enum ns__enum_curtain), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gasValveFunc(struct soap *soap, enum ns__gasValveFunc *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__gasValveFunc
	*a = SOAP_DEFAULT_ns__gasValveFunc;
#else
	*a = (enum ns__gasValveFunc)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gasValveFunc(struct soap *soap, const enum ns__gasValveFunc *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__gasValveFunc);
	if (soap_out_ns__gasValveFunc(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns__gasValveFunc[] =
{	{ (long)f_gvDo, "f-gvDo" },
	{ (long)f_gvAlarm, "f-gvAlarm" },
	{ (long)f_gvDevError, "f-gvDevError" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__gasValveFunc2s(struct soap *soap, enum ns__gasValveFunc n)
{	const char *s = soap_str_code(soap_codes_ns__gasValveFunc, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gasValveFunc(struct soap *soap, const char *tag, int id, const enum ns__gasValveFunc *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__gasValveFunc), type);
	soap_send(soap, soap_ns__gasValveFunc2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns__gasValveFunc * SOAP_FMAC4 soap_get_ns__gasValveFunc(struct soap *soap, enum ns__gasValveFunc *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gasValveFunc(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__gasValveFunc(struct soap *soap, const char *s, enum ns__gasValveFunc *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns__gasValveFunc, s);
	if (map)
		*a = (enum ns__gasValveFunc)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__gasValveFunc)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__gasValveFunc * SOAP_FMAC4 soap_in_ns__gasValveFunc(struct soap *soap, const char *tag, enum ns__gasValveFunc *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ns__gasValveFunc *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__gasValveFunc, sizeof(enum ns__gasValveFunc), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__gasValveFunc(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__gasValveFunc *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__gasValveFunc, 0, sizeof(enum ns__gasValveFunc), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__enum_gasValve(struct soap *soap, enum ns__enum_gasValve *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__enum_gasValve
	*a = SOAP_DEFAULT_ns__enum_gasValve;
#else
	*a = (enum ns__enum_gasValve)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__enum_gasValve(struct soap *soap, const enum ns__enum_gasValve *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__enum_gasValve);
	if (soap_out_ns__enum_gasValve(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns__enum_gasValve[] =
{	{ (long)_gvDo_Close, "gvDo-Close" },
	{ (long)_gvDo_Open, "gvDo-Open" },
	{ (long)_gvAlarm_On, "gvAlarm-On" },
	{ (long)_gvAlarm_Off, "gvAlarm-Off" },
	{ (long)_model_GasValve_Shinwoo, "model-GasValve-Shinwoo" },
	{ (long)_model_GasValve_GoIM, "model-GasValve-GoIM" },
	{ (long)_model_GasValve_Mat, "model-GasValve-Mat" },
	{ (long)_model_GasValve_koreaFire, "model-GasValve-koreaFire" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__enum_gasValve2s(struct soap *soap, enum ns__enum_gasValve n)
{	const char *s = soap_str_code(soap_codes_ns__enum_gasValve, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__enum_gasValve(struct soap *soap, const char *tag, int id, const enum ns__enum_gasValve *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__enum_gasValve), type);
	soap_send(soap, soap_ns__enum_gasValve2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns__enum_gasValve * SOAP_FMAC4 soap_get_ns__enum_gasValve(struct soap *soap, enum ns__enum_gasValve *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__enum_gasValve(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__enum_gasValve(struct soap *soap, const char *s, enum ns__enum_gasValve *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns__enum_gasValve, s);
	if (map)
		*a = (enum ns__enum_gasValve)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 7)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__enum_gasValve)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__enum_gasValve * SOAP_FMAC4 soap_in_ns__enum_gasValve(struct soap *soap, const char *tag, enum ns__enum_gasValve *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ns__enum_gasValve *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__enum_gasValve, sizeof(enum ns__enum_gasValve), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__enum_gasValve(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__enum_gasValve *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__enum_gasValve, 0, sizeof(enum ns__enum_gasValve), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__lightFunc(struct soap *soap, enum ns__lightFunc *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__lightFunc
	*a = SOAP_DEFAULT_ns__lightFunc;
#else
	*a = (enum ns__lightFunc)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__lightFunc(struct soap *soap, const enum ns__lightFunc *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__lightFunc);
	if (soap_out_ns__lightFunc(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns__lightFunc[] =
{	{ (long)f_lightPower, "f-lightPower" },
	{ (long)f_dimmableLevel, "f-dimmableLevel" },
	{ (long)f_lightDevError, "f-lightDevError" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__lightFunc2s(struct soap *soap, enum ns__lightFunc n)
{	const char *s = soap_str_code(soap_codes_ns__lightFunc, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__lightFunc(struct soap *soap, const char *tag, int id, const enum ns__lightFunc *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__lightFunc), type);
	soap_send(soap, soap_ns__lightFunc2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns__lightFunc * SOAP_FMAC4 soap_get_ns__lightFunc(struct soap *soap, enum ns__lightFunc *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__lightFunc(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__lightFunc(struct soap *soap, const char *s, enum ns__lightFunc *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns__lightFunc, s);
	if (map)
		*a = (enum ns__lightFunc)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__lightFunc)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__lightFunc * SOAP_FMAC4 soap_in_ns__lightFunc(struct soap *soap, const char *tag, enum ns__lightFunc *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ns__lightFunc *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__lightFunc, sizeof(enum ns__lightFunc), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__lightFunc(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__lightFunc *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__lightFunc, 0, sizeof(enum ns__lightFunc), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__enum_light(struct soap *soap, enum ns__enum_light *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__enum_light
	*a = SOAP_DEFAULT_ns__enum_light;
#else
	*a = (enum ns__enum_light)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__enum_light(struct soap *soap, const enum ns__enum_light *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__enum_light);
	if (soap_out_ns__enum_light(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns__enum_light[] =
{	{ (long)_lightPower_Off, "lightPower-Off" },
	{ (long)_lightPower_On, "lightPower-On" },
	{ (long)_lightPower_AllOff, "lightPower-AllOff" },
	{ (long)_lightPower_AllOn, "lightPower-AllOn" },
	{ (long)_lightSwitch_Binary, "lightSwitch-Binary" },
	{ (long)_lightSwitch_Dimmable, "lightSwitch-Dimmable" },
	{ (long)_model_Light_JoongAngControl, "model-Light-JoongAngControl" },
	{ (long)_model_Light_Clio, "model-Light-Clio" },
	{ (long)_model_Light_Anam, "model-Light-Anam" },
	{ (long)_model_Light_GoIM, "model-Light-GoIM" },
	{ (long)_model_Light_PlanetInt, "model-Light-PlanetInt" },
	{ (long)_model_UnKnown, "model-UnKnown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__enum_light2s(struct soap *soap, enum ns__enum_light n)
{	const char *s = soap_str_code(soap_codes_ns__enum_light, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__enum_light(struct soap *soap, const char *tag, int id, const enum ns__enum_light *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__enum_light), type);
	soap_send(soap, soap_ns__enum_light2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns__enum_light * SOAP_FMAC4 soap_get_ns__enum_light(struct soap *soap, enum ns__enum_light *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__enum_light(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__enum_light(struct soap *soap, const char *s, enum ns__enum_light *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns__enum_light, s);
	if (map)
		*a = (enum ns__enum_light)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 10)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__enum_light)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__enum_light * SOAP_FMAC4 soap_in_ns__enum_light(struct soap *soap, const char *tag, enum ns__enum_light *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ns__enum_light *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__enum_light, sizeof(enum ns__enum_light), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__enum_light(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__enum_light *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__enum_light, 0, sizeof(enum ns__enum_light), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__boilerFunc(struct soap *soap, enum ns__boilerFunc *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__boilerFunc
	*a = SOAP_DEFAULT_ns__boilerFunc;
#else
	*a = (enum ns__boilerFunc)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__boilerFunc(struct soap *soap, const enum ns__boilerFunc *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__boilerFunc);
	if (soap_out_ns__boilerFunc(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns__boilerFunc[] =
{	{ (long)f_boilerPower, "f-boilerPower" },
	{ (long)f_boilerHeatingPower, "f-boilerHeatingPower" },
	{ (long)f_boilerOutMode, "f-boilerOutMode" },
	{ (long)f_boilerRequestedTemperature, "f-boilerRequestedTemperature" },
	{ (long)f_boilerCurrentTemperature, "f-boilerCurrentTemperature" },
	{ (long)f_boilerHeatingWaterTemperature, "f-boilerHeatingWaterTemperature" },
	{ (long)f_boilerDevError, "f-boilerDevError" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__boilerFunc2s(struct soap *soap, enum ns__boilerFunc n)
{	const char *s = soap_str_code(soap_codes_ns__boilerFunc, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__boilerFunc(struct soap *soap, const char *tag, int id, const enum ns__boilerFunc *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__boilerFunc), type);
	soap_send(soap, soap_ns__boilerFunc2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns__boilerFunc * SOAP_FMAC4 soap_get_ns__boilerFunc(struct soap *soap, enum ns__boilerFunc *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__boilerFunc(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__boilerFunc(struct soap *soap, const char *s, enum ns__boilerFunc *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns__boilerFunc, s);
	if (map)
		*a = (enum ns__boilerFunc)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__boilerFunc)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__boilerFunc * SOAP_FMAC4 soap_in_ns__boilerFunc(struct soap *soap, const char *tag, enum ns__boilerFunc *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ns__boilerFunc *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__boilerFunc, sizeof(enum ns__boilerFunc), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__boilerFunc(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__boilerFunc *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__boilerFunc, 0, sizeof(enum ns__boilerFunc), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__enum_boiler(struct soap *soap, enum ns__enum_boiler *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__enum_boiler
	*a = SOAP_DEFAULT_ns__enum_boiler;
#else
	*a = (enum ns__enum_boiler)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__enum_boiler(struct soap *soap, const enum ns__enum_boiler *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__enum_boiler);
	if (soap_out_ns__enum_boiler(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns__enum_boiler[] =
{	{ (long)_boilerPower_Off, "boilerPower-Off" },
	{ (long)_boilerPower_On, "boilerPower-On" },
	{ (long)_boilerHeating_Off, "boilerHeating-Off" },
	{ (long)_boilerHeating_On, "boilerHeating-On" },
	{ (long)_boilerOutMode_Set, "boilerOutMode-Set" },
	{ (long)_boilerOutMode_Release, "boilerOutMode-Release" },
	{ (long)_boilerDipSwitchMode_Hypocaust, "boilerDipSwitchMode-Hypocaust" },
	{ (long)_boilerDipSwitchMode_InnerTemperature, "boilerDipSwitchMode-InnerTemperature" },
	{ (long)_model_boiler_Rinnai, "model-boiler-Rinnai" },
	{ (long)_model_boiler_Kiturami, "model-boiler-Kiturami" },
	{ (long)_model_boiler_KyungDong, "model-boiler-KyungDong" },
	{ (long)_model_boiler_HansungCisco, "model-boiler-HansungCisco" },
	{ (long)_model_boiler_HauWell, "model-boiler-HauWell" },
	{ (long)_model_boiler_HanEnergy, "model-boiler-HanEnergy" },
	{ (long)_model_boiler_Valcon, "model-boiler-Valcon" },
	{ (long)_model_boiler_Kotech, "model-boiler-Kotech" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__enum_boiler2s(struct soap *soap, enum ns__enum_boiler n)
{	const char *s = soap_str_code(soap_codes_ns__enum_boiler, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__enum_boiler(struct soap *soap, const char *tag, int id, const enum ns__enum_boiler *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__enum_boiler), type);
	soap_send(soap, soap_ns__enum_boiler2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns__enum_boiler * SOAP_FMAC4 soap_get_ns__enum_boiler(struct soap *soap, enum ns__enum_boiler *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__enum_boiler(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__enum_boiler(struct soap *soap, const char *s, enum ns__enum_boiler *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns__enum_boiler, s);
	if (map)
		*a = (enum ns__enum_boiler)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 15)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__enum_boiler)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__enum_boiler * SOAP_FMAC4 soap_in_ns__enum_boiler(struct soap *soap, const char *tag, enum ns__enum_boiler *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ns__enum_boiler *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__enum_boiler, sizeof(enum ns__enum_boiler), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__enum_boiler(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__enum_boiler *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__enum_boiler, 0, sizeof(enum ns__enum_boiler), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__deviceCategoryFunc(struct soap *soap, enum ns__deviceCategoryFunc *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__deviceCategoryFunc
	*a = SOAP_DEFAULT_ns__deviceCategoryFunc;
#else
	*a = (enum ns__deviceCategoryFunc)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__deviceCategoryFunc(struct soap *soap, const enum ns__deviceCategoryFunc *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__deviceCategoryFunc);
	if (soap_out_ns__deviceCategoryFunc(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns__deviceCategoryFunc[] =
{	{ (long)f_deviceCategory, "f-deviceCategory" },
	{ (long)f_deviceCategoryDevError, "f-deviceCategoryDevError" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__deviceCategoryFunc2s(struct soap *soap, enum ns__deviceCategoryFunc n)
{	const char *s = soap_str_code(soap_codes_ns__deviceCategoryFunc, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__deviceCategoryFunc(struct soap *soap, const char *tag, int id, const enum ns__deviceCategoryFunc *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__deviceCategoryFunc), type);
	soap_send(soap, soap_ns__deviceCategoryFunc2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns__deviceCategoryFunc * SOAP_FMAC4 soap_get_ns__deviceCategoryFunc(struct soap *soap, enum ns__deviceCategoryFunc *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__deviceCategoryFunc(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__deviceCategoryFunc(struct soap *soap, const char *s, enum ns__deviceCategoryFunc *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns__deviceCategoryFunc, s);
	if (map)
		*a = (enum ns__deviceCategoryFunc)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__deviceCategoryFunc)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__deviceCategoryFunc * SOAP_FMAC4 soap_in_ns__deviceCategoryFunc(struct soap *soap, const char *tag, enum ns__deviceCategoryFunc *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ns__deviceCategoryFunc *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__deviceCategoryFunc, sizeof(enum ns__deviceCategoryFunc), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__deviceCategoryFunc(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__deviceCategoryFunc *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__deviceCategoryFunc, 0, sizeof(enum ns__deviceCategoryFunc), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__enum_config_Common_Error(struct soap *soap, enum ns__enum_config_Common_Error *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__enum_config_Common_Error
	*a = SOAP_DEFAULT_ns__enum_config_Common_Error;
#else
	*a = (enum ns__enum_config_Common_Error)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__enum_config_Common_Error(struct soap *soap, const enum ns__enum_config_Common_Error *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__enum_config_Common_Error);
	if (soap_out_ns__enum_config_Common_Error(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns__enum_config_Common_Error[] =
{	{ (long)_not_error, "not-error" },
	{ (long)_not_founded_file, "not-founded-file" },
	{ (long)_not_founded_configuration_info, "not-founded-configuration-info" },
	{ (long)_not_founded_mismatch_configuration, "not-founded-mismatch-configuration" },
	{ (long)_not_supported_function, "not-supported-function" },
	{ (long)_supported_function, "supported-function" },
	{ (long)_not_supported_device, "not-supported-device" },
	{ (long)_device_support, "device-support" },
	{ (long)_not_response_control, "not-response-control" },
	{ (long)_not_device_use, "not-device-use" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__enum_config_Common_Error2s(struct soap *soap, enum ns__enum_config_Common_Error n)
{	const char *s = soap_str_code(soap_codes_ns__enum_config_Common_Error, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__enum_config_Common_Error(struct soap *soap, const char *tag, int id, const enum ns__enum_config_Common_Error *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__enum_config_Common_Error), type);
	soap_send(soap, soap_ns__enum_config_Common_Error2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns__enum_config_Common_Error * SOAP_FMAC4 soap_get_ns__enum_config_Common_Error(struct soap *soap, enum ns__enum_config_Common_Error *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__enum_config_Common_Error(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__enum_config_Common_Error(struct soap *soap, const char *s, enum ns__enum_config_Common_Error *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns__enum_config_Common_Error, s);
	if (map)
		*a = (enum ns__enum_config_Common_Error)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 9)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__enum_config_Common_Error)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__enum_config_Common_Error * SOAP_FMAC4 soap_in_ns__enum_config_Common_Error(struct soap *soap, const char *tag, enum ns__enum_config_Common_Error *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ns__enum_config_Common_Error *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__enum_config_Common_Error, sizeof(enum ns__enum_config_Common_Error), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__enum_config_Common_Error(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__enum_config_Common_Error *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__enum_config_Common_Error, 0, sizeof(enum ns__enum_config_Common_Error), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__enum_device_connect_check(struct soap *soap, enum ns__enum_device_connect_check *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__enum_device_connect_check
	*a = SOAP_DEFAULT_ns__enum_device_connect_check;
#else
	*a = (enum ns__enum_device_connect_check)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__enum_device_connect_check(struct soap *soap, const enum ns__enum_device_connect_check *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__enum_device_connect_check);
	if (soap_out_ns__enum_device_connect_check(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns__enum_device_connect_check[] =
{	{ (long)_device_connect, "device-connect" },
	{ (long)_not_device_disconnect, "not-device-disconnect" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__enum_device_connect_check2s(struct soap *soap, enum ns__enum_device_connect_check n)
{	const char *s = soap_str_code(soap_codes_ns__enum_device_connect_check, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__enum_device_connect_check(struct soap *soap, const char *tag, int id, const enum ns__enum_device_connect_check *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__enum_device_connect_check), type);
	soap_send(soap, soap_ns__enum_device_connect_check2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns__enum_device_connect_check * SOAP_FMAC4 soap_get_ns__enum_device_connect_check(struct soap *soap, enum ns__enum_device_connect_check *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__enum_device_connect_check(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__enum_device_connect_check(struct soap *soap, const char *s, enum ns__enum_device_connect_check *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns__enum_device_connect_check, s);
	if (map)
		*a = (enum ns__enum_device_connect_check)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__enum_device_connect_check)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__enum_device_connect_check * SOAP_FMAC4 soap_in_ns__enum_device_connect_check(struct soap *soap, const char *tag, enum ns__enum_device_connect_check *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ns__enum_device_connect_check *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__enum_device_connect_check, sizeof(enum ns__enum_device_connect_check), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__enum_device_connect_check(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__enum_device_connect_check *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__enum_device_connect_check, 0, sizeof(enum ns__enum_device_connect_check), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__enum_devError(struct soap *soap, enum ns__enum_devError *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__enum_devError
	*a = SOAP_DEFAULT_ns__enum_devError;
#else
	*a = (enum ns__enum_devError)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__enum_devError(struct soap *soap, const enum ns__enum_devError *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__enum_devError);
	if (soap_out_ns__enum_devError(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns__enum_devError[] =
{	{ (long)devError_no, "devError-no" },
	{ (long)devError_232_Serial_Port_Open_Error, "devError-232-Serial-Port-Open-Error" },
	{ (long)devError_lncp_Common_Micom_Error, "devError-lncp-Common-Micom-Error" },
	{ (long)devError_lncp_Common_Running_Door_Open, "devError-lncp-Common-Running-Door-Open" },
	{ (long)devError_lncp_Common_Hardware_Error, "devError-lncp-Common-Hardware-Error" },
	{ (long)devError_lncp_Common_Sensor_Error, "devError-lncp-Common-Sensor-Error" },
	{ (long)devError_lncp_Common_Motor_Error, "devError-lncp-Common-Motor-Error" },
	{ (long)devError_lncp_Common_Power_Fail, "devError-lncp-Common-Power-Fail" },
	{ (long)devError_lncp_Common_Temperature_Range_Error, "devError-lncp-Common-Temperature-Range-Error" },
	{ (long)devError_lncp_Common_Device_Preempted_Error, "devError-lncp-Common-Device-Preempted-Error" },
	{ (long)devError_lncp_Common_Device_control_timeout, "devError-lncp-Common-Device-control-timeout" },
	{ (long)devError_lncp_Common_Device_Not_Exist_DD, "devError-lncp-Common-Device-Not-Exist-DD" },
	{ (long)devError_lncp_Common_Device_Nak_Error, "devError-lncp-Common-Device-Nak-Error" },
	{ (long)devError_lncp_Common_Incorrect_Option_Setting, "devError-lncp-Common-Incorrect-Option-Setting" },
	{ (long)devError_lncp_Common_Argument_Error, "devError-lncp-Common-Argument-Error" },
	{ (long)devError_485_Serial_Port_Open_Error, "devError-485-Serial-Port-Open-Error" },
	{ (long)devError_TTL_Serial_Port_Open_Error, "devError-TTL-Serial-Port-Open-Error" },
	{ (long)devError_boiler_DisConnect, "devError-boiler-DisConnect" },
	{ (long)devError_light_DisConnect, "devError-light-DisConnect" },
	{ (long)devError_gas_DisConnect, "devError-gas-DisConnect" },
	{ (long)devError_door_DisConnect, "devError-door-DisConnect" },
	{ (long)devError_outlet_DisConnect, "devError-outlet-DisConnect" },
	{ (long)devError_curtain_DisConnect, "devError-curtain-DisConnect" },
	{ (long)devError_airCleaner_DisConnect, "devError-airCleaner-DisConnect" },
	{ (long)devError_bide_DisConnect, "devError-bide-DisConnect" },
	{ (long)devError_aroma_DisConnect, "devError-aroma-DisConnect" },
	{ (long)devError_rf_DisConnect, "devError-rf-DisConnect" },
	{ (long)devError_plc_DisConnect, "devError-plc-DisConnect" },
	{ (long)devError_bundleLight_DisConnect, "devError-bundleLight-DisConnect" },
	{ (long)devError_systemAircon_DisConnect, "devError-systemAircon-DisConnect" },
	{ (long)devError_fanSystem_DisConnect, "devError-fanSystem-DisConnect" },
	{ (long)devError_aircon_DisConnect, "devError-aircon-DisConnect" },
	{ (long)devError_washMachine_DisConnect, "devError-washMachine-DisConnect" },
	{ (long)devError_dishWashMachine_DisConnect, "devError-dishWashMachine-DisConnect" },
	{ (long)devError_gasOven_DisConnect, "devError-gasOven-DisConnect" },
	{ (long)devError_microwave_DisConnect, "devError-microwave-DisConnect" },
	{ (long)devError_television_DisConnect, "devError-television-DisConnect" },
	{ (long)devError_audio_DisConnect, "devError-audio-DisConnect" },
	{ (long)devError_vtr_DisConnect, "devError-vtr-DisConnect" },
	{ (long)devError_refrigerator_DisConnect, "devError-refrigerator-DisConnect" },
	{ (long)devError_kRefrigeator_DisConnect, "devError-kRefrigeator-DisConnect" },
	{ (long)devError_Boiler_control, "devError-Boiler-control" },
	{ (long)devError_Boiler_drive, "devError-Boiler-drive" },
	{ (long)devError_Boiler_boiler, "devError-Boiler-boiler" },
	{ (long)devError_Boiler_eeprom, "devError-Boiler-eeprom" },
	{ (long)devGas_notFound_sensor, "devGas-notFound-sensor" },
	{ (long)devError_aroma_catridge1_drive, "devError-aroma-catridge1-drive" },
	{ (long)devError_aroma_catridge2_drive, "devError-aroma-catridge2-drive" },
	{ (long)devError_aroma_catridge3_drive, "devError-aroma-catridge3-drive" },
	{ (long)devStatus_no, "devStatus-no" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__enum_devError2s(struct soap *soap, enum ns__enum_devError n)
{	const char *s = soap_str_code(soap_codes_ns__enum_devError, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__enum_devError(struct soap *soap, const char *tag, int id, const enum ns__enum_devError *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__enum_devError), type);
	soap_send(soap, soap_ns__enum_devError2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns__enum_devError * SOAP_FMAC4 soap_get_ns__enum_devError(struct soap *soap, enum ns__enum_devError *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__enum_devError(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__enum_devError(struct soap *soap, const char *s, enum ns__enum_devError *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns__enum_devError, s);
	if (map)
		*a = (enum ns__enum_devError)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 49)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__enum_devError)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__enum_devError * SOAP_FMAC4 soap_in_ns__enum_devError(struct soap *soap, const char *tag, enum ns__enum_devError *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ns__enum_devError *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__enum_devError, sizeof(enum ns__enum_devError), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__enum_devError(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__enum_devError *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__enum_devError, 0, sizeof(enum ns__enum_devError), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__enum_devInfo(struct soap *soap, enum ns__enum_devInfo *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns__enum_devInfo
	*a = SOAP_DEFAULT_ns__enum_devInfo;
#else
	*a = (enum ns__enum_devInfo)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__enum_devInfo(struct soap *soap, const enum ns__enum_devInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__enum_devInfo);
	if (soap_out_ns__enum_devInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns__enum_devInfo[] =
{	{ (long)_dummy, "dummy" },
	{ (long)_boiler, "boiler" },
	{ (long)_light, "light" },
	{ (long)_gasValve, "gasValve" },
	{ (long)_doorLock, "doorLock" },
	{ (long)_outlet, "outlet" },
	{ (long)_curtain, "curtain" },
	{ (long)_airCleaner, "airCleaner" },
	{ (long)_bide, "bide" },
	{ (long)_aroma, "aroma" },
	{ (long)_rf, "rf" },
	{ (long)_zlplc, "zlplc" },
	{ (long)_bundleLight, "bundleLight" },
	{ (long)_systemAircon, "systemAircon" },
	{ (long)_fanSystem, "fanSystem" },
	{ (long)_aircon, "aircon" },
	{ (long)_washMachine, "washMachine" },
	{ (long)_dishWashMachine, "dishWashMachine" },
	{ (long)_gasOven, "gasOven" },
	{ (long)_microwave, "microwave" },
	{ (long)_television, "television" },
	{ (long)_audio, "audio" },
	{ (long)_vtr, "vtr" },
	{ (long)_dvd, "dvd" },
	{ (long)_refrigerator, "refrigerator" },
	{ (long)_kRefrigeator, "kRefrigeator" },
	{ (long)_sensorEmer, "sensorEmer" },
	{ (long)_exTerminal, "exTerminal" },
	{ (long)_protoCommax, "protoCommax" },
	{ (long)_protoLnCP, "protoLnCP" },
	{ (long)_protoSCUBE, "protoSCUBE" },
	{ (long)_protoZ256, "protoZ256" },
	{ (long)_protoICROSS, "protoICROSS" },
	{ (long)_protoSamsung, "protoSamsung" },
	{ (long)_protoHaMun, "protoHaMun" },
	{ (long)_intfPLC, "intfPLC" },
	{ (long)_intfRF, "intfRF" },
	{ (long)_intfRS485, "intfRS485" },
	{ (long)_intfLAN, "intfLAN" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__enum_devInfo2s(struct soap *soap, enum ns__enum_devInfo n)
{	const char *s = soap_str_code(soap_codes_ns__enum_devInfo, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__enum_devInfo(struct soap *soap, const char *tag, int id, const enum ns__enum_devInfo *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__enum_devInfo), type);
	soap_send(soap, soap_ns__enum_devInfo2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns__enum_devInfo * SOAP_FMAC4 soap_get_ns__enum_devInfo(struct soap *soap, enum ns__enum_devInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__enum_devInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__enum_devInfo(struct soap *soap, const char *s, enum ns__enum_devInfo *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns__enum_devInfo, s);
	if (map)
		*a = (enum ns__enum_devInfo)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 44)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns__enum_devInfo)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__enum_devInfo * SOAP_FMAC4 soap_in_ns__enum_devInfo(struct soap *soap, const char *tag, enum ns__enum_devInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum ns__enum_devInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__enum_devInfo, sizeof(enum ns__enum_devInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns__enum_devInfo(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns__enum_devInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__enum_devInfo, 0, sizeof(enum ns__enum_devInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

void ns__setSensorEmerResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
}

void ns__setSensorEmerResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

int ns__setSensorEmerResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__setSensorEmerResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__setSensorEmerResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__setSensorEmerResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setSensorEmerResponse(struct soap *soap, const char *tag, int id, const ns__setSensorEmerResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__setSensorEmerResponse), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__setSensorEmerResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__setSensorEmerResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__setSensorEmerResponse * SOAP_FMAC4 soap_get_ns__setSensorEmerResponse(struct soap *soap, ns__setSensorEmerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setSensorEmerResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__setSensorEmerResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__setSensorEmerResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__setSensorEmerResponse * SOAP_FMAC4 soap_in_ns__setSensorEmerResponse(struct soap *soap, const char *tag, ns__setSensorEmerResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__setSensorEmerResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__setSensorEmerResponse, sizeof(ns__setSensorEmerResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__setSensorEmerResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__setSensorEmerResponse *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__setSensorEmerResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__setSensorEmerResponse, 0, sizeof(ns__setSensorEmerResponse), 0, soap_copy_ns__setSensorEmerResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__setSensorEmerResponse * SOAP_FMAC6 soap_new_ns__setSensorEmerResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__setSensorEmerResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setSensorEmerResponse(struct soap *soap, ns__setSensorEmerResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__setSensorEmerResponse * SOAP_FMAC4 soap_instantiate_ns__setSensorEmerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setSensorEmerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__setSensorEmerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__setSensorEmerResponse;
		if (size)
			*size = sizeof(ns__setSensorEmerResponse);
	}
	else
	{	cp->ptr = (void*)new ns__setSensorEmerResponse[n];
		if (size)
			*size = n * sizeof(ns__setSensorEmerResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__setSensorEmerResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setSensorEmerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__setSensorEmerResponse %p -> %p\n", q, p));
	*(ns__setSensorEmerResponse*)p = *(ns__setSensorEmerResponse*)q;
}

void ns__getSensorEmerResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getSensorEmerResponse*)this)->_return.soap_serialize(soap);
}

void ns__getSensorEmerResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getSensorEmerResponse*)this)->_return.ns__sensorEmer::soap_default(soap);
}

int ns__getSensorEmerResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__getSensorEmerResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__getSensorEmerResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getSensorEmerResponse(struct soap *soap, const char *tag, int id, const ns__getSensorEmerResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerResponse), type);
	(((ns__getSensorEmerResponse*)a)->_return).soap_out(soap, "return", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__getSensorEmerResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__getSensorEmerResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__getSensorEmerResponse * SOAP_FMAC4 soap_get_ns__getSensorEmerResponse(struct soap *soap, ns__getSensorEmerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getSensorEmerResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__getSensorEmerResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__getSensorEmerResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__getSensorEmerResponse * SOAP_FMAC4 soap_in_ns__getSensorEmerResponse(struct soap *soap, const char *tag, ns__getSensorEmerResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__getSensorEmerResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerResponse, sizeof(ns__getSensorEmerResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__getSensorEmerResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__getSensorEmerResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag__return1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((ns__getSensorEmerResponse*)a)->_return).soap_in(soap, NULL, "ns:sensorEmer"))
				{	soap_flag__return1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__return1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__getSensorEmerResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerResponse, 0, sizeof(ns__getSensorEmerResponse), 0, soap_copy_ns__getSensorEmerResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__getSensorEmerResponse * SOAP_FMAC6 soap_new_ns__getSensorEmerResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getSensorEmerResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getSensorEmerResponse(struct soap *soap, ns__getSensorEmerResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__getSensorEmerResponse * SOAP_FMAC4 soap_instantiate_ns__getSensorEmerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getSensorEmerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__getSensorEmerResponse;
		if (size)
			*size = sizeof(ns__getSensorEmerResponse);
	}
	else
	{	cp->ptr = (void*)new ns__getSensorEmerResponse[n];
		if (size)
			*size = n * sizeof(ns__getSensorEmerResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__getSensorEmerResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getSensorEmerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__getSensorEmerResponse %p -> %p\n", q, p));
	*(ns__getSensorEmerResponse*)p = *(ns__getSensorEmerResponse*)q;
}

void ns__getSensorEmerItemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getSensorEmerItemResponse*)this)->_return.soap_serialize(soap);
}

void ns__getSensorEmerItemResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getSensorEmerItemResponse*)this)->_return.ns__sensorEmer::soap_default(soap);
}

int ns__getSensorEmerItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerItemResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__getSensorEmerItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__getSensorEmerItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getSensorEmerItemResponse(struct soap *soap, const char *tag, int id, const ns__getSensorEmerItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerItemResponse), type);
	(((ns__getSensorEmerItemResponse*)a)->_return).soap_out(soap, "return", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__getSensorEmerItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__getSensorEmerItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__getSensorEmerItemResponse * SOAP_FMAC4 soap_get_ns__getSensorEmerItemResponse(struct soap *soap, ns__getSensorEmerItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getSensorEmerItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__getSensorEmerItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__getSensorEmerItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__getSensorEmerItemResponse * SOAP_FMAC4 soap_in_ns__getSensorEmerItemResponse(struct soap *soap, const char *tag, ns__getSensorEmerItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__getSensorEmerItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerItemResponse, sizeof(ns__getSensorEmerItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__getSensorEmerItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__getSensorEmerItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag__return1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((ns__getSensorEmerItemResponse*)a)->_return).soap_in(soap, NULL, "ns:sensorEmer"))
				{	soap_flag__return1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__return1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__getSensorEmerItemResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerItemResponse, 0, sizeof(ns__getSensorEmerItemResponse), 0, soap_copy_ns__getSensorEmerItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__getSensorEmerItemResponse * SOAP_FMAC6 soap_new_ns__getSensorEmerItemResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getSensorEmerItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getSensorEmerItemResponse(struct soap *soap, ns__getSensorEmerItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__getSensorEmerItemResponse * SOAP_FMAC4 soap_instantiate_ns__getSensorEmerItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getSensorEmerItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__getSensorEmerItemResponse;
		if (size)
			*size = sizeof(ns__getSensorEmerItemResponse);
	}
	else
	{	cp->ptr = (void*)new ns__getSensorEmerItemResponse[n];
		if (size)
			*size = n * sizeof(ns__getSensorEmerItemResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__getSensorEmerItemResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getSensorEmerItemResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__getSensorEmerItemResponse %p -> %p\n", q, p));
	*(ns__getSensorEmerItemResponse*)p = *(ns__getSensorEmerItemResponse*)q;
}

void ns__sensorEmer::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
}

void ns__sensorEmer::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_ns__enum_sensorEmer(soap, &((ns__sensorEmer*)this)->model);
	soap_default_ns__enum_sensorEmer(soap, &((ns__sensorEmer*)this)->seMode);
	soap_default_ns__enum_devError(soap, &((ns__sensorEmer*)this)->seDevError);
	soap_default_ns__sensorEmerFunc(soap, &((ns__sensorEmer*)this)->func);
	soap_default_ns__enum_devInfo(soap, &((ns__rootDevice*)this)->dev);
	soap_default_ns__enum_devInfo(soap, &((ns__rootDevice*)this)->proto);
	soap_default_ns__enum_devInfo(soap, &((ns__rootDevice*)this)->intf);
	soap_default_unsignedInt(soap, &((ns__rootDevice*)this)->order);
}

int ns__sensorEmer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__sensorEmer);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__sensorEmer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__sensorEmer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__sensorEmer(struct soap *soap, const char *tag, int id, const ns__sensorEmer *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__sensorEmer), "ns:sensorEmer");
	soap_out_ns__enum_devInfo(soap, "dev", -1, &(((ns__rootDevice*)a)->dev), "");
	soap_out_ns__enum_devInfo(soap, "proto", -1, &(((ns__rootDevice*)a)->proto), "");
	soap_out_ns__enum_devInfo(soap, "intf", -1, &(((ns__rootDevice*)a)->intf), "");
	soap_out_unsignedInt(soap, "order", -1, &(((ns__rootDevice*)a)->order), "");
	soap_out_ns__enum_sensorEmer(soap, "model", -1, &(((ns__sensorEmer*)a)->model), "");
	soap_out_ns__enum_sensorEmer(soap, "seMode", -1, &(((ns__sensorEmer*)a)->seMode), "");
	soap_out_ns__enum_devError(soap, "seDevError", -1, &(((ns__sensorEmer*)a)->seDevError), "");
	soap_out_ns__sensorEmerFunc(soap, "func", -1, &(((ns__sensorEmer*)a)->func), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__sensorEmer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__sensorEmer(soap, this, tag, type);
}

SOAP_FMAC3 ns__sensorEmer * SOAP_FMAC4 soap_get_ns__sensorEmer(struct soap *soap, ns__sensorEmer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__sensorEmer(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__sensorEmer::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__sensorEmer(soap, tag, this, type);
}

SOAP_FMAC3 ns__sensorEmer * SOAP_FMAC4 soap_in_ns__sensorEmer(struct soap *soap, const char *tag, ns__sensorEmer *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__sensorEmer *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__sensorEmer, sizeof(ns__sensorEmer), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__sensorEmer)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__sensorEmer *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_dev2 = 1, soap_flag_proto2 = 1, soap_flag_intf2 = 1, soap_flag_order2 = 1, soap_flag_model1 = 1, soap_flag_seMode1 = 1, soap_flag_seDevError1 = 1, soap_flag_func1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dev2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devInfo(soap, "dev", &(((ns__rootDevice*)a)->dev), "ns:enum-devInfo"))
				{	soap_flag_dev2--;
					continue;
				}
			if (soap_flag_proto2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devInfo(soap, "proto", &(((ns__rootDevice*)a)->proto), "ns:enum-devInfo"))
				{	soap_flag_proto2--;
					continue;
				}
			if (soap_flag_intf2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devInfo(soap, "intf", &(((ns__rootDevice*)a)->intf), "ns:enum-devInfo"))
				{	soap_flag_intf2--;
					continue;
				}
			if (soap_flag_order2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "order", &(((ns__rootDevice*)a)->order), "xsd:unsignedInt"))
				{	soap_flag_order2--;
					continue;
				}
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_sensorEmer(soap, "model", &(((ns__sensorEmer*)a)->model), "ns:enum-sensorEmer"))
				{	soap_flag_model1--;
					continue;
				}
			if (soap_flag_seMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_sensorEmer(soap, "seMode", &(((ns__sensorEmer*)a)->seMode), "ns:enum-sensorEmer"))
				{	soap_flag_seMode1--;
					continue;
				}
			if (soap_flag_seDevError1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devError(soap, "seDevError", &(((ns__sensorEmer*)a)->seDevError), "ns:enum-devError"))
				{	soap_flag_seDevError1--;
					continue;
				}
			if (soap_flag_func1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__sensorEmerFunc(soap, "func", &(((ns__sensorEmer*)a)->func), "ns:sensorEmerFunc"))
				{	soap_flag_func1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dev2 > 0 || soap_flag_proto2 > 0 || soap_flag_intf2 > 0 || soap_flag_order2 > 0 || soap_flag_model1 > 0 || soap_flag_seMode1 > 0 || soap_flag_seDevError1 > 0 || soap_flag_func1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__sensorEmer *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__sensorEmer, 0, sizeof(ns__sensorEmer), 0, soap_copy_ns__sensorEmer);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__sensorEmer * SOAP_FMAC6 soap_new_ns__sensorEmer(struct soap *soap, int n)
{	return soap_instantiate_ns__sensorEmer(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__sensorEmer(struct soap *soap, ns__sensorEmer *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__sensorEmer * SOAP_FMAC4 soap_instantiate_ns__sensorEmer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__sensorEmer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__sensorEmer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__sensorEmer;
		if (size)
			*size = sizeof(ns__sensorEmer);
	}
	else
	{	cp->ptr = (void*)new ns__sensorEmer[n];
		if (size)
			*size = n * sizeof(ns__sensorEmer);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__sensorEmer*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__sensorEmer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__sensorEmer %p -> %p\n", q, p));
	*(ns__sensorEmer*)p = *(ns__sensorEmer*)q;
}

void ns__setFanSystemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
}

void ns__setFanSystemResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

int ns__setFanSystemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__setFanSystemResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__setFanSystemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__setFanSystemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setFanSystemResponse(struct soap *soap, const char *tag, int id, const ns__setFanSystemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__setFanSystemResponse), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__setFanSystemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__setFanSystemResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__setFanSystemResponse * SOAP_FMAC4 soap_get_ns__setFanSystemResponse(struct soap *soap, ns__setFanSystemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setFanSystemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__setFanSystemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__setFanSystemResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__setFanSystemResponse * SOAP_FMAC4 soap_in_ns__setFanSystemResponse(struct soap *soap, const char *tag, ns__setFanSystemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__setFanSystemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__setFanSystemResponse, sizeof(ns__setFanSystemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__setFanSystemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__setFanSystemResponse *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__setFanSystemResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__setFanSystemResponse, 0, sizeof(ns__setFanSystemResponse), 0, soap_copy_ns__setFanSystemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__setFanSystemResponse * SOAP_FMAC6 soap_new_ns__setFanSystemResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__setFanSystemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setFanSystemResponse(struct soap *soap, ns__setFanSystemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__setFanSystemResponse * SOAP_FMAC4 soap_instantiate_ns__setFanSystemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setFanSystemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__setFanSystemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__setFanSystemResponse;
		if (size)
			*size = sizeof(ns__setFanSystemResponse);
	}
	else
	{	cp->ptr = (void*)new ns__setFanSystemResponse[n];
		if (size)
			*size = n * sizeof(ns__setFanSystemResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__setFanSystemResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setFanSystemResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__setFanSystemResponse %p -> %p\n", q, p));
	*(ns__setFanSystemResponse*)p = *(ns__setFanSystemResponse*)q;
}

void ns__getFanSystemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getFanSystemResponse*)this)->_return.soap_serialize(soap);
}

void ns__getFanSystemResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getFanSystemResponse*)this)->_return.ns__fanSystem::soap_default(soap);
}

int ns__getFanSystemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getFanSystemResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__getFanSystemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__getFanSystemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getFanSystemResponse(struct soap *soap, const char *tag, int id, const ns__getFanSystemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getFanSystemResponse), type);
	(((ns__getFanSystemResponse*)a)->_return).soap_out(soap, "return", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__getFanSystemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__getFanSystemResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__getFanSystemResponse * SOAP_FMAC4 soap_get_ns__getFanSystemResponse(struct soap *soap, ns__getFanSystemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getFanSystemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__getFanSystemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__getFanSystemResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__getFanSystemResponse * SOAP_FMAC4 soap_in_ns__getFanSystemResponse(struct soap *soap, const char *tag, ns__getFanSystemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__getFanSystemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getFanSystemResponse, sizeof(ns__getFanSystemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__getFanSystemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__getFanSystemResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag__return1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((ns__getFanSystemResponse*)a)->_return).soap_in(soap, NULL, "ns:fanSystem"))
				{	soap_flag__return1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__return1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__getFanSystemResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getFanSystemResponse, 0, sizeof(ns__getFanSystemResponse), 0, soap_copy_ns__getFanSystemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__getFanSystemResponse * SOAP_FMAC6 soap_new_ns__getFanSystemResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getFanSystemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getFanSystemResponse(struct soap *soap, ns__getFanSystemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__getFanSystemResponse * SOAP_FMAC4 soap_instantiate_ns__getFanSystemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getFanSystemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getFanSystemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__getFanSystemResponse;
		if (size)
			*size = sizeof(ns__getFanSystemResponse);
	}
	else
	{	cp->ptr = (void*)new ns__getFanSystemResponse[n];
		if (size)
			*size = n * sizeof(ns__getFanSystemResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__getFanSystemResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getFanSystemResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__getFanSystemResponse %p -> %p\n", q, p));
	*(ns__getFanSystemResponse*)p = *(ns__getFanSystemResponse*)q;
}

void ns__getFanSystemItemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getFanSystemItemResponse*)this)->_return.soap_serialize(soap);
}

void ns__getFanSystemItemResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getFanSystemItemResponse*)this)->_return.ns__fanSystem::soap_default(soap);
}

int ns__getFanSystemItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getFanSystemItemResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__getFanSystemItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__getFanSystemItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getFanSystemItemResponse(struct soap *soap, const char *tag, int id, const ns__getFanSystemItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getFanSystemItemResponse), type);
	(((ns__getFanSystemItemResponse*)a)->_return).soap_out(soap, "return", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__getFanSystemItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__getFanSystemItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__getFanSystemItemResponse * SOAP_FMAC4 soap_get_ns__getFanSystemItemResponse(struct soap *soap, ns__getFanSystemItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getFanSystemItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__getFanSystemItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__getFanSystemItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__getFanSystemItemResponse * SOAP_FMAC4 soap_in_ns__getFanSystemItemResponse(struct soap *soap, const char *tag, ns__getFanSystemItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__getFanSystemItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getFanSystemItemResponse, sizeof(ns__getFanSystemItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__getFanSystemItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__getFanSystemItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag__return1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((ns__getFanSystemItemResponse*)a)->_return).soap_in(soap, NULL, "ns:fanSystem"))
				{	soap_flag__return1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__return1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__getFanSystemItemResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getFanSystemItemResponse, 0, sizeof(ns__getFanSystemItemResponse), 0, soap_copy_ns__getFanSystemItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__getFanSystemItemResponse * SOAP_FMAC6 soap_new_ns__getFanSystemItemResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getFanSystemItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getFanSystemItemResponse(struct soap *soap, ns__getFanSystemItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__getFanSystemItemResponse * SOAP_FMAC4 soap_instantiate_ns__getFanSystemItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getFanSystemItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getFanSystemItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__getFanSystemItemResponse;
		if (size)
			*size = sizeof(ns__getFanSystemItemResponse);
	}
	else
	{	cp->ptr = (void*)new ns__getFanSystemItemResponse[n];
		if (size)
			*size = n * sizeof(ns__getFanSystemItemResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__getFanSystemItemResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getFanSystemItemResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__getFanSystemItemResponse %p -> %p\n", q, p));
	*(ns__getFanSystemItemResponse*)p = *(ns__getFanSystemItemResponse*)q;
}

void ns__getFanSystemPropertyItemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getFanSystemPropertyItemResponse*)this)->_return.soap_serialize(soap);
}

void ns__getFanSystemPropertyItemResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getFanSystemPropertyItemResponse*)this)->_return.ns__fanSystem::soap_default(soap);
}

int ns__getFanSystemPropertyItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getFanSystemPropertyItemResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__getFanSystemPropertyItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__getFanSystemPropertyItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getFanSystemPropertyItemResponse(struct soap *soap, const char *tag, int id, const ns__getFanSystemPropertyItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getFanSystemPropertyItemResponse), type);
	(((ns__getFanSystemPropertyItemResponse*)a)->_return).soap_out(soap, "return", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__getFanSystemPropertyItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__getFanSystemPropertyItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__getFanSystemPropertyItemResponse * SOAP_FMAC4 soap_get_ns__getFanSystemPropertyItemResponse(struct soap *soap, ns__getFanSystemPropertyItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getFanSystemPropertyItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__getFanSystemPropertyItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__getFanSystemPropertyItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__getFanSystemPropertyItemResponse * SOAP_FMAC4 soap_in_ns__getFanSystemPropertyItemResponse(struct soap *soap, const char *tag, ns__getFanSystemPropertyItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__getFanSystemPropertyItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getFanSystemPropertyItemResponse, sizeof(ns__getFanSystemPropertyItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__getFanSystemPropertyItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__getFanSystemPropertyItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag__return1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((ns__getFanSystemPropertyItemResponse*)a)->_return).soap_in(soap, NULL, "ns:fanSystem"))
				{	soap_flag__return1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__return1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__getFanSystemPropertyItemResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getFanSystemPropertyItemResponse, 0, sizeof(ns__getFanSystemPropertyItemResponse), 0, soap_copy_ns__getFanSystemPropertyItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__getFanSystemPropertyItemResponse * SOAP_FMAC6 soap_new_ns__getFanSystemPropertyItemResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getFanSystemPropertyItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getFanSystemPropertyItemResponse(struct soap *soap, ns__getFanSystemPropertyItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__getFanSystemPropertyItemResponse * SOAP_FMAC4 soap_instantiate_ns__getFanSystemPropertyItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getFanSystemPropertyItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getFanSystemPropertyItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__getFanSystemPropertyItemResponse;
		if (size)
			*size = sizeof(ns__getFanSystemPropertyItemResponse);
	}
	else
	{	cp->ptr = (void*)new ns__getFanSystemPropertyItemResponse[n];
		if (size)
			*size = n * sizeof(ns__getFanSystemPropertyItemResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__getFanSystemPropertyItemResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getFanSystemPropertyItemResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__getFanSystemPropertyItemResponse %p -> %p\n", q, p));
	*(ns__getFanSystemPropertyItemResponse*)p = *(ns__getFanSystemPropertyItemResponse*)q;
}

void ns__fanSystem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd_fanSystemProperty(soap, &((ns__fanSystem*)this)->devFanSystemProperty);
	soap_embedded(soap, &((ns__fanSystem*)this)->fanReservation_Hour, SOAP_TYPE_cmxDeviceService_int);
	soap_embedded(soap, &((ns__fanSystem*)this)->fanReservation_Minute, SOAP_TYPE_cmxDeviceService_int);
	soap_embedded(soap, &((ns__fanSystem*)this)->fanSystemSt_Temperature, SOAP_TYPE_cmxDeviceService_int);
	soap_embedded(soap, &((ns__fanSystem*)this)->fanSystemSt_CO2_Density_High, SOAP_TYPE_cmxDeviceService_int);
	soap_embedded(soap, &((ns__fanSystem*)this)->fanSystemSt_CO2_Density_Low, SOAP_TYPE_cmxDeviceService_int);
}

void ns__fanSystem::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd_fanSystemProperty(soap, &((ns__fanSystem*)this)->devFanSystemProperty);
	soap_default_ns__enum_fanSystem(soap, &((ns__fanSystem*)this)->model);
	soap_default_ns__enum_fanSystem(soap, &((ns__fanSystem*)this)->fanSystemDo_Power);
	soap_default_ns__enum_fanSystem(soap, &((ns__fanSystem*)this)->fanSystemDo_AutoFan);
	soap_default_ns__enum_fanSystem(soap, &((ns__fanSystem*)this)->fanSystemDo_FanMode);
	soap_default_ns__enum_fanSystem(soap, &((ns__fanSystem*)this)->fanSystemDo_FanWind);
	soap_default_ns__enum_fanSystem(soap, &((ns__fanSystem*)this)->fanSystemDo_FanReservationSet);
	soap_default_ns__enum_fanSystem(soap, &((ns__fanSystem*)this)->fanSystemSt_Power);
	soap_default_ns__enum_fanSystem(soap, &((ns__fanSystem*)this)->fanSystemSt_AutoFan);
	soap_default_ns__enum_fanSystem(soap, &((ns__fanSystem*)this)->fanSystemSt_FanMode);
	soap_default_ns__enum_fanSystem(soap, &((ns__fanSystem*)this)->fanSystemSt_CurrentFanMode);
	soap_default_ns__enum_fanSystem(soap, &((ns__fanSystem*)this)->fanSystemSt_FanWind);
	soap_default_ns__enum_fanSystem(soap, &((ns__fanSystem*)this)->fanSystemSt_FanReservationSet);
	soap_default_ns__enum_fanSystem(soap, &((ns__fanSystem*)this)->fanSystemSt_FanReservationSetMode);
	soap_default_int(soap, &((ns__fanSystem*)this)->fanReservation_Hour);
	soap_default_int(soap, &((ns__fanSystem*)this)->fanReservation_Minute);
	soap_default_ns__enum_fanSystem(soap, &((ns__fanSystem*)this)->fanSystemSt_SensorMode);
	soap_default_ns__enum_fanSystem(soap, &((ns__fanSystem*)this)->fanSystemSt_DamperMode);
	soap_default_ns__enum_fanSystem(soap, &((ns__fanSystem*)this)->fanSystemSt_FilterEmpressMode);
	soap_default_ns__enum_fanSystem(soap, &((ns__fanSystem*)this)->fanSystemSt_AlarmMode);
	soap_default_int(soap, &((ns__fanSystem*)this)->fanSystemSt_Temperature);
	soap_default_ns__enum_fanSystem(soap, &((ns__fanSystem*)this)->fanSystemSt_CO2_DensityMode);
	soap_default_int(soap, &((ns__fanSystem*)this)->fanSystemSt_CO2_Density_High);
	soap_default_int(soap, &((ns__fanSystem*)this)->fanSystemSt_CO2_Density_Low);
	soap_default_ns__enum_fanSystem(soap, &((ns__fanSystem*)this)->fanSystemSt_GAS_Density);
	soap_default_ns__enum_devError(soap, &((ns__fanSystem*)this)->fanSystemDevError);
	soap_default_ns__fanSystemFunc(soap, &((ns__fanSystem*)this)->func);
	soap_default_ns__enum_devInfo(soap, &((ns__rootDevice*)this)->dev);
	soap_default_ns__enum_devInfo(soap, &((ns__rootDevice*)this)->proto);
	soap_default_ns__enum_devInfo(soap, &((ns__rootDevice*)this)->intf);
	soap_default_unsignedInt(soap, &((ns__rootDevice*)this)->order);
}

int ns__fanSystem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__fanSystem);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__fanSystem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__fanSystem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__fanSystem(struct soap *soap, const char *tag, int id, const ns__fanSystem *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__fanSystem), "ns:fanSystem");
	soap_out_ns__enum_devInfo(soap, "dev", -1, &(((ns__rootDevice*)a)->dev), "");
	soap_out_ns__enum_devInfo(soap, "proto", -1, &(((ns__rootDevice*)a)->proto), "");
	soap_out_ns__enum_devInfo(soap, "intf", -1, &(((ns__rootDevice*)a)->intf), "");
	soap_out_unsignedInt(soap, "order", -1, &(((ns__rootDevice*)a)->order), "");
	soap_out_xsd_fanSystemProperty(soap, "devFanSystemProperty", -1, &(((ns__fanSystem*)a)->devFanSystemProperty), "");
	soap_out_ns__enum_fanSystem(soap, "model", -1, &(((ns__fanSystem*)a)->model), "");
	soap_out_ns__enum_fanSystem(soap, "fanSystemDo-Power", -1, &(((ns__fanSystem*)a)->fanSystemDo_Power), "");
	soap_out_ns__enum_fanSystem(soap, "fanSystemDo-AutoFan", -1, &(((ns__fanSystem*)a)->fanSystemDo_AutoFan), "");
	soap_out_ns__enum_fanSystem(soap, "fanSystemDo-FanMode", -1, &(((ns__fanSystem*)a)->fanSystemDo_FanMode), "");
	soap_out_ns__enum_fanSystem(soap, "fanSystemDo-FanWind", -1, &(((ns__fanSystem*)a)->fanSystemDo_FanWind), "");
	soap_out_ns__enum_fanSystem(soap, "fanSystemDo-FanReservationSet", -1, &(((ns__fanSystem*)a)->fanSystemDo_FanReservationSet), "");
	soap_out_ns__enum_fanSystem(soap, "fanSystemSt-Power", -1, &(((ns__fanSystem*)a)->fanSystemSt_Power), "");
	soap_out_ns__enum_fanSystem(soap, "fanSystemSt-AutoFan", -1, &(((ns__fanSystem*)a)->fanSystemSt_AutoFan), "");
	soap_out_ns__enum_fanSystem(soap, "fanSystemSt-FanMode", -1, &(((ns__fanSystem*)a)->fanSystemSt_FanMode), "");
	soap_out_ns__enum_fanSystem(soap, "fanSystemSt-CurrentFanMode", -1, &(((ns__fanSystem*)a)->fanSystemSt_CurrentFanMode), "");
	soap_out_ns__enum_fanSystem(soap, "fanSystemSt-FanWind", -1, &(((ns__fanSystem*)a)->fanSystemSt_FanWind), "");
	soap_out_ns__enum_fanSystem(soap, "fanSystemSt-FanReservationSet", -1, &(((ns__fanSystem*)a)->fanSystemSt_FanReservationSet), "");
	soap_out_ns__enum_fanSystem(soap, "fanSystemSt-FanReservationSetMode", -1, &(((ns__fanSystem*)a)->fanSystemSt_FanReservationSetMode), "");
	soap_out_int(soap, "fanReservation-Hour", -1, &(((ns__fanSystem*)a)->fanReservation_Hour), "");
	soap_out_int(soap, "fanReservation-Minute", -1, &(((ns__fanSystem*)a)->fanReservation_Minute), "");
	soap_out_ns__enum_fanSystem(soap, "fanSystemSt-SensorMode", -1, &(((ns__fanSystem*)a)->fanSystemSt_SensorMode), "");
	soap_out_ns__enum_fanSystem(soap, "fanSystemSt-DamperMode", -1, &(((ns__fanSystem*)a)->fanSystemSt_DamperMode), "");
	soap_out_ns__enum_fanSystem(soap, "fanSystemSt-FilterEmpressMode", -1, &(((ns__fanSystem*)a)->fanSystemSt_FilterEmpressMode), "");
	soap_out_ns__enum_fanSystem(soap, "fanSystemSt-AlarmMode", -1, &(((ns__fanSystem*)a)->fanSystemSt_AlarmMode), "");
	soap_out_int(soap, "fanSystemSt-Temperature", -1, &(((ns__fanSystem*)a)->fanSystemSt_Temperature), "");
	soap_out_ns__enum_fanSystem(soap, "fanSystemSt-CO2-DensityMode", -1, &(((ns__fanSystem*)a)->fanSystemSt_CO2_DensityMode), "");
	soap_out_int(soap, "fanSystemSt-CO2-Density-High", -1, &(((ns__fanSystem*)a)->fanSystemSt_CO2_Density_High), "");
	soap_out_int(soap, "fanSystemSt-CO2-Density-Low", -1, &(((ns__fanSystem*)a)->fanSystemSt_CO2_Density_Low), "");
	soap_out_ns__enum_fanSystem(soap, "fanSystemSt-GAS-Density", -1, &(((ns__fanSystem*)a)->fanSystemSt_GAS_Density), "");
	soap_out_ns__enum_devError(soap, "fanSystemDevError", -1, &(((ns__fanSystem*)a)->fanSystemDevError), "");
	soap_out_ns__fanSystemFunc(soap, "func", -1, &(((ns__fanSystem*)a)->func), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__fanSystem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__fanSystem(soap, this, tag, type);
}

SOAP_FMAC3 ns__fanSystem * SOAP_FMAC4 soap_get_ns__fanSystem(struct soap *soap, ns__fanSystem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__fanSystem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__fanSystem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__fanSystem(soap, tag, this, type);
}

SOAP_FMAC3 ns__fanSystem * SOAP_FMAC4 soap_in_ns__fanSystem(struct soap *soap, const char *tag, ns__fanSystem *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__fanSystem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__fanSystem, sizeof(ns__fanSystem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__fanSystem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__fanSystem *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_dev2 = 1, soap_flag_proto2 = 1, soap_flag_intf2 = 1, soap_flag_order2 = 1, soap_flag_devFanSystemProperty1 = 1, soap_flag_model1 = 1, soap_flag_fanSystemDo_Power1 = 1, soap_flag_fanSystemDo_AutoFan1 = 1, soap_flag_fanSystemDo_FanMode1 = 1, soap_flag_fanSystemDo_FanWind1 = 1, soap_flag_fanSystemDo_FanReservationSet1 = 1, soap_flag_fanSystemSt_Power1 = 1, soap_flag_fanSystemSt_AutoFan1 = 1, soap_flag_fanSystemSt_FanMode1 = 1, soap_flag_fanSystemSt_CurrentFanMode1 = 1, soap_flag_fanSystemSt_FanWind1 = 1, soap_flag_fanSystemSt_FanReservationSet1 = 1, soap_flag_fanSystemSt_FanReservationSetMode1 = 1, soap_flag_fanReservation_Hour1 = 1, soap_flag_fanReservation_Minute1 = 1, soap_flag_fanSystemSt_SensorMode1 = 1, soap_flag_fanSystemSt_DamperMode1 = 1, soap_flag_fanSystemSt_FilterEmpressMode1 = 1, soap_flag_fanSystemSt_AlarmMode1 = 1, soap_flag_fanSystemSt_Temperature1 = 1, soap_flag_fanSystemSt_CO2_DensityMode1 = 1, soap_flag_fanSystemSt_CO2_Density_High1 = 1, soap_flag_fanSystemSt_CO2_Density_Low1 = 1, soap_flag_fanSystemSt_GAS_Density1 = 1, soap_flag_fanSystemDevError1 = 1, soap_flag_func1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dev2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devInfo(soap, "dev", &(((ns__rootDevice*)a)->dev), "ns:enum-devInfo"))
				{	soap_flag_dev2--;
					continue;
				}
			if (soap_flag_proto2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devInfo(soap, "proto", &(((ns__rootDevice*)a)->proto), "ns:enum-devInfo"))
				{	soap_flag_proto2--;
					continue;
				}
			if (soap_flag_intf2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devInfo(soap, "intf", &(((ns__rootDevice*)a)->intf), "ns:enum-devInfo"))
				{	soap_flag_intf2--;
					continue;
				}
			if (soap_flag_order2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "order", &(((ns__rootDevice*)a)->order), "xsd:unsignedInt"))
				{	soap_flag_order2--;
					continue;
				}
			if (soap_flag_devFanSystemProperty1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd_fanSystemProperty(soap, "devFanSystemProperty", &(((ns__fanSystem*)a)->devFanSystemProperty), "xsd-fanSystemProperty"))
				{	soap_flag_devFanSystemProperty1--;
					continue;
				}
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_fanSystem(soap, "model", &(((ns__fanSystem*)a)->model), "ns:enum-fanSystem"))
				{	soap_flag_model1--;
					continue;
				}
			if (soap_flag_fanSystemDo_Power1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_fanSystem(soap, "fanSystemDo-Power", &(((ns__fanSystem*)a)->fanSystemDo_Power), "ns:enum-fanSystem"))
				{	soap_flag_fanSystemDo_Power1--;
					continue;
				}
			if (soap_flag_fanSystemDo_AutoFan1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_fanSystem(soap, "fanSystemDo-AutoFan", &(((ns__fanSystem*)a)->fanSystemDo_AutoFan), "ns:enum-fanSystem"))
				{	soap_flag_fanSystemDo_AutoFan1--;
					continue;
				}
			if (soap_flag_fanSystemDo_FanMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_fanSystem(soap, "fanSystemDo-FanMode", &(((ns__fanSystem*)a)->fanSystemDo_FanMode), "ns:enum-fanSystem"))
				{	soap_flag_fanSystemDo_FanMode1--;
					continue;
				}
			if (soap_flag_fanSystemDo_FanWind1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_fanSystem(soap, "fanSystemDo-FanWind", &(((ns__fanSystem*)a)->fanSystemDo_FanWind), "ns:enum-fanSystem"))
				{	soap_flag_fanSystemDo_FanWind1--;
					continue;
				}
			if (soap_flag_fanSystemDo_FanReservationSet1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_fanSystem(soap, "fanSystemDo-FanReservationSet", &(((ns__fanSystem*)a)->fanSystemDo_FanReservationSet), "ns:enum-fanSystem"))
				{	soap_flag_fanSystemDo_FanReservationSet1--;
					continue;
				}
			if (soap_flag_fanSystemSt_Power1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_fanSystem(soap, "fanSystemSt-Power", &(((ns__fanSystem*)a)->fanSystemSt_Power), "ns:enum-fanSystem"))
				{	soap_flag_fanSystemSt_Power1--;
					continue;
				}
			if (soap_flag_fanSystemSt_AutoFan1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_fanSystem(soap, "fanSystemSt-AutoFan", &(((ns__fanSystem*)a)->fanSystemSt_AutoFan), "ns:enum-fanSystem"))
				{	soap_flag_fanSystemSt_AutoFan1--;
					continue;
				}
			if (soap_flag_fanSystemSt_FanMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_fanSystem(soap, "fanSystemSt-FanMode", &(((ns__fanSystem*)a)->fanSystemSt_FanMode), "ns:enum-fanSystem"))
				{	soap_flag_fanSystemSt_FanMode1--;
					continue;
				}
			if (soap_flag_fanSystemSt_CurrentFanMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_fanSystem(soap, "fanSystemSt-CurrentFanMode", &(((ns__fanSystem*)a)->fanSystemSt_CurrentFanMode), "ns:enum-fanSystem"))
				{	soap_flag_fanSystemSt_CurrentFanMode1--;
					continue;
				}
			if (soap_flag_fanSystemSt_FanWind1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_fanSystem(soap, "fanSystemSt-FanWind", &(((ns__fanSystem*)a)->fanSystemSt_FanWind), "ns:enum-fanSystem"))
				{	soap_flag_fanSystemSt_FanWind1--;
					continue;
				}
			if (soap_flag_fanSystemSt_FanReservationSet1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_fanSystem(soap, "fanSystemSt-FanReservationSet", &(((ns__fanSystem*)a)->fanSystemSt_FanReservationSet), "ns:enum-fanSystem"))
				{	soap_flag_fanSystemSt_FanReservationSet1--;
					continue;
				}
			if (soap_flag_fanSystemSt_FanReservationSetMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_fanSystem(soap, "fanSystemSt-FanReservationSetMode", &(((ns__fanSystem*)a)->fanSystemSt_FanReservationSetMode), "ns:enum-fanSystem"))
				{	soap_flag_fanSystemSt_FanReservationSetMode1--;
					continue;
				}
			if (soap_flag_fanReservation_Hour1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "fanReservation-Hour", &(((ns__fanSystem*)a)->fanReservation_Hour), "xsd:int"))
				{	soap_flag_fanReservation_Hour1--;
					continue;
				}
			if (soap_flag_fanReservation_Minute1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "fanReservation-Minute", &(((ns__fanSystem*)a)->fanReservation_Minute), "xsd:int"))
				{	soap_flag_fanReservation_Minute1--;
					continue;
				}
			if (soap_flag_fanSystemSt_SensorMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_fanSystem(soap, "fanSystemSt-SensorMode", &(((ns__fanSystem*)a)->fanSystemSt_SensorMode), "ns:enum-fanSystem"))
				{	soap_flag_fanSystemSt_SensorMode1--;
					continue;
				}
			if (soap_flag_fanSystemSt_DamperMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_fanSystem(soap, "fanSystemSt-DamperMode", &(((ns__fanSystem*)a)->fanSystemSt_DamperMode), "ns:enum-fanSystem"))
				{	soap_flag_fanSystemSt_DamperMode1--;
					continue;
				}
			if (soap_flag_fanSystemSt_FilterEmpressMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_fanSystem(soap, "fanSystemSt-FilterEmpressMode", &(((ns__fanSystem*)a)->fanSystemSt_FilterEmpressMode), "ns:enum-fanSystem"))
				{	soap_flag_fanSystemSt_FilterEmpressMode1--;
					continue;
				}
			if (soap_flag_fanSystemSt_AlarmMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_fanSystem(soap, "fanSystemSt-AlarmMode", &(((ns__fanSystem*)a)->fanSystemSt_AlarmMode), "ns:enum-fanSystem"))
				{	soap_flag_fanSystemSt_AlarmMode1--;
					continue;
				}
			if (soap_flag_fanSystemSt_Temperature1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "fanSystemSt-Temperature", &(((ns__fanSystem*)a)->fanSystemSt_Temperature), "xsd:int"))
				{	soap_flag_fanSystemSt_Temperature1--;
					continue;
				}
			if (soap_flag_fanSystemSt_CO2_DensityMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_fanSystem(soap, "fanSystemSt-CO2-DensityMode", &(((ns__fanSystem*)a)->fanSystemSt_CO2_DensityMode), "ns:enum-fanSystem"))
				{	soap_flag_fanSystemSt_CO2_DensityMode1--;
					continue;
				}
			if (soap_flag_fanSystemSt_CO2_Density_High1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "fanSystemSt-CO2-Density-High", &(((ns__fanSystem*)a)->fanSystemSt_CO2_Density_High), "xsd:int"))
				{	soap_flag_fanSystemSt_CO2_Density_High1--;
					continue;
				}
			if (soap_flag_fanSystemSt_CO2_Density_Low1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "fanSystemSt-CO2-Density-Low", &(((ns__fanSystem*)a)->fanSystemSt_CO2_Density_Low), "xsd:int"))
				{	soap_flag_fanSystemSt_CO2_Density_Low1--;
					continue;
				}
			if (soap_flag_fanSystemSt_GAS_Density1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_fanSystem(soap, "fanSystemSt-GAS-Density", &(((ns__fanSystem*)a)->fanSystemSt_GAS_Density), "ns:enum-fanSystem"))
				{	soap_flag_fanSystemSt_GAS_Density1--;
					continue;
				}
			if (soap_flag_fanSystemDevError1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devError(soap, "fanSystemDevError", &(((ns__fanSystem*)a)->fanSystemDevError), "ns:enum-devError"))
				{	soap_flag_fanSystemDevError1--;
					continue;
				}
			if (soap_flag_func1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__fanSystemFunc(soap, "func", &(((ns__fanSystem*)a)->func), "ns:fanSystemFunc"))
				{	soap_flag_func1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dev2 > 0 || soap_flag_proto2 > 0 || soap_flag_intf2 > 0 || soap_flag_order2 > 0 || soap_flag_devFanSystemProperty1 > 0 || soap_flag_model1 > 0 || soap_flag_fanSystemDo_Power1 > 0 || soap_flag_fanSystemDo_AutoFan1 > 0 || soap_flag_fanSystemDo_FanMode1 > 0 || soap_flag_fanSystemDo_FanWind1 > 0 || soap_flag_fanSystemDo_FanReservationSet1 > 0 || soap_flag_fanSystemSt_Power1 > 0 || soap_flag_fanSystemSt_AutoFan1 > 0 || soap_flag_fanSystemSt_FanMode1 > 0 || soap_flag_fanSystemSt_CurrentFanMode1 > 0 || soap_flag_fanSystemSt_FanWind1 > 0 || soap_flag_fanSystemSt_FanReservationSet1 > 0 || soap_flag_fanSystemSt_FanReservationSetMode1 > 0 || soap_flag_fanReservation_Hour1 > 0 || soap_flag_fanReservation_Minute1 > 0 || soap_flag_fanSystemSt_SensorMode1 > 0 || soap_flag_fanSystemSt_DamperMode1 > 0 || soap_flag_fanSystemSt_FilterEmpressMode1 > 0 || soap_flag_fanSystemSt_AlarmMode1 > 0 || soap_flag_fanSystemSt_Temperature1 > 0 || soap_flag_fanSystemSt_CO2_DensityMode1 > 0 || soap_flag_fanSystemSt_CO2_Density_High1 > 0 || soap_flag_fanSystemSt_CO2_Density_Low1 > 0 || soap_flag_fanSystemSt_GAS_Density1 > 0 || soap_flag_fanSystemDevError1 > 0 || soap_flag_func1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__fanSystem *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__fanSystem, 0, sizeof(ns__fanSystem), 0, soap_copy_ns__fanSystem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__fanSystem * SOAP_FMAC6 soap_new_ns__fanSystem(struct soap *soap, int n)
{	return soap_instantiate_ns__fanSystem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__fanSystem(struct soap *soap, ns__fanSystem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__fanSystem * SOAP_FMAC4 soap_instantiate_ns__fanSystem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__fanSystem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__fanSystem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__fanSystem;
		if (size)
			*size = sizeof(ns__fanSystem);
	}
	else
	{	cp->ptr = (void*)new ns__fanSystem[n];
		if (size)
			*size = n * sizeof(ns__fanSystem);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__fanSystem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__fanSystem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__fanSystem %p -> %p\n", q, p));
	*(ns__fanSystem*)p = *(ns__fanSystem*)q;
}

void ns__setSystemAirconResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
}

void ns__setSystemAirconResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

int ns__setSystemAirconResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__setSystemAirconResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__setSystemAirconResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__setSystemAirconResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setSystemAirconResponse(struct soap *soap, const char *tag, int id, const ns__setSystemAirconResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__setSystemAirconResponse), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__setSystemAirconResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__setSystemAirconResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__setSystemAirconResponse * SOAP_FMAC4 soap_get_ns__setSystemAirconResponse(struct soap *soap, ns__setSystemAirconResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setSystemAirconResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__setSystemAirconResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__setSystemAirconResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__setSystemAirconResponse * SOAP_FMAC4 soap_in_ns__setSystemAirconResponse(struct soap *soap, const char *tag, ns__setSystemAirconResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__setSystemAirconResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__setSystemAirconResponse, sizeof(ns__setSystemAirconResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__setSystemAirconResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__setSystemAirconResponse *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__setSystemAirconResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__setSystemAirconResponse, 0, sizeof(ns__setSystemAirconResponse), 0, soap_copy_ns__setSystemAirconResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__setSystemAirconResponse * SOAP_FMAC6 soap_new_ns__setSystemAirconResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__setSystemAirconResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setSystemAirconResponse(struct soap *soap, ns__setSystemAirconResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__setSystemAirconResponse * SOAP_FMAC4 soap_instantiate_ns__setSystemAirconResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setSystemAirconResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__setSystemAirconResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__setSystemAirconResponse;
		if (size)
			*size = sizeof(ns__setSystemAirconResponse);
	}
	else
	{	cp->ptr = (void*)new ns__setSystemAirconResponse[n];
		if (size)
			*size = n * sizeof(ns__setSystemAirconResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__setSystemAirconResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setSystemAirconResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__setSystemAirconResponse %p -> %p\n", q, p));
	*(ns__setSystemAirconResponse*)p = *(ns__setSystemAirconResponse*)q;
}

void ns__getSystemAirconResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getSystemAirconResponse*)this)->_return.soap_serialize(soap);
}

void ns__getSystemAirconResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getSystemAirconResponse*)this)->_return.ns__systemAircon::soap_default(soap);
}

int ns__getSystemAirconResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__getSystemAirconResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__getSystemAirconResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getSystemAirconResponse(struct soap *soap, const char *tag, int id, const ns__getSystemAirconResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconResponse), type);
	(((ns__getSystemAirconResponse*)a)->_return).soap_out(soap, "return", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__getSystemAirconResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__getSystemAirconResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__getSystemAirconResponse * SOAP_FMAC4 soap_get_ns__getSystemAirconResponse(struct soap *soap, ns__getSystemAirconResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getSystemAirconResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__getSystemAirconResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__getSystemAirconResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__getSystemAirconResponse * SOAP_FMAC4 soap_in_ns__getSystemAirconResponse(struct soap *soap, const char *tag, ns__getSystemAirconResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__getSystemAirconResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconResponse, sizeof(ns__getSystemAirconResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__getSystemAirconResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__getSystemAirconResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag__return1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((ns__getSystemAirconResponse*)a)->_return).soap_in(soap, NULL, "ns:systemAircon"))
				{	soap_flag__return1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__return1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__getSystemAirconResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconResponse, 0, sizeof(ns__getSystemAirconResponse), 0, soap_copy_ns__getSystemAirconResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__getSystemAirconResponse * SOAP_FMAC6 soap_new_ns__getSystemAirconResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getSystemAirconResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getSystemAirconResponse(struct soap *soap, ns__getSystemAirconResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__getSystemAirconResponse * SOAP_FMAC4 soap_instantiate_ns__getSystemAirconResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getSystemAirconResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__getSystemAirconResponse;
		if (size)
			*size = sizeof(ns__getSystemAirconResponse);
	}
	else
	{	cp->ptr = (void*)new ns__getSystemAirconResponse[n];
		if (size)
			*size = n * sizeof(ns__getSystemAirconResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__getSystemAirconResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getSystemAirconResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__getSystemAirconResponse %p -> %p\n", q, p));
	*(ns__getSystemAirconResponse*)p = *(ns__getSystemAirconResponse*)q;
}

void ns__getSystemAirconItemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getSystemAirconItemResponse*)this)->_return.soap_serialize(soap);
}

void ns__getSystemAirconItemResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getSystemAirconItemResponse*)this)->_return.ns__systemAircon::soap_default(soap);
}

int ns__getSystemAirconItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconItemResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__getSystemAirconItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__getSystemAirconItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getSystemAirconItemResponse(struct soap *soap, const char *tag, int id, const ns__getSystemAirconItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconItemResponse), type);
	(((ns__getSystemAirconItemResponse*)a)->_return).soap_out(soap, "return", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__getSystemAirconItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__getSystemAirconItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__getSystemAirconItemResponse * SOAP_FMAC4 soap_get_ns__getSystemAirconItemResponse(struct soap *soap, ns__getSystemAirconItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getSystemAirconItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__getSystemAirconItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__getSystemAirconItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__getSystemAirconItemResponse * SOAP_FMAC4 soap_in_ns__getSystemAirconItemResponse(struct soap *soap, const char *tag, ns__getSystemAirconItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__getSystemAirconItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconItemResponse, sizeof(ns__getSystemAirconItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__getSystemAirconItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__getSystemAirconItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag__return1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((ns__getSystemAirconItemResponse*)a)->_return).soap_in(soap, NULL, "ns:systemAircon"))
				{	soap_flag__return1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__return1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__getSystemAirconItemResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconItemResponse, 0, sizeof(ns__getSystemAirconItemResponse), 0, soap_copy_ns__getSystemAirconItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__getSystemAirconItemResponse * SOAP_FMAC6 soap_new_ns__getSystemAirconItemResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getSystemAirconItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getSystemAirconItemResponse(struct soap *soap, ns__getSystemAirconItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__getSystemAirconItemResponse * SOAP_FMAC4 soap_instantiate_ns__getSystemAirconItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getSystemAirconItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__getSystemAirconItemResponse;
		if (size)
			*size = sizeof(ns__getSystemAirconItemResponse);
	}
	else
	{	cp->ptr = (void*)new ns__getSystemAirconItemResponse[n];
		if (size)
			*size = n * sizeof(ns__getSystemAirconItemResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__getSystemAirconItemResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getSystemAirconItemResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__getSystemAirconItemResponse %p -> %p\n", q, p));
	*(ns__getSystemAirconItemResponse*)p = *(ns__getSystemAirconItemResponse*)q;
}

void ns__getSystemAirconPropertyItemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getSystemAirconPropertyItemResponse*)this)->_return.soap_serialize(soap);
}

void ns__getSystemAirconPropertyItemResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getSystemAirconPropertyItemResponse*)this)->_return.ns__systemAircon::soap_default(soap);
}

int ns__getSystemAirconPropertyItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconPropertyItemResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__getSystemAirconPropertyItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__getSystemAirconPropertyItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getSystemAirconPropertyItemResponse(struct soap *soap, const char *tag, int id, const ns__getSystemAirconPropertyItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconPropertyItemResponse), type);
	(((ns__getSystemAirconPropertyItemResponse*)a)->_return).soap_out(soap, "return", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__getSystemAirconPropertyItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__getSystemAirconPropertyItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__getSystemAirconPropertyItemResponse * SOAP_FMAC4 soap_get_ns__getSystemAirconPropertyItemResponse(struct soap *soap, ns__getSystemAirconPropertyItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getSystemAirconPropertyItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__getSystemAirconPropertyItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__getSystemAirconPropertyItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__getSystemAirconPropertyItemResponse * SOAP_FMAC4 soap_in_ns__getSystemAirconPropertyItemResponse(struct soap *soap, const char *tag, ns__getSystemAirconPropertyItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__getSystemAirconPropertyItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconPropertyItemResponse, sizeof(ns__getSystemAirconPropertyItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__getSystemAirconPropertyItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__getSystemAirconPropertyItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag__return1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((ns__getSystemAirconPropertyItemResponse*)a)->_return).soap_in(soap, NULL, "ns:systemAircon"))
				{	soap_flag__return1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__return1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__getSystemAirconPropertyItemResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconPropertyItemResponse, 0, sizeof(ns__getSystemAirconPropertyItemResponse), 0, soap_copy_ns__getSystemAirconPropertyItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__getSystemAirconPropertyItemResponse * SOAP_FMAC6 soap_new_ns__getSystemAirconPropertyItemResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getSystemAirconPropertyItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getSystemAirconPropertyItemResponse(struct soap *soap, ns__getSystemAirconPropertyItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__getSystemAirconPropertyItemResponse * SOAP_FMAC4 soap_instantiate_ns__getSystemAirconPropertyItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getSystemAirconPropertyItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconPropertyItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__getSystemAirconPropertyItemResponse;
		if (size)
			*size = sizeof(ns__getSystemAirconPropertyItemResponse);
	}
	else
	{	cp->ptr = (void*)new ns__getSystemAirconPropertyItemResponse[n];
		if (size)
			*size = n * sizeof(ns__getSystemAirconPropertyItemResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__getSystemAirconPropertyItemResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getSystemAirconPropertyItemResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__getSystemAirconPropertyItemResponse %p -> %p\n", q, p));
	*(ns__getSystemAirconPropertyItemResponse*)p = *(ns__getSystemAirconPropertyItemResponse*)q;
}

void ns__systemAircon::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd_systemAirconProperty(soap, &((ns__systemAircon*)this)->devsystemAirconProperty);
	soap_embedded(soap, &((ns__systemAircon*)this)->systemAirconDo_Temperature_Set, SOAP_TYPE_cmxDeviceService_int);
	soap_embedded(soap, &((ns__systemAircon*)this)->systemAirconSt_Temperature_Set, SOAP_TYPE_cmxDeviceService_int);
	soap_embedded(soap, &((ns__systemAircon*)this)->systemAirconSt_Temperature_Current, SOAP_TYPE_cmxDeviceService_int);
}

void ns__systemAircon::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd_systemAirconProperty(soap, &((ns__systemAircon*)this)->devsystemAirconProperty);
	soap_default_ns__enum_systemAircon(soap, &((ns__systemAircon*)this)->model);
	soap_default_ns__enum_systemAircon(soap, &((ns__systemAircon*)this)->systemAirconDo_Power);
	soap_default_ns__enum_systemAircon(soap, &((ns__systemAircon*)this)->systemAirconDo_WindDirection);
	soap_default_ns__enum_systemAircon(soap, &((ns__systemAircon*)this)->systemAirconDo_WindPower);
	soap_default_ns__enum_systemAircon(soap, &((ns__systemAircon*)this)->systemAirconDo_Drive);
	soap_default_ns__enum_systemAircon(soap, &((ns__systemAircon*)this)->systemAirconDo_StatusQuery);
	soap_default_ns__enum_systemAircon(soap, &((ns__systemAircon*)this)->systemAirconSt_Power);
	soap_default_ns__enum_systemAircon(soap, &((ns__systemAircon*)this)->systemAirconSt_WindDirection);
	soap_default_ns__enum_systemAircon(soap, &((ns__systemAircon*)this)->systemAirconSt_WindPower);
	soap_default_ns__enum_systemAircon(soap, &((ns__systemAircon*)this)->systemAirconSt_Drive);
	soap_default_ns__enum_systemAircon(soap, &((ns__systemAircon*)this)->systemAirconSt_Tracking);
	soap_default_ns__enum_systemAircon(soap, &((ns__systemAircon*)this)->systemAirconSt_Installation);
	soap_default_ns__enum_systemAircon(soap, &((ns__systemAircon*)this)->systemAirconSt_InnerRoom_Error);
	soap_default_ns__enum_systemAircon(soap, &((ns__systemAircon*)this)->systemAirconSt_OutRoom_Error);
	soap_default_int(soap, &((ns__systemAircon*)this)->systemAirconDo_Temperature_Set);
	soap_default_int(soap, &((ns__systemAircon*)this)->systemAirconSt_Temperature_Set);
	soap_default_int(soap, &((ns__systemAircon*)this)->systemAirconSt_Temperature_Current);
	soap_default_ns__enum_devError(soap, &((ns__systemAircon*)this)->systemAirconDevError);
	soap_default_ns__systemAirconFunc(soap, &((ns__systemAircon*)this)->func);
	soap_default_ns__enum_devInfo(soap, &((ns__rootDevice*)this)->dev);
	soap_default_ns__enum_devInfo(soap, &((ns__rootDevice*)this)->proto);
	soap_default_ns__enum_devInfo(soap, &((ns__rootDevice*)this)->intf);
	soap_default_unsignedInt(soap, &((ns__rootDevice*)this)->order);
}

int ns__systemAircon::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__systemAircon);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__systemAircon::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__systemAircon(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__systemAircon(struct soap *soap, const char *tag, int id, const ns__systemAircon *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__systemAircon), "ns:systemAircon");
	soap_out_ns__enum_devInfo(soap, "dev", -1, &(((ns__rootDevice*)a)->dev), "");
	soap_out_ns__enum_devInfo(soap, "proto", -1, &(((ns__rootDevice*)a)->proto), "");
	soap_out_ns__enum_devInfo(soap, "intf", -1, &(((ns__rootDevice*)a)->intf), "");
	soap_out_unsignedInt(soap, "order", -1, &(((ns__rootDevice*)a)->order), "");
	soap_out_xsd_systemAirconProperty(soap, "devsystemAirconProperty", -1, &(((ns__systemAircon*)a)->devsystemAirconProperty), "");
	soap_out_ns__enum_systemAircon(soap, "model", -1, &(((ns__systemAircon*)a)->model), "");
	soap_out_ns__enum_systemAircon(soap, "systemAirconDo-Power", -1, &(((ns__systemAircon*)a)->systemAirconDo_Power), "");
	soap_out_ns__enum_systemAircon(soap, "systemAirconDo-WindDirection", -1, &(((ns__systemAircon*)a)->systemAirconDo_WindDirection), "");
	soap_out_ns__enum_systemAircon(soap, "systemAirconDo-WindPower", -1, &(((ns__systemAircon*)a)->systemAirconDo_WindPower), "");
	soap_out_ns__enum_systemAircon(soap, "systemAirconDo-Drive", -1, &(((ns__systemAircon*)a)->systemAirconDo_Drive), "");
	soap_out_ns__enum_systemAircon(soap, "systemAirconDo-StatusQuery", -1, &(((ns__systemAircon*)a)->systemAirconDo_StatusQuery), "");
	soap_out_ns__enum_systemAircon(soap, "systemAirconSt-Power", -1, &(((ns__systemAircon*)a)->systemAirconSt_Power), "");
	soap_out_ns__enum_systemAircon(soap, "systemAirconSt-WindDirection", -1, &(((ns__systemAircon*)a)->systemAirconSt_WindDirection), "");
	soap_out_ns__enum_systemAircon(soap, "systemAirconSt-WindPower", -1, &(((ns__systemAircon*)a)->systemAirconSt_WindPower), "");
	soap_out_ns__enum_systemAircon(soap, "systemAirconSt-Drive", -1, &(((ns__systemAircon*)a)->systemAirconSt_Drive), "");
	soap_out_ns__enum_systemAircon(soap, "systemAirconSt-Tracking", -1, &(((ns__systemAircon*)a)->systemAirconSt_Tracking), "");
	soap_out_ns__enum_systemAircon(soap, "systemAirconSt-Installation", -1, &(((ns__systemAircon*)a)->systemAirconSt_Installation), "");
	soap_out_ns__enum_systemAircon(soap, "systemAirconSt-InnerRoom-Error", -1, &(((ns__systemAircon*)a)->systemAirconSt_InnerRoom_Error), "");
	soap_out_ns__enum_systemAircon(soap, "systemAirconSt-OutRoom-Error", -1, &(((ns__systemAircon*)a)->systemAirconSt_OutRoom_Error), "");
	soap_out_int(soap, "systemAirconDo-Temperature-Set", -1, &(((ns__systemAircon*)a)->systemAirconDo_Temperature_Set), "");
	soap_out_int(soap, "systemAirconSt-Temperature-Set", -1, &(((ns__systemAircon*)a)->systemAirconSt_Temperature_Set), "");
	soap_out_int(soap, "systemAirconSt-Temperature-Current", -1, &(((ns__systemAircon*)a)->systemAirconSt_Temperature_Current), "");
	soap_out_ns__enum_devError(soap, "systemAirconDevError", -1, &(((ns__systemAircon*)a)->systemAirconDevError), "");
	soap_out_ns__systemAirconFunc(soap, "func", -1, &(((ns__systemAircon*)a)->func), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__systemAircon::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__systemAircon(soap, this, tag, type);
}

SOAP_FMAC3 ns__systemAircon * SOAP_FMAC4 soap_get_ns__systemAircon(struct soap *soap, ns__systemAircon *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__systemAircon(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__systemAircon::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__systemAircon(soap, tag, this, type);
}

SOAP_FMAC3 ns__systemAircon * SOAP_FMAC4 soap_in_ns__systemAircon(struct soap *soap, const char *tag, ns__systemAircon *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__systemAircon *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__systemAircon, sizeof(ns__systemAircon), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__systemAircon)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__systemAircon *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_dev2 = 1, soap_flag_proto2 = 1, soap_flag_intf2 = 1, soap_flag_order2 = 1, soap_flag_devsystemAirconProperty1 = 1, soap_flag_model1 = 1, soap_flag_systemAirconDo_Power1 = 1, soap_flag_systemAirconDo_WindDirection1 = 1, soap_flag_systemAirconDo_WindPower1 = 1, soap_flag_systemAirconDo_Drive1 = 1, soap_flag_systemAirconDo_StatusQuery1 = 1, soap_flag_systemAirconSt_Power1 = 1, soap_flag_systemAirconSt_WindDirection1 = 1, soap_flag_systemAirconSt_WindPower1 = 1, soap_flag_systemAirconSt_Drive1 = 1, soap_flag_systemAirconSt_Tracking1 = 1, soap_flag_systemAirconSt_Installation1 = 1, soap_flag_systemAirconSt_InnerRoom_Error1 = 1, soap_flag_systemAirconSt_OutRoom_Error1 = 1, soap_flag_systemAirconDo_Temperature_Set1 = 1, soap_flag_systemAirconSt_Temperature_Set1 = 1, soap_flag_systemAirconSt_Temperature_Current1 = 1, soap_flag_systemAirconDevError1 = 1, soap_flag_func1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dev2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devInfo(soap, "dev", &(((ns__rootDevice*)a)->dev), "ns:enum-devInfo"))
				{	soap_flag_dev2--;
					continue;
				}
			if (soap_flag_proto2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devInfo(soap, "proto", &(((ns__rootDevice*)a)->proto), "ns:enum-devInfo"))
				{	soap_flag_proto2--;
					continue;
				}
			if (soap_flag_intf2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devInfo(soap, "intf", &(((ns__rootDevice*)a)->intf), "ns:enum-devInfo"))
				{	soap_flag_intf2--;
					continue;
				}
			if (soap_flag_order2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "order", &(((ns__rootDevice*)a)->order), "xsd:unsignedInt"))
				{	soap_flag_order2--;
					continue;
				}
			if (soap_flag_devsystemAirconProperty1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd_systemAirconProperty(soap, "devsystemAirconProperty", &(((ns__systemAircon*)a)->devsystemAirconProperty), "xsd-systemAirconProperty"))
				{	soap_flag_devsystemAirconProperty1--;
					continue;
				}
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_systemAircon(soap, "model", &(((ns__systemAircon*)a)->model), "ns:enum-systemAircon"))
				{	soap_flag_model1--;
					continue;
				}
			if (soap_flag_systemAirconDo_Power1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_systemAircon(soap, "systemAirconDo-Power", &(((ns__systemAircon*)a)->systemAirconDo_Power), "ns:enum-systemAircon"))
				{	soap_flag_systemAirconDo_Power1--;
					continue;
				}
			if (soap_flag_systemAirconDo_WindDirection1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_systemAircon(soap, "systemAirconDo-WindDirection", &(((ns__systemAircon*)a)->systemAirconDo_WindDirection), "ns:enum-systemAircon"))
				{	soap_flag_systemAirconDo_WindDirection1--;
					continue;
				}
			if (soap_flag_systemAirconDo_WindPower1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_systemAircon(soap, "systemAirconDo-WindPower", &(((ns__systemAircon*)a)->systemAirconDo_WindPower), "ns:enum-systemAircon"))
				{	soap_flag_systemAirconDo_WindPower1--;
					continue;
				}
			if (soap_flag_systemAirconDo_Drive1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_systemAircon(soap, "systemAirconDo-Drive", &(((ns__systemAircon*)a)->systemAirconDo_Drive), "ns:enum-systemAircon"))
				{	soap_flag_systemAirconDo_Drive1--;
					continue;
				}
			if (soap_flag_systemAirconDo_StatusQuery1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_systemAircon(soap, "systemAirconDo-StatusQuery", &(((ns__systemAircon*)a)->systemAirconDo_StatusQuery), "ns:enum-systemAircon"))
				{	soap_flag_systemAirconDo_StatusQuery1--;
					continue;
				}
			if (soap_flag_systemAirconSt_Power1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_systemAircon(soap, "systemAirconSt-Power", &(((ns__systemAircon*)a)->systemAirconSt_Power), "ns:enum-systemAircon"))
				{	soap_flag_systemAirconSt_Power1--;
					continue;
				}
			if (soap_flag_systemAirconSt_WindDirection1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_systemAircon(soap, "systemAirconSt-WindDirection", &(((ns__systemAircon*)a)->systemAirconSt_WindDirection), "ns:enum-systemAircon"))
				{	soap_flag_systemAirconSt_WindDirection1--;
					continue;
				}
			if (soap_flag_systemAirconSt_WindPower1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_systemAircon(soap, "systemAirconSt-WindPower", &(((ns__systemAircon*)a)->systemAirconSt_WindPower), "ns:enum-systemAircon"))
				{	soap_flag_systemAirconSt_WindPower1--;
					continue;
				}
			if (soap_flag_systemAirconSt_Drive1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_systemAircon(soap, "systemAirconSt-Drive", &(((ns__systemAircon*)a)->systemAirconSt_Drive), "ns:enum-systemAircon"))
				{	soap_flag_systemAirconSt_Drive1--;
					continue;
				}
			if (soap_flag_systemAirconSt_Tracking1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_systemAircon(soap, "systemAirconSt-Tracking", &(((ns__systemAircon*)a)->systemAirconSt_Tracking), "ns:enum-systemAircon"))
				{	soap_flag_systemAirconSt_Tracking1--;
					continue;
				}
			if (soap_flag_systemAirconSt_Installation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_systemAircon(soap, "systemAirconSt-Installation", &(((ns__systemAircon*)a)->systemAirconSt_Installation), "ns:enum-systemAircon"))
				{	soap_flag_systemAirconSt_Installation1--;
					continue;
				}
			if (soap_flag_systemAirconSt_InnerRoom_Error1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_systemAircon(soap, "systemAirconSt-InnerRoom-Error", &(((ns__systemAircon*)a)->systemAirconSt_InnerRoom_Error), "ns:enum-systemAircon"))
				{	soap_flag_systemAirconSt_InnerRoom_Error1--;
					continue;
				}
			if (soap_flag_systemAirconSt_OutRoom_Error1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_systemAircon(soap, "systemAirconSt-OutRoom-Error", &(((ns__systemAircon*)a)->systemAirconSt_OutRoom_Error), "ns:enum-systemAircon"))
				{	soap_flag_systemAirconSt_OutRoom_Error1--;
					continue;
				}
			if (soap_flag_systemAirconDo_Temperature_Set1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "systemAirconDo-Temperature-Set", &(((ns__systemAircon*)a)->systemAirconDo_Temperature_Set), "xsd:int"))
				{	soap_flag_systemAirconDo_Temperature_Set1--;
					continue;
				}
			if (soap_flag_systemAirconSt_Temperature_Set1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "systemAirconSt-Temperature-Set", &(((ns__systemAircon*)a)->systemAirconSt_Temperature_Set), "xsd:int"))
				{	soap_flag_systemAirconSt_Temperature_Set1--;
					continue;
				}
			if (soap_flag_systemAirconSt_Temperature_Current1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "systemAirconSt-Temperature-Current", &(((ns__systemAircon*)a)->systemAirconSt_Temperature_Current), "xsd:int"))
				{	soap_flag_systemAirconSt_Temperature_Current1--;
					continue;
				}
			if (soap_flag_systemAirconDevError1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devError(soap, "systemAirconDevError", &(((ns__systemAircon*)a)->systemAirconDevError), "ns:enum-devError"))
				{	soap_flag_systemAirconDevError1--;
					continue;
				}
			if (soap_flag_func1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__systemAirconFunc(soap, "func", &(((ns__systemAircon*)a)->func), "ns:systemAirconFunc"))
				{	soap_flag_func1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dev2 > 0 || soap_flag_proto2 > 0 || soap_flag_intf2 > 0 || soap_flag_order2 > 0 || soap_flag_devsystemAirconProperty1 > 0 || soap_flag_model1 > 0 || soap_flag_systemAirconDo_Power1 > 0 || soap_flag_systemAirconDo_WindDirection1 > 0 || soap_flag_systemAirconDo_WindPower1 > 0 || soap_flag_systemAirconDo_Drive1 > 0 || soap_flag_systemAirconDo_StatusQuery1 > 0 || soap_flag_systemAirconSt_Power1 > 0 || soap_flag_systemAirconSt_WindDirection1 > 0 || soap_flag_systemAirconSt_WindPower1 > 0 || soap_flag_systemAirconSt_Drive1 > 0 || soap_flag_systemAirconSt_Tracking1 > 0 || soap_flag_systemAirconSt_Installation1 > 0 || soap_flag_systemAirconSt_InnerRoom_Error1 > 0 || soap_flag_systemAirconSt_OutRoom_Error1 > 0 || soap_flag_systemAirconDo_Temperature_Set1 > 0 || soap_flag_systemAirconSt_Temperature_Set1 > 0 || soap_flag_systemAirconSt_Temperature_Current1 > 0 || soap_flag_systemAirconDevError1 > 0 || soap_flag_func1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__systemAircon *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__systemAircon, 0, sizeof(ns__systemAircon), 0, soap_copy_ns__systemAircon);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__systemAircon * SOAP_FMAC6 soap_new_ns__systemAircon(struct soap *soap, int n)
{	return soap_instantiate_ns__systemAircon(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__systemAircon(struct soap *soap, ns__systemAircon *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__systemAircon * SOAP_FMAC4 soap_instantiate_ns__systemAircon(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__systemAircon(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__systemAircon, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__systemAircon;
		if (size)
			*size = sizeof(ns__systemAircon);
	}
	else
	{	cp->ptr = (void*)new ns__systemAircon[n];
		if (size)
			*size = n * sizeof(ns__systemAircon);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__systemAircon*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__systemAircon(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__systemAircon %p -> %p\n", q, p));
	*(ns__systemAircon*)p = *(ns__systemAircon*)q;
}

void ns__setBundleLightResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
}

void ns__setBundleLightResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

int ns__setBundleLightResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__setBundleLightResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__setBundleLightResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__setBundleLightResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setBundleLightResponse(struct soap *soap, const char *tag, int id, const ns__setBundleLightResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__setBundleLightResponse), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__setBundleLightResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__setBundleLightResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__setBundleLightResponse * SOAP_FMAC4 soap_get_ns__setBundleLightResponse(struct soap *soap, ns__setBundleLightResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setBundleLightResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__setBundleLightResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__setBundleLightResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__setBundleLightResponse * SOAP_FMAC4 soap_in_ns__setBundleLightResponse(struct soap *soap, const char *tag, ns__setBundleLightResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__setBundleLightResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__setBundleLightResponse, sizeof(ns__setBundleLightResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__setBundleLightResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__setBundleLightResponse *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__setBundleLightResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__setBundleLightResponse, 0, sizeof(ns__setBundleLightResponse), 0, soap_copy_ns__setBundleLightResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__setBundleLightResponse * SOAP_FMAC6 soap_new_ns__setBundleLightResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__setBundleLightResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setBundleLightResponse(struct soap *soap, ns__setBundleLightResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__setBundleLightResponse * SOAP_FMAC4 soap_instantiate_ns__setBundleLightResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setBundleLightResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__setBundleLightResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__setBundleLightResponse;
		if (size)
			*size = sizeof(ns__setBundleLightResponse);
	}
	else
	{	cp->ptr = (void*)new ns__setBundleLightResponse[n];
		if (size)
			*size = n * sizeof(ns__setBundleLightResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__setBundleLightResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setBundleLightResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__setBundleLightResponse %p -> %p\n", q, p));
	*(ns__setBundleLightResponse*)p = *(ns__setBundleLightResponse*)q;
}

void ns__getBundleLightResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getBundleLightResponse*)this)->_return.soap_serialize(soap);
}

void ns__getBundleLightResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getBundleLightResponse*)this)->_return.ns__bundleLight::soap_default(soap);
}

int ns__getBundleLightResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getBundleLightResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__getBundleLightResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__getBundleLightResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getBundleLightResponse(struct soap *soap, const char *tag, int id, const ns__getBundleLightResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getBundleLightResponse), type);
	(((ns__getBundleLightResponse*)a)->_return).soap_out(soap, "return", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__getBundleLightResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__getBundleLightResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__getBundleLightResponse * SOAP_FMAC4 soap_get_ns__getBundleLightResponse(struct soap *soap, ns__getBundleLightResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getBundleLightResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__getBundleLightResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__getBundleLightResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__getBundleLightResponse * SOAP_FMAC4 soap_in_ns__getBundleLightResponse(struct soap *soap, const char *tag, ns__getBundleLightResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__getBundleLightResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getBundleLightResponse, sizeof(ns__getBundleLightResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__getBundleLightResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__getBundleLightResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag__return1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((ns__getBundleLightResponse*)a)->_return).soap_in(soap, NULL, "ns:bundleLight"))
				{	soap_flag__return1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__return1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__getBundleLightResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getBundleLightResponse, 0, sizeof(ns__getBundleLightResponse), 0, soap_copy_ns__getBundleLightResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__getBundleLightResponse * SOAP_FMAC6 soap_new_ns__getBundleLightResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getBundleLightResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getBundleLightResponse(struct soap *soap, ns__getBundleLightResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__getBundleLightResponse * SOAP_FMAC4 soap_instantiate_ns__getBundleLightResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getBundleLightResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getBundleLightResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__getBundleLightResponse;
		if (size)
			*size = sizeof(ns__getBundleLightResponse);
	}
	else
	{	cp->ptr = (void*)new ns__getBundleLightResponse[n];
		if (size)
			*size = n * sizeof(ns__getBundleLightResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__getBundleLightResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getBundleLightResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__getBundleLightResponse %p -> %p\n", q, p));
	*(ns__getBundleLightResponse*)p = *(ns__getBundleLightResponse*)q;
}

void ns__getBundleLightItemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getBundleLightItemResponse*)this)->_return.soap_serialize(soap);
}

void ns__getBundleLightItemResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getBundleLightItemResponse*)this)->_return.ns__bundleLight::soap_default(soap);
}

int ns__getBundleLightItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getBundleLightItemResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__getBundleLightItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__getBundleLightItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getBundleLightItemResponse(struct soap *soap, const char *tag, int id, const ns__getBundleLightItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getBundleLightItemResponse), type);
	(((ns__getBundleLightItemResponse*)a)->_return).soap_out(soap, "return", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__getBundleLightItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__getBundleLightItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__getBundleLightItemResponse * SOAP_FMAC4 soap_get_ns__getBundleLightItemResponse(struct soap *soap, ns__getBundleLightItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getBundleLightItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__getBundleLightItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__getBundleLightItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__getBundleLightItemResponse * SOAP_FMAC4 soap_in_ns__getBundleLightItemResponse(struct soap *soap, const char *tag, ns__getBundleLightItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__getBundleLightItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getBundleLightItemResponse, sizeof(ns__getBundleLightItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__getBundleLightItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__getBundleLightItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag__return1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((ns__getBundleLightItemResponse*)a)->_return).soap_in(soap, NULL, "ns:bundleLight"))
				{	soap_flag__return1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__return1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__getBundleLightItemResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getBundleLightItemResponse, 0, sizeof(ns__getBundleLightItemResponse), 0, soap_copy_ns__getBundleLightItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__getBundleLightItemResponse * SOAP_FMAC6 soap_new_ns__getBundleLightItemResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getBundleLightItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getBundleLightItemResponse(struct soap *soap, ns__getBundleLightItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__getBundleLightItemResponse * SOAP_FMAC4 soap_instantiate_ns__getBundleLightItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getBundleLightItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getBundleLightItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__getBundleLightItemResponse;
		if (size)
			*size = sizeof(ns__getBundleLightItemResponse);
	}
	else
	{	cp->ptr = (void*)new ns__getBundleLightItemResponse[n];
		if (size)
			*size = n * sizeof(ns__getBundleLightItemResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__getBundleLightItemResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getBundleLightItemResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__getBundleLightItemResponse %p -> %p\n", q, p));
	*(ns__getBundleLightItemResponse*)p = *(ns__getBundleLightItemResponse*)q;
}

void ns__getBundleLightPropertyItemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getBundleLightPropertyItemResponse*)this)->_return.soap_serialize(soap);
}

void ns__getBundleLightPropertyItemResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getBundleLightPropertyItemResponse*)this)->_return.ns__bundleLight::soap_default(soap);
}

int ns__getBundleLightPropertyItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getBundleLightPropertyItemResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__getBundleLightPropertyItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__getBundleLightPropertyItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getBundleLightPropertyItemResponse(struct soap *soap, const char *tag, int id, const ns__getBundleLightPropertyItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getBundleLightPropertyItemResponse), type);
	(((ns__getBundleLightPropertyItemResponse*)a)->_return).soap_out(soap, "return", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__getBundleLightPropertyItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__getBundleLightPropertyItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__getBundleLightPropertyItemResponse * SOAP_FMAC4 soap_get_ns__getBundleLightPropertyItemResponse(struct soap *soap, ns__getBundleLightPropertyItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getBundleLightPropertyItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__getBundleLightPropertyItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__getBundleLightPropertyItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__getBundleLightPropertyItemResponse * SOAP_FMAC4 soap_in_ns__getBundleLightPropertyItemResponse(struct soap *soap, const char *tag, ns__getBundleLightPropertyItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__getBundleLightPropertyItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getBundleLightPropertyItemResponse, sizeof(ns__getBundleLightPropertyItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__getBundleLightPropertyItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__getBundleLightPropertyItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag__return1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((ns__getBundleLightPropertyItemResponse*)a)->_return).soap_in(soap, NULL, "ns:bundleLight"))
				{	soap_flag__return1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__return1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__getBundleLightPropertyItemResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getBundleLightPropertyItemResponse, 0, sizeof(ns__getBundleLightPropertyItemResponse), 0, soap_copy_ns__getBundleLightPropertyItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__getBundleLightPropertyItemResponse * SOAP_FMAC6 soap_new_ns__getBundleLightPropertyItemResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getBundleLightPropertyItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getBundleLightPropertyItemResponse(struct soap *soap, ns__getBundleLightPropertyItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__getBundleLightPropertyItemResponse * SOAP_FMAC4 soap_instantiate_ns__getBundleLightPropertyItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getBundleLightPropertyItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getBundleLightPropertyItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__getBundleLightPropertyItemResponse;
		if (size)
			*size = sizeof(ns__getBundleLightPropertyItemResponse);
	}
	else
	{	cp->ptr = (void*)new ns__getBundleLightPropertyItemResponse[n];
		if (size)
			*size = n * sizeof(ns__getBundleLightPropertyItemResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__getBundleLightPropertyItemResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getBundleLightPropertyItemResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__getBundleLightPropertyItemResponse %p -> %p\n", q, p));
	*(ns__getBundleLightPropertyItemResponse*)p = *(ns__getBundleLightPropertyItemResponse*)q;
}

void ns__bundleLight::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd_bundleLightProperty(soap, &((ns__bundleLight*)this)->devBundleLightProperty);
}

void ns__bundleLight::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd_bundleLightProperty(soap, &((ns__bundleLight*)this)->devBundleLightProperty);
	soap_default_ns__enum_bundleLight(soap, &((ns__bundleLight*)this)->model);
	soap_default_ns__enum_bundleLight(soap, &((ns__bundleLight*)this)->bundleLightPower);
	soap_default_ns__enum_bundleLight(soap, &((ns__bundleLight*)this)->bundleLightExit);
	soap_default_ns__enum_bundleLight(soap, &((ns__bundleLight*)this)->readyEnergyPower);
	soap_default_ns__enum_bundleLight(soap, &((ns__bundleLight*)this)->gasValve);
	soap_default_ns__enum_bundleLight(soap, &((ns__bundleLight*)this)->bundleLightElevator);
	soap_default_ns__enum_devError(soap, &((ns__bundleLight*)this)->bundleLightDevError);
	soap_default_ns__bundleLightFunc(soap, &((ns__bundleLight*)this)->func);
	soap_default_ns__enum_devInfo(soap, &((ns__rootDevice*)this)->dev);
	soap_default_ns__enum_devInfo(soap, &((ns__rootDevice*)this)->proto);
	soap_default_ns__enum_devInfo(soap, &((ns__rootDevice*)this)->intf);
	soap_default_unsignedInt(soap, &((ns__rootDevice*)this)->order);
}

int ns__bundleLight::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__bundleLight);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__bundleLight::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__bundleLight(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__bundleLight(struct soap *soap, const char *tag, int id, const ns__bundleLight *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__bundleLight), "ns:bundleLight");
	soap_out_ns__enum_devInfo(soap, "dev", -1, &(((ns__rootDevice*)a)->dev), "");
	soap_out_ns__enum_devInfo(soap, "proto", -1, &(((ns__rootDevice*)a)->proto), "");
	soap_out_ns__enum_devInfo(soap, "intf", -1, &(((ns__rootDevice*)a)->intf), "");
	soap_out_unsignedInt(soap, "order", -1, &(((ns__rootDevice*)a)->order), "");
	soap_out_xsd_bundleLightProperty(soap, "devBundleLightProperty", -1, &(((ns__bundleLight*)a)->devBundleLightProperty), "");
	soap_out_ns__enum_bundleLight(soap, "model", -1, &(((ns__bundleLight*)a)->model), "");
	soap_out_ns__enum_bundleLight(soap, "bundleLightPower", -1, &(((ns__bundleLight*)a)->bundleLightPower), "");
	soap_out_ns__enum_bundleLight(soap, "bundleLightExit", -1, &(((ns__bundleLight*)a)->bundleLightExit), "");
	soap_out_ns__enum_bundleLight(soap, "readyEnergyPower", -1, &(((ns__bundleLight*)a)->readyEnergyPower), "");
	soap_out_ns__enum_bundleLight(soap, "gasValve", -1, &(((ns__bundleLight*)a)->gasValve), "");
	soap_out_ns__enum_bundleLight(soap, "bundleLightElevator", -1, &(((ns__bundleLight*)a)->bundleLightElevator), "");
	soap_out_ns__enum_devError(soap, "bundleLightDevError", -1, &(((ns__bundleLight*)a)->bundleLightDevError), "");
	soap_out_ns__bundleLightFunc(soap, "func", -1, &(((ns__bundleLight*)a)->func), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__bundleLight::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__bundleLight(soap, this, tag, type);
}

SOAP_FMAC3 ns__bundleLight * SOAP_FMAC4 soap_get_ns__bundleLight(struct soap *soap, ns__bundleLight *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__bundleLight(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__bundleLight::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__bundleLight(soap, tag, this, type);
}

SOAP_FMAC3 ns__bundleLight * SOAP_FMAC4 soap_in_ns__bundleLight(struct soap *soap, const char *tag, ns__bundleLight *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__bundleLight *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__bundleLight, sizeof(ns__bundleLight), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__bundleLight)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__bundleLight *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_dev2 = 1, soap_flag_proto2 = 1, soap_flag_intf2 = 1, soap_flag_order2 = 1, soap_flag_devBundleLightProperty1 = 1, soap_flag_model1 = 1, soap_flag_bundleLightPower1 = 1, soap_flag_bundleLightExit1 = 1, soap_flag_readyEnergyPower1 = 1, soap_flag_gasValve1 = 1, soap_flag_bundleLightElevator1 = 1, soap_flag_bundleLightDevError1 = 1, soap_flag_func1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dev2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devInfo(soap, "dev", &(((ns__rootDevice*)a)->dev), "ns:enum-devInfo"))
				{	soap_flag_dev2--;
					continue;
				}
			if (soap_flag_proto2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devInfo(soap, "proto", &(((ns__rootDevice*)a)->proto), "ns:enum-devInfo"))
				{	soap_flag_proto2--;
					continue;
				}
			if (soap_flag_intf2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devInfo(soap, "intf", &(((ns__rootDevice*)a)->intf), "ns:enum-devInfo"))
				{	soap_flag_intf2--;
					continue;
				}
			if (soap_flag_order2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "order", &(((ns__rootDevice*)a)->order), "xsd:unsignedInt"))
				{	soap_flag_order2--;
					continue;
				}
			if (soap_flag_devBundleLightProperty1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd_bundleLightProperty(soap, "devBundleLightProperty", &(((ns__bundleLight*)a)->devBundleLightProperty), "xsd-bundleLightProperty"))
				{	soap_flag_devBundleLightProperty1--;
					continue;
				}
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_bundleLight(soap, "model", &(((ns__bundleLight*)a)->model), "ns:enum-bundleLight"))
				{	soap_flag_model1--;
					continue;
				}
			if (soap_flag_bundleLightPower1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_bundleLight(soap, "bundleLightPower", &(((ns__bundleLight*)a)->bundleLightPower), "ns:enum-bundleLight"))
				{	soap_flag_bundleLightPower1--;
					continue;
				}
			if (soap_flag_bundleLightExit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_bundleLight(soap, "bundleLightExit", &(((ns__bundleLight*)a)->bundleLightExit), "ns:enum-bundleLight"))
				{	soap_flag_bundleLightExit1--;
					continue;
				}
			if (soap_flag_readyEnergyPower1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_bundleLight(soap, "readyEnergyPower", &(((ns__bundleLight*)a)->readyEnergyPower), "ns:enum-bundleLight"))
				{	soap_flag_readyEnergyPower1--;
					continue;
				}
			if (soap_flag_gasValve1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_bundleLight(soap, "gasValve", &(((ns__bundleLight*)a)->gasValve), "ns:enum-bundleLight"))
				{	soap_flag_gasValve1--;
					continue;
				}
			if (soap_flag_bundleLightElevator1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_bundleLight(soap, "bundleLightElevator", &(((ns__bundleLight*)a)->bundleLightElevator), "ns:enum-bundleLight"))
				{	soap_flag_bundleLightElevator1--;
					continue;
				}
			if (soap_flag_bundleLightDevError1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devError(soap, "bundleLightDevError", &(((ns__bundleLight*)a)->bundleLightDevError), "ns:enum-devError"))
				{	soap_flag_bundleLightDevError1--;
					continue;
				}
			if (soap_flag_func1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__bundleLightFunc(soap, "func", &(((ns__bundleLight*)a)->func), "ns:bundleLightFunc"))
				{	soap_flag_func1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dev2 > 0 || soap_flag_proto2 > 0 || soap_flag_intf2 > 0 || soap_flag_order2 > 0 || soap_flag_devBundleLightProperty1 > 0 || soap_flag_model1 > 0 || soap_flag_bundleLightPower1 > 0 || soap_flag_bundleLightExit1 > 0 || soap_flag_readyEnergyPower1 > 0 || soap_flag_gasValve1 > 0 || soap_flag_bundleLightElevator1 > 0 || soap_flag_bundleLightDevError1 > 0 || soap_flag_func1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__bundleLight *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__bundleLight, 0, sizeof(ns__bundleLight), 0, soap_copy_ns__bundleLight);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__bundleLight * SOAP_FMAC6 soap_new_ns__bundleLight(struct soap *soap, int n)
{	return soap_instantiate_ns__bundleLight(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__bundleLight(struct soap *soap, ns__bundleLight *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__bundleLight * SOAP_FMAC4 soap_instantiate_ns__bundleLight(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__bundleLight(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__bundleLight, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__bundleLight;
		if (size)
			*size = sizeof(ns__bundleLight);
	}
	else
	{	cp->ptr = (void*)new ns__bundleLight[n];
		if (size)
			*size = n * sizeof(ns__bundleLight);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__bundleLight*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__bundleLight(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__bundleLight %p -> %p\n", q, p));
	*(ns__bundleLight*)p = *(ns__bundleLight*)q;
}

void ns__setCurtainResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
}

void ns__setCurtainResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

int ns__setCurtainResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__setCurtainResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__setCurtainResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__setCurtainResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setCurtainResponse(struct soap *soap, const char *tag, int id, const ns__setCurtainResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__setCurtainResponse), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__setCurtainResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__setCurtainResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__setCurtainResponse * SOAP_FMAC4 soap_get_ns__setCurtainResponse(struct soap *soap, ns__setCurtainResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setCurtainResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__setCurtainResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__setCurtainResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__setCurtainResponse * SOAP_FMAC4 soap_in_ns__setCurtainResponse(struct soap *soap, const char *tag, ns__setCurtainResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__setCurtainResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__setCurtainResponse, sizeof(ns__setCurtainResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__setCurtainResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__setCurtainResponse *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__setCurtainResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__setCurtainResponse, 0, sizeof(ns__setCurtainResponse), 0, soap_copy_ns__setCurtainResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__setCurtainResponse * SOAP_FMAC6 soap_new_ns__setCurtainResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__setCurtainResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setCurtainResponse(struct soap *soap, ns__setCurtainResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__setCurtainResponse * SOAP_FMAC4 soap_instantiate_ns__setCurtainResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setCurtainResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__setCurtainResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__setCurtainResponse;
		if (size)
			*size = sizeof(ns__setCurtainResponse);
	}
	else
	{	cp->ptr = (void*)new ns__setCurtainResponse[n];
		if (size)
			*size = n * sizeof(ns__setCurtainResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__setCurtainResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setCurtainResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__setCurtainResponse %p -> %p\n", q, p));
	*(ns__setCurtainResponse*)p = *(ns__setCurtainResponse*)q;
}

void ns__getCurtainResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getCurtainResponse*)this)->_return.soap_serialize(soap);
}

void ns__getCurtainResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getCurtainResponse*)this)->_return.ns__curtain::soap_default(soap);
}

int ns__getCurtainResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getCurtainResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__getCurtainResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__getCurtainResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getCurtainResponse(struct soap *soap, const char *tag, int id, const ns__getCurtainResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getCurtainResponse), type);
	(((ns__getCurtainResponse*)a)->_return).soap_out(soap, "return", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__getCurtainResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__getCurtainResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__getCurtainResponse * SOAP_FMAC4 soap_get_ns__getCurtainResponse(struct soap *soap, ns__getCurtainResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getCurtainResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__getCurtainResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__getCurtainResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__getCurtainResponse * SOAP_FMAC4 soap_in_ns__getCurtainResponse(struct soap *soap, const char *tag, ns__getCurtainResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__getCurtainResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getCurtainResponse, sizeof(ns__getCurtainResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__getCurtainResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__getCurtainResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag__return1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((ns__getCurtainResponse*)a)->_return).soap_in(soap, NULL, "ns:curtain"))
				{	soap_flag__return1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__return1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__getCurtainResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getCurtainResponse, 0, sizeof(ns__getCurtainResponse), 0, soap_copy_ns__getCurtainResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__getCurtainResponse * SOAP_FMAC6 soap_new_ns__getCurtainResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getCurtainResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getCurtainResponse(struct soap *soap, ns__getCurtainResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__getCurtainResponse * SOAP_FMAC4 soap_instantiate_ns__getCurtainResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getCurtainResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getCurtainResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__getCurtainResponse;
		if (size)
			*size = sizeof(ns__getCurtainResponse);
	}
	else
	{	cp->ptr = (void*)new ns__getCurtainResponse[n];
		if (size)
			*size = n * sizeof(ns__getCurtainResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__getCurtainResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getCurtainResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__getCurtainResponse %p -> %p\n", q, p));
	*(ns__getCurtainResponse*)p = *(ns__getCurtainResponse*)q;
}

void ns__getCurtainItemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getCurtainItemResponse*)this)->_return.soap_serialize(soap);
}

void ns__getCurtainItemResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getCurtainItemResponse*)this)->_return.ns__curtain::soap_default(soap);
}

int ns__getCurtainItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getCurtainItemResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__getCurtainItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__getCurtainItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getCurtainItemResponse(struct soap *soap, const char *tag, int id, const ns__getCurtainItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getCurtainItemResponse), type);
	(((ns__getCurtainItemResponse*)a)->_return).soap_out(soap, "return", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__getCurtainItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__getCurtainItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__getCurtainItemResponse * SOAP_FMAC4 soap_get_ns__getCurtainItemResponse(struct soap *soap, ns__getCurtainItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getCurtainItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__getCurtainItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__getCurtainItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__getCurtainItemResponse * SOAP_FMAC4 soap_in_ns__getCurtainItemResponse(struct soap *soap, const char *tag, ns__getCurtainItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__getCurtainItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getCurtainItemResponse, sizeof(ns__getCurtainItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__getCurtainItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__getCurtainItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag__return1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((ns__getCurtainItemResponse*)a)->_return).soap_in(soap, NULL, "ns:curtain"))
				{	soap_flag__return1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__return1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__getCurtainItemResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getCurtainItemResponse, 0, sizeof(ns__getCurtainItemResponse), 0, soap_copy_ns__getCurtainItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__getCurtainItemResponse * SOAP_FMAC6 soap_new_ns__getCurtainItemResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getCurtainItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getCurtainItemResponse(struct soap *soap, ns__getCurtainItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__getCurtainItemResponse * SOAP_FMAC4 soap_instantiate_ns__getCurtainItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getCurtainItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getCurtainItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__getCurtainItemResponse;
		if (size)
			*size = sizeof(ns__getCurtainItemResponse);
	}
	else
	{	cp->ptr = (void*)new ns__getCurtainItemResponse[n];
		if (size)
			*size = n * sizeof(ns__getCurtainItemResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__getCurtainItemResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getCurtainItemResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__getCurtainItemResponse %p -> %p\n", q, p));
	*(ns__getCurtainItemResponse*)p = *(ns__getCurtainItemResponse*)q;
}

void ns__getCurtainPropertyItemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getCurtainPropertyItemResponse*)this)->_return.soap_serialize(soap);
}

void ns__getCurtainPropertyItemResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getCurtainPropertyItemResponse*)this)->_return.ns__curtain::soap_default(soap);
}

int ns__getCurtainPropertyItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getCurtainPropertyItemResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__getCurtainPropertyItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__getCurtainPropertyItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getCurtainPropertyItemResponse(struct soap *soap, const char *tag, int id, const ns__getCurtainPropertyItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getCurtainPropertyItemResponse), type);
	(((ns__getCurtainPropertyItemResponse*)a)->_return).soap_out(soap, "return", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__getCurtainPropertyItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__getCurtainPropertyItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__getCurtainPropertyItemResponse * SOAP_FMAC4 soap_get_ns__getCurtainPropertyItemResponse(struct soap *soap, ns__getCurtainPropertyItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getCurtainPropertyItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__getCurtainPropertyItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__getCurtainPropertyItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__getCurtainPropertyItemResponse * SOAP_FMAC4 soap_in_ns__getCurtainPropertyItemResponse(struct soap *soap, const char *tag, ns__getCurtainPropertyItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__getCurtainPropertyItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getCurtainPropertyItemResponse, sizeof(ns__getCurtainPropertyItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__getCurtainPropertyItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__getCurtainPropertyItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag__return1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((ns__getCurtainPropertyItemResponse*)a)->_return).soap_in(soap, NULL, "ns:curtain"))
				{	soap_flag__return1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__return1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__getCurtainPropertyItemResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getCurtainPropertyItemResponse, 0, sizeof(ns__getCurtainPropertyItemResponse), 0, soap_copy_ns__getCurtainPropertyItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__getCurtainPropertyItemResponse * SOAP_FMAC6 soap_new_ns__getCurtainPropertyItemResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getCurtainPropertyItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getCurtainPropertyItemResponse(struct soap *soap, ns__getCurtainPropertyItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__getCurtainPropertyItemResponse * SOAP_FMAC4 soap_instantiate_ns__getCurtainPropertyItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getCurtainPropertyItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getCurtainPropertyItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__getCurtainPropertyItemResponse;
		if (size)
			*size = sizeof(ns__getCurtainPropertyItemResponse);
	}
	else
	{	cp->ptr = (void*)new ns__getCurtainPropertyItemResponse[n];
		if (size)
			*size = n * sizeof(ns__getCurtainPropertyItemResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__getCurtainPropertyItemResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getCurtainPropertyItemResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__getCurtainPropertyItemResponse %p -> %p\n", q, p));
	*(ns__getCurtainPropertyItemResponse*)p = *(ns__getCurtainPropertyItemResponse*)q;
}

void ns__curtain::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd_curtainProperty(soap, &((ns__curtain*)this)->devCurtainProperty);
	soap_embedded(soap, &((ns__curtain*)this)->curtainAngular, SOAP_TYPE_cmxDeviceService_int);
}

void ns__curtain::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd_curtainProperty(soap, &((ns__curtain*)this)->devCurtainProperty);
	soap_default_ns__enum_curtain(soap, &((ns__curtain*)this)->model);
	soap_default_ns__enum_curtain(soap, &((ns__curtain*)this)->curtainDo);
	soap_default_ns__enum_devError(soap, &((ns__curtain*)this)->curtainDevError);
	soap_default_int(soap, &((ns__curtain*)this)->curtainAngular);
	soap_default_ns__curtainFunc(soap, &((ns__curtain*)this)->func);
	soap_default_ns__enum_devInfo(soap, &((ns__rootDevice*)this)->dev);
	soap_default_ns__enum_devInfo(soap, &((ns__rootDevice*)this)->proto);
	soap_default_ns__enum_devInfo(soap, &((ns__rootDevice*)this)->intf);
	soap_default_unsignedInt(soap, &((ns__rootDevice*)this)->order);
}

int ns__curtain::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__curtain);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__curtain::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__curtain(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__curtain(struct soap *soap, const char *tag, int id, const ns__curtain *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__curtain), "ns:curtain");
	soap_out_ns__enum_devInfo(soap, "dev", -1, &(((ns__rootDevice*)a)->dev), "");
	soap_out_ns__enum_devInfo(soap, "proto", -1, &(((ns__rootDevice*)a)->proto), "");
	soap_out_ns__enum_devInfo(soap, "intf", -1, &(((ns__rootDevice*)a)->intf), "");
	soap_out_unsignedInt(soap, "order", -1, &(((ns__rootDevice*)a)->order), "");
	soap_out_xsd_curtainProperty(soap, "devCurtainProperty", -1, &(((ns__curtain*)a)->devCurtainProperty), "");
	soap_out_ns__enum_curtain(soap, "model", -1, &(((ns__curtain*)a)->model), "");
	soap_out_ns__enum_curtain(soap, "curtainDo", -1, &(((ns__curtain*)a)->curtainDo), "");
	soap_out_ns__enum_devError(soap, "curtainDevError", -1, &(((ns__curtain*)a)->curtainDevError), "");
	soap_out_int(soap, "curtainAngular", -1, &(((ns__curtain*)a)->curtainAngular), "");
	soap_out_ns__curtainFunc(soap, "func", -1, &(((ns__curtain*)a)->func), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__curtain::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__curtain(soap, this, tag, type);
}

SOAP_FMAC3 ns__curtain * SOAP_FMAC4 soap_get_ns__curtain(struct soap *soap, ns__curtain *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__curtain(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__curtain::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__curtain(soap, tag, this, type);
}

SOAP_FMAC3 ns__curtain * SOAP_FMAC4 soap_in_ns__curtain(struct soap *soap, const char *tag, ns__curtain *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__curtain *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__curtain, sizeof(ns__curtain), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__curtain)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__curtain *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_dev2 = 1, soap_flag_proto2 = 1, soap_flag_intf2 = 1, soap_flag_order2 = 1, soap_flag_devCurtainProperty1 = 1, soap_flag_model1 = 1, soap_flag_curtainDo1 = 1, soap_flag_curtainDevError1 = 1, soap_flag_curtainAngular1 = 1, soap_flag_func1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dev2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devInfo(soap, "dev", &(((ns__rootDevice*)a)->dev), "ns:enum-devInfo"))
				{	soap_flag_dev2--;
					continue;
				}
			if (soap_flag_proto2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devInfo(soap, "proto", &(((ns__rootDevice*)a)->proto), "ns:enum-devInfo"))
				{	soap_flag_proto2--;
					continue;
				}
			if (soap_flag_intf2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devInfo(soap, "intf", &(((ns__rootDevice*)a)->intf), "ns:enum-devInfo"))
				{	soap_flag_intf2--;
					continue;
				}
			if (soap_flag_order2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "order", &(((ns__rootDevice*)a)->order), "xsd:unsignedInt"))
				{	soap_flag_order2--;
					continue;
				}
			if (soap_flag_devCurtainProperty1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd_curtainProperty(soap, "devCurtainProperty", &(((ns__curtain*)a)->devCurtainProperty), "xsd-curtainProperty"))
				{	soap_flag_devCurtainProperty1--;
					continue;
				}
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_curtain(soap, "model", &(((ns__curtain*)a)->model), "ns:enum-curtain"))
				{	soap_flag_model1--;
					continue;
				}
			if (soap_flag_curtainDo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_curtain(soap, "curtainDo", &(((ns__curtain*)a)->curtainDo), "ns:enum-curtain"))
				{	soap_flag_curtainDo1--;
					continue;
				}
			if (soap_flag_curtainDevError1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devError(soap, "curtainDevError", &(((ns__curtain*)a)->curtainDevError), "ns:enum-devError"))
				{	soap_flag_curtainDevError1--;
					continue;
				}
			if (soap_flag_curtainAngular1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curtainAngular", &(((ns__curtain*)a)->curtainAngular), "xsd:int"))
				{	soap_flag_curtainAngular1--;
					continue;
				}
			if (soap_flag_func1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__curtainFunc(soap, "func", &(((ns__curtain*)a)->func), "ns:curtainFunc"))
				{	soap_flag_func1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dev2 > 0 || soap_flag_proto2 > 0 || soap_flag_intf2 > 0 || soap_flag_order2 > 0 || soap_flag_devCurtainProperty1 > 0 || soap_flag_model1 > 0 || soap_flag_curtainDo1 > 0 || soap_flag_curtainDevError1 > 0 || soap_flag_curtainAngular1 > 0 || soap_flag_func1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__curtain *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__curtain, 0, sizeof(ns__curtain), 0, soap_copy_ns__curtain);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__curtain * SOAP_FMAC6 soap_new_ns__curtain(struct soap *soap, int n)
{	return soap_instantiate_ns__curtain(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__curtain(struct soap *soap, ns__curtain *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__curtain * SOAP_FMAC4 soap_instantiate_ns__curtain(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__curtain(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__curtain, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__curtain;
		if (size)
			*size = sizeof(ns__curtain);
	}
	else
	{	cp->ptr = (void*)new ns__curtain[n];
		if (size)
			*size = n * sizeof(ns__curtain);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__curtain*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__curtain(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__curtain %p -> %p\n", q, p));
	*(ns__curtain*)p = *(ns__curtain*)q;
}

void ns__setGasValveResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
}

void ns__setGasValveResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

int ns__setGasValveResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__setGasValveResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__setGasValveResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__setGasValveResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setGasValveResponse(struct soap *soap, const char *tag, int id, const ns__setGasValveResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__setGasValveResponse), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__setGasValveResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__setGasValveResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__setGasValveResponse * SOAP_FMAC4 soap_get_ns__setGasValveResponse(struct soap *soap, ns__setGasValveResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setGasValveResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__setGasValveResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__setGasValveResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__setGasValveResponse * SOAP_FMAC4 soap_in_ns__setGasValveResponse(struct soap *soap, const char *tag, ns__setGasValveResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__setGasValveResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__setGasValveResponse, sizeof(ns__setGasValveResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__setGasValveResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__setGasValveResponse *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__setGasValveResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__setGasValveResponse, 0, sizeof(ns__setGasValveResponse), 0, soap_copy_ns__setGasValveResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__setGasValveResponse * SOAP_FMAC6 soap_new_ns__setGasValveResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__setGasValveResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setGasValveResponse(struct soap *soap, ns__setGasValveResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__setGasValveResponse * SOAP_FMAC4 soap_instantiate_ns__setGasValveResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setGasValveResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__setGasValveResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__setGasValveResponse;
		if (size)
			*size = sizeof(ns__setGasValveResponse);
	}
	else
	{	cp->ptr = (void*)new ns__setGasValveResponse[n];
		if (size)
			*size = n * sizeof(ns__setGasValveResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__setGasValveResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setGasValveResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__setGasValveResponse %p -> %p\n", q, p));
	*(ns__setGasValveResponse*)p = *(ns__setGasValveResponse*)q;
}

void ns__getGasValveResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getGasValveResponse*)this)->_return.soap_serialize(soap);
}

void ns__getGasValveResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getGasValveResponse*)this)->_return.ns__gasValve::soap_default(soap);
}

int ns__getGasValveResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getGasValveResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__getGasValveResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__getGasValveResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getGasValveResponse(struct soap *soap, const char *tag, int id, const ns__getGasValveResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getGasValveResponse), type);
	(((ns__getGasValveResponse*)a)->_return).soap_out(soap, "return", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__getGasValveResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__getGasValveResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__getGasValveResponse * SOAP_FMAC4 soap_get_ns__getGasValveResponse(struct soap *soap, ns__getGasValveResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getGasValveResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__getGasValveResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__getGasValveResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__getGasValveResponse * SOAP_FMAC4 soap_in_ns__getGasValveResponse(struct soap *soap, const char *tag, ns__getGasValveResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__getGasValveResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getGasValveResponse, sizeof(ns__getGasValveResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__getGasValveResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__getGasValveResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag__return1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((ns__getGasValveResponse*)a)->_return).soap_in(soap, NULL, "ns:gasValve"))
				{	soap_flag__return1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__return1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__getGasValveResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getGasValveResponse, 0, sizeof(ns__getGasValveResponse), 0, soap_copy_ns__getGasValveResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__getGasValveResponse * SOAP_FMAC6 soap_new_ns__getGasValveResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getGasValveResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getGasValveResponse(struct soap *soap, ns__getGasValveResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__getGasValveResponse * SOAP_FMAC4 soap_instantiate_ns__getGasValveResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getGasValveResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getGasValveResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__getGasValveResponse;
		if (size)
			*size = sizeof(ns__getGasValveResponse);
	}
	else
	{	cp->ptr = (void*)new ns__getGasValveResponse[n];
		if (size)
			*size = n * sizeof(ns__getGasValveResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__getGasValveResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getGasValveResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__getGasValveResponse %p -> %p\n", q, p));
	*(ns__getGasValveResponse*)p = *(ns__getGasValveResponse*)q;
}

void ns__getGasValveItemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getGasValveItemResponse*)this)->_return.soap_serialize(soap);
}

void ns__getGasValveItemResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getGasValveItemResponse*)this)->_return.ns__gasValve::soap_default(soap);
}

int ns__getGasValveItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getGasValveItemResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__getGasValveItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__getGasValveItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getGasValveItemResponse(struct soap *soap, const char *tag, int id, const ns__getGasValveItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getGasValveItemResponse), type);
	(((ns__getGasValveItemResponse*)a)->_return).soap_out(soap, "return", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__getGasValveItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__getGasValveItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__getGasValveItemResponse * SOAP_FMAC4 soap_get_ns__getGasValveItemResponse(struct soap *soap, ns__getGasValveItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getGasValveItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__getGasValveItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__getGasValveItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__getGasValveItemResponse * SOAP_FMAC4 soap_in_ns__getGasValveItemResponse(struct soap *soap, const char *tag, ns__getGasValveItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__getGasValveItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getGasValveItemResponse, sizeof(ns__getGasValveItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__getGasValveItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__getGasValveItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag__return1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((ns__getGasValveItemResponse*)a)->_return).soap_in(soap, NULL, "ns:gasValve"))
				{	soap_flag__return1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__return1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__getGasValveItemResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getGasValveItemResponse, 0, sizeof(ns__getGasValveItemResponse), 0, soap_copy_ns__getGasValveItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__getGasValveItemResponse * SOAP_FMAC6 soap_new_ns__getGasValveItemResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getGasValveItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getGasValveItemResponse(struct soap *soap, ns__getGasValveItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__getGasValveItemResponse * SOAP_FMAC4 soap_instantiate_ns__getGasValveItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getGasValveItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getGasValveItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__getGasValveItemResponse;
		if (size)
			*size = sizeof(ns__getGasValveItemResponse);
	}
	else
	{	cp->ptr = (void*)new ns__getGasValveItemResponse[n];
		if (size)
			*size = n * sizeof(ns__getGasValveItemResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__getGasValveItemResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getGasValveItemResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__getGasValveItemResponse %p -> %p\n", q, p));
	*(ns__getGasValveItemResponse*)p = *(ns__getGasValveItemResponse*)q;
}

void ns__getGasValvePropertyItemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getGasValvePropertyItemResponse*)this)->_return.soap_serialize(soap);
}

void ns__getGasValvePropertyItemResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getGasValvePropertyItemResponse*)this)->_return.ns__gasValve::soap_default(soap);
}

int ns__getGasValvePropertyItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getGasValvePropertyItemResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__getGasValvePropertyItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__getGasValvePropertyItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getGasValvePropertyItemResponse(struct soap *soap, const char *tag, int id, const ns__getGasValvePropertyItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getGasValvePropertyItemResponse), type);
	(((ns__getGasValvePropertyItemResponse*)a)->_return).soap_out(soap, "return", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__getGasValvePropertyItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__getGasValvePropertyItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__getGasValvePropertyItemResponse * SOAP_FMAC4 soap_get_ns__getGasValvePropertyItemResponse(struct soap *soap, ns__getGasValvePropertyItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getGasValvePropertyItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__getGasValvePropertyItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__getGasValvePropertyItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__getGasValvePropertyItemResponse * SOAP_FMAC4 soap_in_ns__getGasValvePropertyItemResponse(struct soap *soap, const char *tag, ns__getGasValvePropertyItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__getGasValvePropertyItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getGasValvePropertyItemResponse, sizeof(ns__getGasValvePropertyItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__getGasValvePropertyItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__getGasValvePropertyItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag__return1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((ns__getGasValvePropertyItemResponse*)a)->_return).soap_in(soap, NULL, "ns:gasValve"))
				{	soap_flag__return1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__return1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__getGasValvePropertyItemResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getGasValvePropertyItemResponse, 0, sizeof(ns__getGasValvePropertyItemResponse), 0, soap_copy_ns__getGasValvePropertyItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__getGasValvePropertyItemResponse * SOAP_FMAC6 soap_new_ns__getGasValvePropertyItemResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getGasValvePropertyItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getGasValvePropertyItemResponse(struct soap *soap, ns__getGasValvePropertyItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__getGasValvePropertyItemResponse * SOAP_FMAC4 soap_instantiate_ns__getGasValvePropertyItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getGasValvePropertyItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getGasValvePropertyItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__getGasValvePropertyItemResponse;
		if (size)
			*size = sizeof(ns__getGasValvePropertyItemResponse);
	}
	else
	{	cp->ptr = (void*)new ns__getGasValvePropertyItemResponse[n];
		if (size)
			*size = n * sizeof(ns__getGasValvePropertyItemResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__getGasValvePropertyItemResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getGasValvePropertyItemResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__getGasValvePropertyItemResponse %p -> %p\n", q, p));
	*(ns__getGasValvePropertyItemResponse*)p = *(ns__getGasValvePropertyItemResponse*)q;
}

void ns__gasValve::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd_gasValveProperty(soap, &((ns__gasValve*)this)->devGasValveProperty);
}

void ns__gasValve::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd_gasValveProperty(soap, &((ns__gasValve*)this)->devGasValveProperty);
	soap_default_ns__enum_gasValve(soap, &((ns__gasValve*)this)->model);
	soap_default_ns__enum_gasValve(soap, &((ns__gasValve*)this)->gvDo);
	soap_default_ns__enum_gasValve(soap, &((ns__gasValve*)this)->gvAlarm);
	soap_default_ns__enum_devError(soap, &((ns__gasValve*)this)->gvDevError);
	soap_default_ns__gasValveFunc(soap, &((ns__gasValve*)this)->func);
	soap_default_ns__enum_devInfo(soap, &((ns__rootDevice*)this)->dev);
	soap_default_ns__enum_devInfo(soap, &((ns__rootDevice*)this)->proto);
	soap_default_ns__enum_devInfo(soap, &((ns__rootDevice*)this)->intf);
	soap_default_unsignedInt(soap, &((ns__rootDevice*)this)->order);
}

int ns__gasValve::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__gasValve);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__gasValve::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__gasValve(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gasValve(struct soap *soap, const char *tag, int id, const ns__gasValve *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__gasValve), "ns:gasValve");
	soap_out_ns__enum_devInfo(soap, "dev", -1, &(((ns__rootDevice*)a)->dev), "");
	soap_out_ns__enum_devInfo(soap, "proto", -1, &(((ns__rootDevice*)a)->proto), "");
	soap_out_ns__enum_devInfo(soap, "intf", -1, &(((ns__rootDevice*)a)->intf), "");
	soap_out_unsignedInt(soap, "order", -1, &(((ns__rootDevice*)a)->order), "");
	soap_out_xsd_gasValveProperty(soap, "devGasValveProperty", -1, &(((ns__gasValve*)a)->devGasValveProperty), "");
	soap_out_ns__enum_gasValve(soap, "model", -1, &(((ns__gasValve*)a)->model), "");
	soap_out_ns__enum_gasValve(soap, "gvDo", -1, &(((ns__gasValve*)a)->gvDo), "");
	soap_out_ns__enum_gasValve(soap, "gvAlarm", -1, &(((ns__gasValve*)a)->gvAlarm), "");
	soap_out_ns__enum_devError(soap, "gvDevError", -1, &(((ns__gasValve*)a)->gvDevError), "");
	soap_out_ns__gasValveFunc(soap, "func", -1, &(((ns__gasValve*)a)->func), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__gasValve::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__gasValve(soap, this, tag, type);
}

SOAP_FMAC3 ns__gasValve * SOAP_FMAC4 soap_get_ns__gasValve(struct soap *soap, ns__gasValve *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gasValve(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__gasValve::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__gasValve(soap, tag, this, type);
}

SOAP_FMAC3 ns__gasValve * SOAP_FMAC4 soap_in_ns__gasValve(struct soap *soap, const char *tag, ns__gasValve *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__gasValve *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__gasValve, sizeof(ns__gasValve), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__gasValve)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__gasValve *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_dev2 = 1, soap_flag_proto2 = 1, soap_flag_intf2 = 1, soap_flag_order2 = 1, soap_flag_devGasValveProperty1 = 1, soap_flag_model1 = 1, soap_flag_gvDo1 = 1, soap_flag_gvAlarm1 = 1, soap_flag_gvDevError1 = 1, soap_flag_func1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dev2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devInfo(soap, "dev", &(((ns__rootDevice*)a)->dev), "ns:enum-devInfo"))
				{	soap_flag_dev2--;
					continue;
				}
			if (soap_flag_proto2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devInfo(soap, "proto", &(((ns__rootDevice*)a)->proto), "ns:enum-devInfo"))
				{	soap_flag_proto2--;
					continue;
				}
			if (soap_flag_intf2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devInfo(soap, "intf", &(((ns__rootDevice*)a)->intf), "ns:enum-devInfo"))
				{	soap_flag_intf2--;
					continue;
				}
			if (soap_flag_order2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "order", &(((ns__rootDevice*)a)->order), "xsd:unsignedInt"))
				{	soap_flag_order2--;
					continue;
				}
			if (soap_flag_devGasValveProperty1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd_gasValveProperty(soap, "devGasValveProperty", &(((ns__gasValve*)a)->devGasValveProperty), "xsd-gasValveProperty"))
				{	soap_flag_devGasValveProperty1--;
					continue;
				}
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_gasValve(soap, "model", &(((ns__gasValve*)a)->model), "ns:enum-gasValve"))
				{	soap_flag_model1--;
					continue;
				}
			if (soap_flag_gvDo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_gasValve(soap, "gvDo", &(((ns__gasValve*)a)->gvDo), "ns:enum-gasValve"))
				{	soap_flag_gvDo1--;
					continue;
				}
			if (soap_flag_gvAlarm1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_gasValve(soap, "gvAlarm", &(((ns__gasValve*)a)->gvAlarm), "ns:enum-gasValve"))
				{	soap_flag_gvAlarm1--;
					continue;
				}
			if (soap_flag_gvDevError1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devError(soap, "gvDevError", &(((ns__gasValve*)a)->gvDevError), "ns:enum-devError"))
				{	soap_flag_gvDevError1--;
					continue;
				}
			if (soap_flag_func1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__gasValveFunc(soap, "func", &(((ns__gasValve*)a)->func), "ns:gasValveFunc"))
				{	soap_flag_func1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dev2 > 0 || soap_flag_proto2 > 0 || soap_flag_intf2 > 0 || soap_flag_order2 > 0 || soap_flag_devGasValveProperty1 > 0 || soap_flag_model1 > 0 || soap_flag_gvDo1 > 0 || soap_flag_gvAlarm1 > 0 || soap_flag_gvDevError1 > 0 || soap_flag_func1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__gasValve *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__gasValve, 0, sizeof(ns__gasValve), 0, soap_copy_ns__gasValve);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__gasValve * SOAP_FMAC6 soap_new_ns__gasValve(struct soap *soap, int n)
{	return soap_instantiate_ns__gasValve(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__gasValve(struct soap *soap, ns__gasValve *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__gasValve * SOAP_FMAC4 soap_instantiate_ns__gasValve(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__gasValve(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__gasValve, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__gasValve;
		if (size)
			*size = sizeof(ns__gasValve);
	}
	else
	{	cp->ptr = (void*)new ns__gasValve[n];
		if (size)
			*size = n * sizeof(ns__gasValve);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__gasValve*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__gasValve(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__gasValve %p -> %p\n", q, p));
	*(ns__gasValve*)p = *(ns__gasValve*)q;
}

void ns__setLightResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
}

void ns__setLightResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

int ns__setLightResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__setLightResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__setLightResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__setLightResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setLightResponse(struct soap *soap, const char *tag, int id, const ns__setLightResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__setLightResponse), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__setLightResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__setLightResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__setLightResponse * SOAP_FMAC4 soap_get_ns__setLightResponse(struct soap *soap, ns__setLightResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setLightResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__setLightResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__setLightResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__setLightResponse * SOAP_FMAC4 soap_in_ns__setLightResponse(struct soap *soap, const char *tag, ns__setLightResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__setLightResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__setLightResponse, sizeof(ns__setLightResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__setLightResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__setLightResponse *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__setLightResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__setLightResponse, 0, sizeof(ns__setLightResponse), 0, soap_copy_ns__setLightResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__setLightResponse * SOAP_FMAC6 soap_new_ns__setLightResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__setLightResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setLightResponse(struct soap *soap, ns__setLightResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__setLightResponse * SOAP_FMAC4 soap_instantiate_ns__setLightResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setLightResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__setLightResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__setLightResponse;
		if (size)
			*size = sizeof(ns__setLightResponse);
	}
	else
	{	cp->ptr = (void*)new ns__setLightResponse[n];
		if (size)
			*size = n * sizeof(ns__setLightResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__setLightResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setLightResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__setLightResponse %p -> %p\n", q, p));
	*(ns__setLightResponse*)p = *(ns__setLightResponse*)q;
}

void ns__getLightResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getLightResponse*)this)->_return.soap_serialize(soap);
}

void ns__getLightResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getLightResponse*)this)->_return.ns__light::soap_default(soap);
}

int ns__getLightResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getLightResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__getLightResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__getLightResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getLightResponse(struct soap *soap, const char *tag, int id, const ns__getLightResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getLightResponse), type);
	(((ns__getLightResponse*)a)->_return).soap_out(soap, "return", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__getLightResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__getLightResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__getLightResponse * SOAP_FMAC4 soap_get_ns__getLightResponse(struct soap *soap, ns__getLightResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getLightResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__getLightResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__getLightResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__getLightResponse * SOAP_FMAC4 soap_in_ns__getLightResponse(struct soap *soap, const char *tag, ns__getLightResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__getLightResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getLightResponse, sizeof(ns__getLightResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__getLightResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__getLightResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag__return1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((ns__getLightResponse*)a)->_return).soap_in(soap, NULL, "ns:light"))
				{	soap_flag__return1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__return1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__getLightResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getLightResponse, 0, sizeof(ns__getLightResponse), 0, soap_copy_ns__getLightResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__getLightResponse * SOAP_FMAC6 soap_new_ns__getLightResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getLightResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getLightResponse(struct soap *soap, ns__getLightResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__getLightResponse * SOAP_FMAC4 soap_instantiate_ns__getLightResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getLightResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getLightResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__getLightResponse;
		if (size)
			*size = sizeof(ns__getLightResponse);
	}
	else
	{	cp->ptr = (void*)new ns__getLightResponse[n];
		if (size)
			*size = n * sizeof(ns__getLightResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__getLightResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getLightResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__getLightResponse %p -> %p\n", q, p));
	*(ns__getLightResponse*)p = *(ns__getLightResponse*)q;
}

void ns__getLightItemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getLightItemResponse*)this)->_return.soap_serialize(soap);
}

void ns__getLightItemResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getLightItemResponse*)this)->_return.ns__light::soap_default(soap);
}

int ns__getLightItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getLightItemResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__getLightItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__getLightItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getLightItemResponse(struct soap *soap, const char *tag, int id, const ns__getLightItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getLightItemResponse), type);
	(((ns__getLightItemResponse*)a)->_return).soap_out(soap, "return", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__getLightItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__getLightItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__getLightItemResponse * SOAP_FMAC4 soap_get_ns__getLightItemResponse(struct soap *soap, ns__getLightItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getLightItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__getLightItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__getLightItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__getLightItemResponse * SOAP_FMAC4 soap_in_ns__getLightItemResponse(struct soap *soap, const char *tag, ns__getLightItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__getLightItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getLightItemResponse, sizeof(ns__getLightItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__getLightItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__getLightItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag__return1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((ns__getLightItemResponse*)a)->_return).soap_in(soap, NULL, "ns:light"))
				{	soap_flag__return1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__return1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__getLightItemResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getLightItemResponse, 0, sizeof(ns__getLightItemResponse), 0, soap_copy_ns__getLightItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__getLightItemResponse * SOAP_FMAC6 soap_new_ns__getLightItemResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getLightItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getLightItemResponse(struct soap *soap, ns__getLightItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__getLightItemResponse * SOAP_FMAC4 soap_instantiate_ns__getLightItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getLightItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getLightItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__getLightItemResponse;
		if (size)
			*size = sizeof(ns__getLightItemResponse);
	}
	else
	{	cp->ptr = (void*)new ns__getLightItemResponse[n];
		if (size)
			*size = n * sizeof(ns__getLightItemResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__getLightItemResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getLightItemResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__getLightItemResponse %p -> %p\n", q, p));
	*(ns__getLightItemResponse*)p = *(ns__getLightItemResponse*)q;
}

void ns__getLightPropertyItemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getLightPropertyItemResponse*)this)->_return.soap_serialize(soap);
}

void ns__getLightPropertyItemResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getLightPropertyItemResponse*)this)->_return.ns__light::soap_default(soap);
}

int ns__getLightPropertyItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getLightPropertyItemResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__getLightPropertyItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__getLightPropertyItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getLightPropertyItemResponse(struct soap *soap, const char *tag, int id, const ns__getLightPropertyItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getLightPropertyItemResponse), type);
	(((ns__getLightPropertyItemResponse*)a)->_return).soap_out(soap, "return", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__getLightPropertyItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__getLightPropertyItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__getLightPropertyItemResponse * SOAP_FMAC4 soap_get_ns__getLightPropertyItemResponse(struct soap *soap, ns__getLightPropertyItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getLightPropertyItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__getLightPropertyItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__getLightPropertyItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__getLightPropertyItemResponse * SOAP_FMAC4 soap_in_ns__getLightPropertyItemResponse(struct soap *soap, const char *tag, ns__getLightPropertyItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__getLightPropertyItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getLightPropertyItemResponse, sizeof(ns__getLightPropertyItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__getLightPropertyItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__getLightPropertyItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag__return1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((ns__getLightPropertyItemResponse*)a)->_return).soap_in(soap, NULL, "ns:light"))
				{	soap_flag__return1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__return1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__getLightPropertyItemResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getLightPropertyItemResponse, 0, sizeof(ns__getLightPropertyItemResponse), 0, soap_copy_ns__getLightPropertyItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__getLightPropertyItemResponse * SOAP_FMAC6 soap_new_ns__getLightPropertyItemResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getLightPropertyItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getLightPropertyItemResponse(struct soap *soap, ns__getLightPropertyItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__getLightPropertyItemResponse * SOAP_FMAC4 soap_instantiate_ns__getLightPropertyItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getLightPropertyItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getLightPropertyItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__getLightPropertyItemResponse;
		if (size)
			*size = sizeof(ns__getLightPropertyItemResponse);
	}
	else
	{	cp->ptr = (void*)new ns__getLightPropertyItemResponse[n];
		if (size)
			*size = n * sizeof(ns__getLightPropertyItemResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__getLightPropertyItemResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getLightPropertyItemResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__getLightPropertyItemResponse %p -> %p\n", q, p));
	*(ns__getLightPropertyItemResponse*)p = *(ns__getLightPropertyItemResponse*)q;
}

void ns__light::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd_LightProperty(soap, &((ns__light*)this)->devLightProperty);
	soap_serialize_string(soap, &((ns__light*)this)->lightZoneMainName);
	soap_serialize_string(soap, &((ns__light*)this)->lightZoneSubName);
	soap_embedded(soap, &((ns__light*)this)->dimmableLevel, SOAP_TYPE_cmxDeviceService_int);
}

void ns__light::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd_LightProperty(soap, &((ns__light*)this)->devLightProperty);
	soap_default_string(soap, &((ns__light*)this)->lightZoneMainName);
	soap_default_string(soap, &((ns__light*)this)->lightZoneSubName);
	soap_default_int(soap, &((ns__light*)this)->dimmableLevel);
	soap_default_ns__enum_light(soap, &((ns__light*)this)->model);
	soap_default_ns__enum_light(soap, &((ns__light*)this)->lightPower);
	soap_default_ns__enum_light(soap, &((ns__light*)this)->lightSwitchMode);
	soap_default_ns__enum_devError(soap, &((ns__light*)this)->lightDevError);
	soap_default_ns__lightFunc(soap, &((ns__light*)this)->func);
	soap_default_ns__enum_devInfo(soap, &((ns__rootDevice*)this)->dev);
	soap_default_ns__enum_devInfo(soap, &((ns__rootDevice*)this)->proto);
	soap_default_ns__enum_devInfo(soap, &((ns__rootDevice*)this)->intf);
	soap_default_unsignedInt(soap, &((ns__rootDevice*)this)->order);
}

int ns__light::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__light);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__light::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__light(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__light(struct soap *soap, const char *tag, int id, const ns__light *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__light), "ns:light");
	soap_out_ns__enum_devInfo(soap, "dev", -1, &(((ns__rootDevice*)a)->dev), "");
	soap_out_ns__enum_devInfo(soap, "proto", -1, &(((ns__rootDevice*)a)->proto), "");
	soap_out_ns__enum_devInfo(soap, "intf", -1, &(((ns__rootDevice*)a)->intf), "");
	soap_out_unsignedInt(soap, "order", -1, &(((ns__rootDevice*)a)->order), "");
	soap_out_xsd_LightProperty(soap, "devLightProperty", -1, &(((ns__light*)a)->devLightProperty), "");
	soap_out_string(soap, "lightZoneMainName", -1, &(((ns__light*)a)->lightZoneMainName), "");
	soap_out_string(soap, "lightZoneSubName", -1, &(((ns__light*)a)->lightZoneSubName), "");
	soap_out_int(soap, "dimmableLevel", -1, &(((ns__light*)a)->dimmableLevel), "");
	soap_out_ns__enum_light(soap, "model", -1, &(((ns__light*)a)->model), "");
	soap_out_ns__enum_light(soap, "lightPower", -1, &(((ns__light*)a)->lightPower), "");
	soap_out_ns__enum_light(soap, "lightSwitchMode", -1, &(((ns__light*)a)->lightSwitchMode), "");
	soap_out_ns__enum_devError(soap, "lightDevError", -1, &(((ns__light*)a)->lightDevError), "");
	soap_out_ns__lightFunc(soap, "func", -1, &(((ns__light*)a)->func), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__light::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__light(soap, this, tag, type);
}

SOAP_FMAC3 ns__light * SOAP_FMAC4 soap_get_ns__light(struct soap *soap, ns__light *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__light(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__light::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__light(soap, tag, this, type);
}

SOAP_FMAC3 ns__light * SOAP_FMAC4 soap_in_ns__light(struct soap *soap, const char *tag, ns__light *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__light *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__light, sizeof(ns__light), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__light)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__light *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_dev2 = 1, soap_flag_proto2 = 1, soap_flag_intf2 = 1, soap_flag_order2 = 1, soap_flag_devLightProperty1 = 1, soap_flag_lightZoneMainName1 = 1, soap_flag_lightZoneSubName1 = 1, soap_flag_dimmableLevel1 = 1, soap_flag_model1 = 1, soap_flag_lightPower1 = 1, soap_flag_lightSwitchMode1 = 1, soap_flag_lightDevError1 = 1, soap_flag_func1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dev2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devInfo(soap, "dev", &(((ns__rootDevice*)a)->dev), "ns:enum-devInfo"))
				{	soap_flag_dev2--;
					continue;
				}
			if (soap_flag_proto2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devInfo(soap, "proto", &(((ns__rootDevice*)a)->proto), "ns:enum-devInfo"))
				{	soap_flag_proto2--;
					continue;
				}
			if (soap_flag_intf2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devInfo(soap, "intf", &(((ns__rootDevice*)a)->intf), "ns:enum-devInfo"))
				{	soap_flag_intf2--;
					continue;
				}
			if (soap_flag_order2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "order", &(((ns__rootDevice*)a)->order), "xsd:unsignedInt"))
				{	soap_flag_order2--;
					continue;
				}
			if (soap_flag_devLightProperty1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd_LightProperty(soap, "devLightProperty", &(((ns__light*)a)->devLightProperty), "xsd-LightProperty"))
				{	soap_flag_devLightProperty1--;
					continue;
				}
			if (soap_flag_lightZoneMainName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lightZoneMainName", &(((ns__light*)a)->lightZoneMainName), "xsd:string"))
				{	soap_flag_lightZoneMainName1--;
					continue;
				}
			if (soap_flag_lightZoneSubName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lightZoneSubName", &(((ns__light*)a)->lightZoneSubName), "xsd:string"))
				{	soap_flag_lightZoneSubName1--;
					continue;
				}
			if (soap_flag_dimmableLevel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "dimmableLevel", &(((ns__light*)a)->dimmableLevel), "xsd:int"))
				{	soap_flag_dimmableLevel1--;
					continue;
				}
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_light(soap, "model", &(((ns__light*)a)->model), "ns:enum-light"))
				{	soap_flag_model1--;
					continue;
				}
			if (soap_flag_lightPower1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_light(soap, "lightPower", &(((ns__light*)a)->lightPower), "ns:enum-light"))
				{	soap_flag_lightPower1--;
					continue;
				}
			if (soap_flag_lightSwitchMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_light(soap, "lightSwitchMode", &(((ns__light*)a)->lightSwitchMode), "ns:enum-light"))
				{	soap_flag_lightSwitchMode1--;
					continue;
				}
			if (soap_flag_lightDevError1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devError(soap, "lightDevError", &(((ns__light*)a)->lightDevError), "ns:enum-devError"))
				{	soap_flag_lightDevError1--;
					continue;
				}
			if (soap_flag_func1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__lightFunc(soap, "func", &(((ns__light*)a)->func), "ns:lightFunc"))
				{	soap_flag_func1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dev2 > 0 || soap_flag_proto2 > 0 || soap_flag_intf2 > 0 || soap_flag_order2 > 0 || soap_flag_devLightProperty1 > 0 || soap_flag_dimmableLevel1 > 0 || soap_flag_model1 > 0 || soap_flag_lightPower1 > 0 || soap_flag_lightSwitchMode1 > 0 || soap_flag_lightDevError1 > 0 || soap_flag_func1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__light *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__light, 0, sizeof(ns__light), 0, soap_copy_ns__light);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__light * SOAP_FMAC6 soap_new_ns__light(struct soap *soap, int n)
{	return soap_instantiate_ns__light(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__light(struct soap *soap, ns__light *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__light * SOAP_FMAC4 soap_instantiate_ns__light(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__light(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__light, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__light;
		if (size)
			*size = sizeof(ns__light);
	}
	else
	{	cp->ptr = (void*)new ns__light[n];
		if (size)
			*size = n * sizeof(ns__light);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__light*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__light(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__light %p -> %p\n", q, p));
	*(ns__light*)p = *(ns__light*)q;
}

void ns__setBoilerResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
}

void ns__setBoilerResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

int ns__setBoilerResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__setBoilerResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__setBoilerResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__setBoilerResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setBoilerResponse(struct soap *soap, const char *tag, int id, const ns__setBoilerResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__setBoilerResponse), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__setBoilerResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__setBoilerResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__setBoilerResponse * SOAP_FMAC4 soap_get_ns__setBoilerResponse(struct soap *soap, ns__setBoilerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setBoilerResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__setBoilerResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__setBoilerResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__setBoilerResponse * SOAP_FMAC4 soap_in_ns__setBoilerResponse(struct soap *soap, const char *tag, ns__setBoilerResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__setBoilerResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__setBoilerResponse, sizeof(ns__setBoilerResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__setBoilerResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__setBoilerResponse *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__setBoilerResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__setBoilerResponse, 0, sizeof(ns__setBoilerResponse), 0, soap_copy_ns__setBoilerResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__setBoilerResponse * SOAP_FMAC6 soap_new_ns__setBoilerResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__setBoilerResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setBoilerResponse(struct soap *soap, ns__setBoilerResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__setBoilerResponse * SOAP_FMAC4 soap_instantiate_ns__setBoilerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setBoilerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__setBoilerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__setBoilerResponse;
		if (size)
			*size = sizeof(ns__setBoilerResponse);
	}
	else
	{	cp->ptr = (void*)new ns__setBoilerResponse[n];
		if (size)
			*size = n * sizeof(ns__setBoilerResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__setBoilerResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setBoilerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__setBoilerResponse %p -> %p\n", q, p));
	*(ns__setBoilerResponse*)p = *(ns__setBoilerResponse*)q;
}

void ns__getBoilerResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getBoilerResponse*)this)->_return.soap_serialize(soap);
}

void ns__getBoilerResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getBoilerResponse*)this)->_return.ns__boiler::soap_default(soap);
}

int ns__getBoilerResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getBoilerResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__getBoilerResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__getBoilerResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getBoilerResponse(struct soap *soap, const char *tag, int id, const ns__getBoilerResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getBoilerResponse), type);
	(((ns__getBoilerResponse*)a)->_return).soap_out(soap, "return", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__getBoilerResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__getBoilerResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__getBoilerResponse * SOAP_FMAC4 soap_get_ns__getBoilerResponse(struct soap *soap, ns__getBoilerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getBoilerResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__getBoilerResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__getBoilerResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__getBoilerResponse * SOAP_FMAC4 soap_in_ns__getBoilerResponse(struct soap *soap, const char *tag, ns__getBoilerResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__getBoilerResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getBoilerResponse, sizeof(ns__getBoilerResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__getBoilerResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__getBoilerResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag__return1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((ns__getBoilerResponse*)a)->_return).soap_in(soap, NULL, "ns:boiler"))
				{	soap_flag__return1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__return1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__getBoilerResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getBoilerResponse, 0, sizeof(ns__getBoilerResponse), 0, soap_copy_ns__getBoilerResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__getBoilerResponse * SOAP_FMAC6 soap_new_ns__getBoilerResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getBoilerResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getBoilerResponse(struct soap *soap, ns__getBoilerResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__getBoilerResponse * SOAP_FMAC4 soap_instantiate_ns__getBoilerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getBoilerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getBoilerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__getBoilerResponse;
		if (size)
			*size = sizeof(ns__getBoilerResponse);
	}
	else
	{	cp->ptr = (void*)new ns__getBoilerResponse[n];
		if (size)
			*size = n * sizeof(ns__getBoilerResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__getBoilerResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getBoilerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__getBoilerResponse %p -> %p\n", q, p));
	*(ns__getBoilerResponse*)p = *(ns__getBoilerResponse*)q;
}

void ns__getBoilerItemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getBoilerItemResponse*)this)->_return.soap_serialize(soap);
}

void ns__getBoilerItemResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getBoilerItemResponse*)this)->_return.ns__boiler::soap_default(soap);
}

int ns__getBoilerItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getBoilerItemResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__getBoilerItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__getBoilerItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getBoilerItemResponse(struct soap *soap, const char *tag, int id, const ns__getBoilerItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getBoilerItemResponse), type);
	(((ns__getBoilerItemResponse*)a)->_return).soap_out(soap, "return", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__getBoilerItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__getBoilerItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__getBoilerItemResponse * SOAP_FMAC4 soap_get_ns__getBoilerItemResponse(struct soap *soap, ns__getBoilerItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getBoilerItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__getBoilerItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__getBoilerItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__getBoilerItemResponse * SOAP_FMAC4 soap_in_ns__getBoilerItemResponse(struct soap *soap, const char *tag, ns__getBoilerItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__getBoilerItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getBoilerItemResponse, sizeof(ns__getBoilerItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__getBoilerItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__getBoilerItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag__return1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((ns__getBoilerItemResponse*)a)->_return).soap_in(soap, NULL, "ns:boiler"))
				{	soap_flag__return1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__return1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__getBoilerItemResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getBoilerItemResponse, 0, sizeof(ns__getBoilerItemResponse), 0, soap_copy_ns__getBoilerItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__getBoilerItemResponse * SOAP_FMAC6 soap_new_ns__getBoilerItemResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getBoilerItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getBoilerItemResponse(struct soap *soap, ns__getBoilerItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__getBoilerItemResponse * SOAP_FMAC4 soap_instantiate_ns__getBoilerItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getBoilerItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getBoilerItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__getBoilerItemResponse;
		if (size)
			*size = sizeof(ns__getBoilerItemResponse);
	}
	else
	{	cp->ptr = (void*)new ns__getBoilerItemResponse[n];
		if (size)
			*size = n * sizeof(ns__getBoilerItemResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__getBoilerItemResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getBoilerItemResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__getBoilerItemResponse %p -> %p\n", q, p));
	*(ns__getBoilerItemResponse*)p = *(ns__getBoilerItemResponse*)q;
}

void ns__getBoilerPropertyItemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getBoilerPropertyItemResponse*)this)->_return.soap_serialize(soap);
}

void ns__getBoilerPropertyItemResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getBoilerPropertyItemResponse*)this)->_return.ns__boiler::soap_default(soap);
}

int ns__getBoilerPropertyItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getBoilerPropertyItemResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__getBoilerPropertyItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__getBoilerPropertyItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getBoilerPropertyItemResponse(struct soap *soap, const char *tag, int id, const ns__getBoilerPropertyItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getBoilerPropertyItemResponse), type);
	(((ns__getBoilerPropertyItemResponse*)a)->_return).soap_out(soap, "return", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__getBoilerPropertyItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__getBoilerPropertyItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__getBoilerPropertyItemResponse * SOAP_FMAC4 soap_get_ns__getBoilerPropertyItemResponse(struct soap *soap, ns__getBoilerPropertyItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getBoilerPropertyItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__getBoilerPropertyItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__getBoilerPropertyItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__getBoilerPropertyItemResponse * SOAP_FMAC4 soap_in_ns__getBoilerPropertyItemResponse(struct soap *soap, const char *tag, ns__getBoilerPropertyItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__getBoilerPropertyItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getBoilerPropertyItemResponse, sizeof(ns__getBoilerPropertyItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__getBoilerPropertyItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__getBoilerPropertyItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag__return1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((ns__getBoilerPropertyItemResponse*)a)->_return).soap_in(soap, NULL, "ns:boiler"))
				{	soap_flag__return1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__return1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__getBoilerPropertyItemResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getBoilerPropertyItemResponse, 0, sizeof(ns__getBoilerPropertyItemResponse), 0, soap_copy_ns__getBoilerPropertyItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__getBoilerPropertyItemResponse * SOAP_FMAC6 soap_new_ns__getBoilerPropertyItemResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getBoilerPropertyItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getBoilerPropertyItemResponse(struct soap *soap, ns__getBoilerPropertyItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__getBoilerPropertyItemResponse * SOAP_FMAC4 soap_instantiate_ns__getBoilerPropertyItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getBoilerPropertyItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getBoilerPropertyItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__getBoilerPropertyItemResponse;
		if (size)
			*size = sizeof(ns__getBoilerPropertyItemResponse);
	}
	else
	{	cp->ptr = (void*)new ns__getBoilerPropertyItemResponse[n];
		if (size)
			*size = n * sizeof(ns__getBoilerPropertyItemResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__getBoilerPropertyItemResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getBoilerPropertyItemResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__getBoilerPropertyItemResponse %p -> %p\n", q, p));
	*(ns__getBoilerPropertyItemResponse*)p = *(ns__getBoilerPropertyItemResponse*)q;
}

void ns__boiler::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd_BoilerProperty(soap, &((ns__boiler*)this)->devBoilerProperty);
	soap_serialize_string(soap, &((ns__boiler*)this)->boilerZoneName);
	soap_embedded(soap, &((ns__boiler*)this)->boilerRequestedTemperature, SOAP_TYPE_cmxDeviceService_int);
	soap_embedded(soap, &((ns__boiler*)this)->boilerCurrentTemperature, SOAP_TYPE_cmxDeviceService_int);
	soap_embedded(soap, &((ns__boiler*)this)->boilerHeatingWaterTemperature, SOAP_TYPE_cmxDeviceService_int);
}

void ns__boiler::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd_BoilerProperty(soap, &((ns__boiler*)this)->devBoilerProperty);
	soap_default_string(soap, &((ns__boiler*)this)->boilerZoneName);
	soap_default_int(soap, &((ns__boiler*)this)->boilerRequestedTemperature);
	soap_default_int(soap, &((ns__boiler*)this)->boilerCurrentTemperature);
	soap_default_int(soap, &((ns__boiler*)this)->boilerHeatingWaterTemperature);
	soap_default_ns__enum_boiler(soap, &((ns__boiler*)this)->model);
	soap_default_ns__enum_boiler(soap, &((ns__boiler*)this)->boilerPower);
	soap_default_ns__enum_boiler(soap, &((ns__boiler*)this)->boilerHeatingPower);
	soap_default_ns__enum_boiler(soap, &((ns__boiler*)this)->boilerOutMode);
	soap_default_ns__enum_boiler(soap, &((ns__boiler*)this)->boilerDipSwitchMode);
	soap_default_ns__enum_devError(soap, &((ns__boiler*)this)->boilerDevError);
	soap_default_ns__boilerFunc(soap, &((ns__boiler*)this)->func);
	soap_default_ns__enum_devInfo(soap, &((ns__rootDevice*)this)->dev);
	soap_default_ns__enum_devInfo(soap, &((ns__rootDevice*)this)->proto);
	soap_default_ns__enum_devInfo(soap, &((ns__rootDevice*)this)->intf);
	soap_default_unsignedInt(soap, &((ns__rootDevice*)this)->order);
}

int ns__boiler::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__boiler);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__boiler::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__boiler(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__boiler(struct soap *soap, const char *tag, int id, const ns__boiler *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__boiler), "ns:boiler");
	soap_out_ns__enum_devInfo(soap, "dev", -1, &(((ns__rootDevice*)a)->dev), "");
	soap_out_ns__enum_devInfo(soap, "proto", -1, &(((ns__rootDevice*)a)->proto), "");
	soap_out_ns__enum_devInfo(soap, "intf", -1, &(((ns__rootDevice*)a)->intf), "");
	soap_out_unsignedInt(soap, "order", -1, &(((ns__rootDevice*)a)->order), "");
	soap_out_xsd_BoilerProperty(soap, "devBoilerProperty", -1, &(((ns__boiler*)a)->devBoilerProperty), "");
	soap_out_string(soap, "boilerZoneName", -1, &(((ns__boiler*)a)->boilerZoneName), "");
	soap_out_int(soap, "boilerRequestedTemperature", -1, &(((ns__boiler*)a)->boilerRequestedTemperature), "");
	soap_out_int(soap, "boilerCurrentTemperature", -1, &(((ns__boiler*)a)->boilerCurrentTemperature), "");
	soap_out_int(soap, "boilerHeatingWaterTemperature", -1, &(((ns__boiler*)a)->boilerHeatingWaterTemperature), "");
	soap_out_ns__enum_boiler(soap, "model", -1, &(((ns__boiler*)a)->model), "");
	soap_out_ns__enum_boiler(soap, "boilerPower", -1, &(((ns__boiler*)a)->boilerPower), "");
	soap_out_ns__enum_boiler(soap, "boilerHeatingPower", -1, &(((ns__boiler*)a)->boilerHeatingPower), "");
	soap_out_ns__enum_boiler(soap, "boilerOutMode", -1, &(((ns__boiler*)a)->boilerOutMode), "");
	soap_out_ns__enum_boiler(soap, "boilerDipSwitchMode", -1, &(((ns__boiler*)a)->boilerDipSwitchMode), "");
	soap_out_ns__enum_devError(soap, "boilerDevError", -1, &(((ns__boiler*)a)->boilerDevError), "");
	soap_out_ns__boilerFunc(soap, "func", -1, &(((ns__boiler*)a)->func), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__boiler::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__boiler(soap, this, tag, type);
}

SOAP_FMAC3 ns__boiler * SOAP_FMAC4 soap_get_ns__boiler(struct soap *soap, ns__boiler *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__boiler(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__boiler::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__boiler(soap, tag, this, type);
}

SOAP_FMAC3 ns__boiler * SOAP_FMAC4 soap_in_ns__boiler(struct soap *soap, const char *tag, ns__boiler *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__boiler *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__boiler, sizeof(ns__boiler), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__boiler)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__boiler *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_dev2 = 1, soap_flag_proto2 = 1, soap_flag_intf2 = 1, soap_flag_order2 = 1, soap_flag_devBoilerProperty1 = 1, soap_flag_boilerZoneName1 = 1, soap_flag_boilerRequestedTemperature1 = 1, soap_flag_boilerCurrentTemperature1 = 1, soap_flag_boilerHeatingWaterTemperature1 = 1, soap_flag_model1 = 1, soap_flag_boilerPower1 = 1, soap_flag_boilerHeatingPower1 = 1, soap_flag_boilerOutMode1 = 1, soap_flag_boilerDipSwitchMode1 = 1, soap_flag_boilerDevError1 = 1, soap_flag_func1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dev2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devInfo(soap, "dev", &(((ns__rootDevice*)a)->dev), "ns:enum-devInfo"))
				{	soap_flag_dev2--;
					continue;
				}
			if (soap_flag_proto2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devInfo(soap, "proto", &(((ns__rootDevice*)a)->proto), "ns:enum-devInfo"))
				{	soap_flag_proto2--;
					continue;
				}
			if (soap_flag_intf2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devInfo(soap, "intf", &(((ns__rootDevice*)a)->intf), "ns:enum-devInfo"))
				{	soap_flag_intf2--;
					continue;
				}
			if (soap_flag_order2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "order", &(((ns__rootDevice*)a)->order), "xsd:unsignedInt"))
				{	soap_flag_order2--;
					continue;
				}
			if (soap_flag_devBoilerProperty1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd_BoilerProperty(soap, "devBoilerProperty", &(((ns__boiler*)a)->devBoilerProperty), "xsd-BoilerProperty"))
				{	soap_flag_devBoilerProperty1--;
					continue;
				}
			if (soap_flag_boilerZoneName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "boilerZoneName", &(((ns__boiler*)a)->boilerZoneName), "xsd:string"))
				{	soap_flag_boilerZoneName1--;
					continue;
				}
			if (soap_flag_boilerRequestedTemperature1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "boilerRequestedTemperature", &(((ns__boiler*)a)->boilerRequestedTemperature), "xsd:int"))
				{	soap_flag_boilerRequestedTemperature1--;
					continue;
				}
			if (soap_flag_boilerCurrentTemperature1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "boilerCurrentTemperature", &(((ns__boiler*)a)->boilerCurrentTemperature), "xsd:int"))
				{	soap_flag_boilerCurrentTemperature1--;
					continue;
				}
			if (soap_flag_boilerHeatingWaterTemperature1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "boilerHeatingWaterTemperature", &(((ns__boiler*)a)->boilerHeatingWaterTemperature), "xsd:int"))
				{	soap_flag_boilerHeatingWaterTemperature1--;
					continue;
				}
			if (soap_flag_model1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_boiler(soap, "model", &(((ns__boiler*)a)->model), "ns:enum-boiler"))
				{	soap_flag_model1--;
					continue;
				}
			if (soap_flag_boilerPower1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_boiler(soap, "boilerPower", &(((ns__boiler*)a)->boilerPower), "ns:enum-boiler"))
				{	soap_flag_boilerPower1--;
					continue;
				}
			if (soap_flag_boilerHeatingPower1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_boiler(soap, "boilerHeatingPower", &(((ns__boiler*)a)->boilerHeatingPower), "ns:enum-boiler"))
				{	soap_flag_boilerHeatingPower1--;
					continue;
				}
			if (soap_flag_boilerOutMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_boiler(soap, "boilerOutMode", &(((ns__boiler*)a)->boilerOutMode), "ns:enum-boiler"))
				{	soap_flag_boilerOutMode1--;
					continue;
				}
			if (soap_flag_boilerDipSwitchMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_boiler(soap, "boilerDipSwitchMode", &(((ns__boiler*)a)->boilerDipSwitchMode), "ns:enum-boiler"))
				{	soap_flag_boilerDipSwitchMode1--;
					continue;
				}
			if (soap_flag_boilerDevError1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devError(soap, "boilerDevError", &(((ns__boiler*)a)->boilerDevError), "ns:enum-devError"))
				{	soap_flag_boilerDevError1--;
					continue;
				}
			if (soap_flag_func1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__boilerFunc(soap, "func", &(((ns__boiler*)a)->func), "ns:boilerFunc"))
				{	soap_flag_func1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dev2 > 0 || soap_flag_proto2 > 0 || soap_flag_intf2 > 0 || soap_flag_order2 > 0 || soap_flag_devBoilerProperty1 > 0 || soap_flag_boilerRequestedTemperature1 > 0 || soap_flag_boilerCurrentTemperature1 > 0 || soap_flag_boilerHeatingWaterTemperature1 > 0 || soap_flag_model1 > 0 || soap_flag_boilerPower1 > 0 || soap_flag_boilerHeatingPower1 > 0 || soap_flag_boilerOutMode1 > 0 || soap_flag_boilerDipSwitchMode1 > 0 || soap_flag_boilerDevError1 > 0 || soap_flag_func1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__boiler *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__boiler, 0, sizeof(ns__boiler), 0, soap_copy_ns__boiler);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__boiler * SOAP_FMAC6 soap_new_ns__boiler(struct soap *soap, int n)
{	return soap_instantiate_ns__boiler(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__boiler(struct soap *soap, ns__boiler *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__boiler * SOAP_FMAC4 soap_instantiate_ns__boiler(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__boiler(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__boiler, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__boiler;
		if (size)
			*size = sizeof(ns__boiler);
	}
	else
	{	cp->ptr = (void*)new ns__boiler[n];
		if (size)
			*size = n * sizeof(ns__boiler);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__boiler*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__boiler(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__boiler %p -> %p\n", q, p));
	*(ns__boiler*)p = *(ns__boiler*)q;
}

void ns__setDeviceCategoryResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
}

void ns__setDeviceCategoryResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

int ns__setDeviceCategoryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__setDeviceCategoryResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__setDeviceCategoryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__setDeviceCategoryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setDeviceCategoryResponse(struct soap *soap, const char *tag, int id, const ns__setDeviceCategoryResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__setDeviceCategoryResponse), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__setDeviceCategoryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__setDeviceCategoryResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__setDeviceCategoryResponse * SOAP_FMAC4 soap_get_ns__setDeviceCategoryResponse(struct soap *soap, ns__setDeviceCategoryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setDeviceCategoryResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__setDeviceCategoryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__setDeviceCategoryResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__setDeviceCategoryResponse * SOAP_FMAC4 soap_in_ns__setDeviceCategoryResponse(struct soap *soap, const char *tag, ns__setDeviceCategoryResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__setDeviceCategoryResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__setDeviceCategoryResponse, sizeof(ns__setDeviceCategoryResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__setDeviceCategoryResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__setDeviceCategoryResponse *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__setDeviceCategoryResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__setDeviceCategoryResponse, 0, sizeof(ns__setDeviceCategoryResponse), 0, soap_copy_ns__setDeviceCategoryResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__setDeviceCategoryResponse * SOAP_FMAC6 soap_new_ns__setDeviceCategoryResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__setDeviceCategoryResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setDeviceCategoryResponse(struct soap *soap, ns__setDeviceCategoryResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__setDeviceCategoryResponse * SOAP_FMAC4 soap_instantiate_ns__setDeviceCategoryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setDeviceCategoryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__setDeviceCategoryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__setDeviceCategoryResponse;
		if (size)
			*size = sizeof(ns__setDeviceCategoryResponse);
	}
	else
	{	cp->ptr = (void*)new ns__setDeviceCategoryResponse[n];
		if (size)
			*size = n * sizeof(ns__setDeviceCategoryResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__setDeviceCategoryResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setDeviceCategoryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__setDeviceCategoryResponse %p -> %p\n", q, p));
	*(ns__setDeviceCategoryResponse*)p = *(ns__setDeviceCategoryResponse*)q;
}

void ns__getDeviceCategoryResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getDeviceCategoryResponse*)this)->_return.soap_serialize(soap);
}

void ns__getDeviceCategoryResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getDeviceCategoryResponse*)this)->_return.ns__deviceCategory::soap_default(soap);
}

int ns__getDeviceCategoryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__getDeviceCategoryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__getDeviceCategoryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getDeviceCategoryResponse(struct soap *soap, const char *tag, int id, const ns__getDeviceCategoryResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryResponse), type);
	(((ns__getDeviceCategoryResponse*)a)->_return).soap_out(soap, "return", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__getDeviceCategoryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__getDeviceCategoryResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__getDeviceCategoryResponse * SOAP_FMAC4 soap_get_ns__getDeviceCategoryResponse(struct soap *soap, ns__getDeviceCategoryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getDeviceCategoryResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__getDeviceCategoryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__getDeviceCategoryResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__getDeviceCategoryResponse * SOAP_FMAC4 soap_in_ns__getDeviceCategoryResponse(struct soap *soap, const char *tag, ns__getDeviceCategoryResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__getDeviceCategoryResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryResponse, sizeof(ns__getDeviceCategoryResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__getDeviceCategoryResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag__return1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((ns__getDeviceCategoryResponse*)a)->_return).soap_in(soap, NULL, "ns:deviceCategory"))
				{	soap_flag__return1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__return1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__getDeviceCategoryResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryResponse, 0, sizeof(ns__getDeviceCategoryResponse), 0, soap_copy_ns__getDeviceCategoryResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__getDeviceCategoryResponse * SOAP_FMAC6 soap_new_ns__getDeviceCategoryResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getDeviceCategoryResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getDeviceCategoryResponse(struct soap *soap, ns__getDeviceCategoryResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__getDeviceCategoryResponse * SOAP_FMAC4 soap_instantiate_ns__getDeviceCategoryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getDeviceCategoryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__getDeviceCategoryResponse;
		if (size)
			*size = sizeof(ns__getDeviceCategoryResponse);
	}
	else
	{	cp->ptr = (void*)new ns__getDeviceCategoryResponse[n];
		if (size)
			*size = n * sizeof(ns__getDeviceCategoryResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__getDeviceCategoryResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getDeviceCategoryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__getDeviceCategoryResponse %p -> %p\n", q, p));
	*(ns__getDeviceCategoryResponse*)p = *(ns__getDeviceCategoryResponse*)q;
}

void ns__getDeviceCategoryItemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getDeviceCategoryItemResponse*)this)->_return.soap_serialize(soap);
}

void ns__getDeviceCategoryItemResponse::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((ns__getDeviceCategoryItemResponse*)this)->_return.ns__deviceCategory::soap_default(soap);
}

int ns__getDeviceCategoryItemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryItemResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__getDeviceCategoryItemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__getDeviceCategoryItemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getDeviceCategoryItemResponse(struct soap *soap, const char *tag, int id, const ns__getDeviceCategoryItemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryItemResponse), type);
	(((ns__getDeviceCategoryItemResponse*)a)->_return).soap_out(soap, "return", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__getDeviceCategoryItemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__getDeviceCategoryItemResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns__getDeviceCategoryItemResponse * SOAP_FMAC4 soap_get_ns__getDeviceCategoryItemResponse(struct soap *soap, ns__getDeviceCategoryItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getDeviceCategoryItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__getDeviceCategoryItemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__getDeviceCategoryItemResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns__getDeviceCategoryItemResponse * SOAP_FMAC4 soap_in_ns__getDeviceCategoryItemResponse(struct soap *soap, const char *tag, ns__getDeviceCategoryItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__getDeviceCategoryItemResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryItemResponse, sizeof(ns__getDeviceCategoryItemResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryItemResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__getDeviceCategoryItemResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag__return1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((ns__getDeviceCategoryItemResponse*)a)->_return).soap_in(soap, NULL, "ns:deviceCategory"))
				{	soap_flag__return1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__return1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__getDeviceCategoryItemResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryItemResponse, 0, sizeof(ns__getDeviceCategoryItemResponse), 0, soap_copy_ns__getDeviceCategoryItemResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__getDeviceCategoryItemResponse * SOAP_FMAC6 soap_new_ns__getDeviceCategoryItemResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getDeviceCategoryItemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getDeviceCategoryItemResponse(struct soap *soap, ns__getDeviceCategoryItemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__getDeviceCategoryItemResponse * SOAP_FMAC4 soap_instantiate_ns__getDeviceCategoryItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getDeviceCategoryItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__getDeviceCategoryItemResponse;
		if (size)
			*size = sizeof(ns__getDeviceCategoryItemResponse);
	}
	else
	{	cp->ptr = (void*)new ns__getDeviceCategoryItemResponse[n];
		if (size)
			*size = n * sizeof(ns__getDeviceCategoryItemResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__getDeviceCategoryItemResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getDeviceCategoryItemResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__getDeviceCategoryItemResponse %p -> %p\n", q, p));
	*(ns__getDeviceCategoryItemResponse*)p = *(ns__getDeviceCategoryItemResponse*)q;
}

void ns__deviceCategory::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd_devCategory(soap, &((ns__deviceCategory*)this)->enable_device_category);
}

void ns__deviceCategory::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd_devCategory(soap, &((ns__deviceCategory*)this)->enable_device_category);
	soap_default_ns__enum_config_Common_Error(soap, &((ns__deviceCategory*)this)->commonError);
	soap_default_ns__enum_devError(soap, &((ns__deviceCategory*)this)->boilerDeviceError);
	soap_default_ns__enum_devError(soap, &((ns__deviceCategory*)this)->lightDeviceError);
	soap_default_ns__enum_devError(soap, &((ns__deviceCategory*)this)->gasDeviceError);
	soap_default_ns__enum_devError(soap, &((ns__deviceCategory*)this)->doorLockDeviceError);
	soap_default_ns__enum_devError(soap, &((ns__deviceCategory*)this)->acConsentDeviceError);
	soap_default_ns__enum_devError(soap, &((ns__deviceCategory*)this)->curtainDeviceError);
	soap_default_ns__enum_devError(soap, &((ns__deviceCategory*)this)->bundleLightDeviceError);
	soap_default_ns__enum_devError(soap, &((ns__deviceCategory*)this)->fanSystemDeviceError);
	soap_default_ns__enum_devError(soap, &((ns__deviceCategory*)this)->airconDeviceError);
	soap_default_ns__enum_devError(soap, &((ns__deviceCategory*)this)->rfDeviceError);
	soap_default_ns__enum_devError(soap, &((ns__deviceCategory*)this)->systemAirconDeviceError);
	soap_default_ns__enum_device_connect_check(soap, &((ns__deviceCategory*)this)->deviceConnectionCheck);
	soap_default_ns__deviceCategoryFunc(soap, &((ns__deviceCategory*)this)->func);
}

int ns__deviceCategory::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__deviceCategory);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__deviceCategory::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__deviceCategory(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__deviceCategory(struct soap *soap, const char *tag, int id, const ns__deviceCategory *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__deviceCategory), type);
	soap_out_xsd_devCategory(soap, "enable-device-category", -1, &(((ns__deviceCategory*)a)->enable_device_category), "");
	soap_out_ns__enum_config_Common_Error(soap, "commonError", -1, &(((ns__deviceCategory*)a)->commonError), "");
	soap_out_ns__enum_devError(soap, "boilerDeviceError", -1, &(((ns__deviceCategory*)a)->boilerDeviceError), "");
	soap_out_ns__enum_devError(soap, "lightDeviceError", -1, &(((ns__deviceCategory*)a)->lightDeviceError), "");
	soap_out_ns__enum_devError(soap, "gasDeviceError", -1, &(((ns__deviceCategory*)a)->gasDeviceError), "");
	soap_out_ns__enum_devError(soap, "doorLockDeviceError", -1, &(((ns__deviceCategory*)a)->doorLockDeviceError), "");
	soap_out_ns__enum_devError(soap, "acConsentDeviceError", -1, &(((ns__deviceCategory*)a)->acConsentDeviceError), "");
	soap_out_ns__enum_devError(soap, "curtainDeviceError", -1, &(((ns__deviceCategory*)a)->curtainDeviceError), "");
	soap_out_ns__enum_devError(soap, "bundleLightDeviceError", -1, &(((ns__deviceCategory*)a)->bundleLightDeviceError), "");
	soap_out_ns__enum_devError(soap, "fanSystemDeviceError", -1, &(((ns__deviceCategory*)a)->fanSystemDeviceError), "");
	soap_out_ns__enum_devError(soap, "airconDeviceError", -1, &(((ns__deviceCategory*)a)->airconDeviceError), "");
	soap_out_ns__enum_devError(soap, "rfDeviceError", -1, &(((ns__deviceCategory*)a)->rfDeviceError), "");
	soap_out_ns__enum_devError(soap, "systemAirconDeviceError", -1, &(((ns__deviceCategory*)a)->systemAirconDeviceError), "");
	soap_out_ns__enum_device_connect_check(soap, "deviceConnectionCheck", -1, &(((ns__deviceCategory*)a)->deviceConnectionCheck), "");
	soap_out_ns__deviceCategoryFunc(soap, "func", -1, &(((ns__deviceCategory*)a)->func), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__deviceCategory::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__deviceCategory(soap, this, tag, type);
}

SOAP_FMAC3 ns__deviceCategory * SOAP_FMAC4 soap_get_ns__deviceCategory(struct soap *soap, ns__deviceCategory *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__deviceCategory(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__deviceCategory::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__deviceCategory(soap, tag, this, type);
}

SOAP_FMAC3 ns__deviceCategory * SOAP_FMAC4 soap_in_ns__deviceCategory(struct soap *soap, const char *tag, ns__deviceCategory *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__deviceCategory *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__deviceCategory, sizeof(ns__deviceCategory), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__deviceCategory)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__deviceCategory *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_enable_device_category1 = 1, soap_flag_commonError1 = 1, soap_flag_boilerDeviceError1 = 1, soap_flag_lightDeviceError1 = 1, soap_flag_gasDeviceError1 = 1, soap_flag_doorLockDeviceError1 = 1, soap_flag_acConsentDeviceError1 = 1, soap_flag_curtainDeviceError1 = 1, soap_flag_bundleLightDeviceError1 = 1, soap_flag_fanSystemDeviceError1 = 1, soap_flag_airconDeviceError1 = 1, soap_flag_rfDeviceError1 = 1, soap_flag_systemAirconDeviceError1 = 1, soap_flag_deviceConnectionCheck1 = 1, soap_flag_func1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_enable_device_category1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd_devCategory(soap, "enable-device-category", &(((ns__deviceCategory*)a)->enable_device_category), "xsd-devCategory"))
				{	soap_flag_enable_device_category1--;
					continue;
				}
			if (soap_flag_commonError1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_config_Common_Error(soap, "commonError", &(((ns__deviceCategory*)a)->commonError), "ns:enum-config-Common-Error"))
				{	soap_flag_commonError1--;
					continue;
				}
			if (soap_flag_boilerDeviceError1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devError(soap, "boilerDeviceError", &(((ns__deviceCategory*)a)->boilerDeviceError), "ns:enum-devError"))
				{	soap_flag_boilerDeviceError1--;
					continue;
				}
			if (soap_flag_lightDeviceError1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devError(soap, "lightDeviceError", &(((ns__deviceCategory*)a)->lightDeviceError), "ns:enum-devError"))
				{	soap_flag_lightDeviceError1--;
					continue;
				}
			if (soap_flag_gasDeviceError1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devError(soap, "gasDeviceError", &(((ns__deviceCategory*)a)->gasDeviceError), "ns:enum-devError"))
				{	soap_flag_gasDeviceError1--;
					continue;
				}
			if (soap_flag_doorLockDeviceError1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devError(soap, "doorLockDeviceError", &(((ns__deviceCategory*)a)->doorLockDeviceError), "ns:enum-devError"))
				{	soap_flag_doorLockDeviceError1--;
					continue;
				}
			if (soap_flag_acConsentDeviceError1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devError(soap, "acConsentDeviceError", &(((ns__deviceCategory*)a)->acConsentDeviceError), "ns:enum-devError"))
				{	soap_flag_acConsentDeviceError1--;
					continue;
				}
			if (soap_flag_curtainDeviceError1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devError(soap, "curtainDeviceError", &(((ns__deviceCategory*)a)->curtainDeviceError), "ns:enum-devError"))
				{	soap_flag_curtainDeviceError1--;
					continue;
				}
			if (soap_flag_bundleLightDeviceError1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devError(soap, "bundleLightDeviceError", &(((ns__deviceCategory*)a)->bundleLightDeviceError), "ns:enum-devError"))
				{	soap_flag_bundleLightDeviceError1--;
					continue;
				}
			if (soap_flag_fanSystemDeviceError1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devError(soap, "fanSystemDeviceError", &(((ns__deviceCategory*)a)->fanSystemDeviceError), "ns:enum-devError"))
				{	soap_flag_fanSystemDeviceError1--;
					continue;
				}
			if (soap_flag_airconDeviceError1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devError(soap, "airconDeviceError", &(((ns__deviceCategory*)a)->airconDeviceError), "ns:enum-devError"))
				{	soap_flag_airconDeviceError1--;
					continue;
				}
			if (soap_flag_rfDeviceError1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devError(soap, "rfDeviceError", &(((ns__deviceCategory*)a)->rfDeviceError), "ns:enum-devError"))
				{	soap_flag_rfDeviceError1--;
					continue;
				}
			if (soap_flag_systemAirconDeviceError1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devError(soap, "systemAirconDeviceError", &(((ns__deviceCategory*)a)->systemAirconDeviceError), "ns:enum-devError"))
				{	soap_flag_systemAirconDeviceError1--;
					continue;
				}
			if (soap_flag_deviceConnectionCheck1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_device_connect_check(soap, "deviceConnectionCheck", &(((ns__deviceCategory*)a)->deviceConnectionCheck), "ns:enum-device-connect-check"))
				{	soap_flag_deviceConnectionCheck1--;
					continue;
				}
			if (soap_flag_func1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__deviceCategoryFunc(soap, "func", &(((ns__deviceCategory*)a)->func), "ns:deviceCategoryFunc"))
				{	soap_flag_func1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_enable_device_category1 > 0 || soap_flag_commonError1 > 0 || soap_flag_boilerDeviceError1 > 0 || soap_flag_lightDeviceError1 > 0 || soap_flag_gasDeviceError1 > 0 || soap_flag_doorLockDeviceError1 > 0 || soap_flag_acConsentDeviceError1 > 0 || soap_flag_curtainDeviceError1 > 0 || soap_flag_bundleLightDeviceError1 > 0 || soap_flag_fanSystemDeviceError1 > 0 || soap_flag_airconDeviceError1 > 0 || soap_flag_rfDeviceError1 > 0 || soap_flag_systemAirconDeviceError1 > 0 || soap_flag_deviceConnectionCheck1 > 0 || soap_flag_func1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__deviceCategory *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__deviceCategory, 0, sizeof(ns__deviceCategory), 0, soap_copy_ns__deviceCategory);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__deviceCategory * SOAP_FMAC6 soap_new_ns__deviceCategory(struct soap *soap, int n)
{	return soap_instantiate_ns__deviceCategory(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__deviceCategory(struct soap *soap, ns__deviceCategory *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__deviceCategory * SOAP_FMAC4 soap_instantiate_ns__deviceCategory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__deviceCategory(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__deviceCategory, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns__deviceCategory;
		if (size)
			*size = sizeof(ns__deviceCategory);
	}
	else
	{	cp->ptr = (void*)new ns__deviceCategory[n];
		if (size)
			*size = n * sizeof(ns__deviceCategory);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__deviceCategory*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__deviceCategory(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__deviceCategory %p -> %p\n", q, p));
	*(ns__deviceCategory*)p = *(ns__deviceCategory*)q;
}

void ns__rootDevice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
}

void ns__rootDevice::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_ns__enum_devInfo(soap, &((ns__rootDevice*)this)->dev);
	soap_default_ns__enum_devInfo(soap, &((ns__rootDevice*)this)->proto);
	soap_default_ns__enum_devInfo(soap, &((ns__rootDevice*)this)->intf);
	soap_default_unsignedInt(soap, &((ns__rootDevice*)this)->order);
}

int ns__rootDevice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__rootDevice);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns__rootDevice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__rootDevice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__rootDevice(struct soap *soap, const char *tag, int id, const ns__rootDevice *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__rootDevice), type);
	soap_out_ns__enum_devInfo(soap, "dev", -1, &(((ns__rootDevice*)a)->dev), "");
	soap_out_ns__enum_devInfo(soap, "proto", -1, &(((ns__rootDevice*)a)->proto), "");
	soap_out_ns__enum_devInfo(soap, "intf", -1, &(((ns__rootDevice*)a)->intf), "");
	soap_out_unsignedInt(soap, "order", -1, &(((ns__rootDevice*)a)->order), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns__rootDevice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__rootDevice(soap, this, tag, type);
}

SOAP_FMAC3 ns__rootDevice * SOAP_FMAC4 soap_get_ns__rootDevice(struct soap *soap, ns__rootDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__rootDevice(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns__rootDevice::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__rootDevice(soap, tag, this, type);
}

SOAP_FMAC3 ns__rootDevice * SOAP_FMAC4 soap_in_ns__rootDevice(struct soap *soap, const char *tag, ns__rootDevice *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (ns__rootDevice *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__rootDevice, sizeof(ns__rootDevice), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_cmxDeviceService_ns__rootDevice)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns__rootDevice *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_dev1 = 1, soap_flag_proto1 = 1, soap_flag_intf1 = 1, soap_flag_order1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dev1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devInfo(soap, "dev", &(((ns__rootDevice*)a)->dev), "ns:enum-devInfo"))
				{	soap_flag_dev1--;
					continue;
				}
			if (soap_flag_proto1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devInfo(soap, "proto", &(((ns__rootDevice*)a)->proto), "ns:enum-devInfo"))
				{	soap_flag_proto1--;
					continue;
				}
			if (soap_flag_intf1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns__enum_devInfo(soap, "intf", &(((ns__rootDevice*)a)->intf), "ns:enum-devInfo"))
				{	soap_flag_intf1--;
					continue;
				}
			if (soap_flag_order1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "order", &(((ns__rootDevice*)a)->order), "xsd:unsignedInt"))
				{	soap_flag_order1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dev1 > 0 || soap_flag_proto1 > 0 || soap_flag_intf1 > 0 || soap_flag_order1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__rootDevice *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__rootDevice, 0, sizeof(ns__rootDevice), 0, soap_copy_ns__rootDevice);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns__rootDevice * SOAP_FMAC6 soap_new_ns__rootDevice(struct soap *soap, int n)
{	return soap_instantiate_ns__rootDevice(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__rootDevice(struct soap *soap, ns__rootDevice *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns__rootDevice * SOAP_FMAC4 soap_instantiate_ns__rootDevice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__rootDevice(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__rootDevice, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns:boiler"))
	{	cp->type = SOAP_TYPE_cmxDeviceService_ns__boiler;
		if (n < 0)
		{	cp->ptr = (void*)new ns__boiler;
			if (size)
				*size = sizeof(ns__boiler);
		}
		else
		{	cp->ptr = (void*)new ns__boiler[n];
			if (size)
				*size = n * sizeof(ns__boiler);
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns__boiler*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns:light"))
	{	cp->type = SOAP_TYPE_cmxDeviceService_ns__light;
		if (n < 0)
		{	cp->ptr = (void*)new ns__light;
			if (size)
				*size = sizeof(ns__light);
		}
		else
		{	cp->ptr = (void*)new ns__light[n];
			if (size)
				*size = n * sizeof(ns__light);
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns__light*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns:gasValve"))
	{	cp->type = SOAP_TYPE_cmxDeviceService_ns__gasValve;
		if (n < 0)
		{	cp->ptr = (void*)new ns__gasValve;
			if (size)
				*size = sizeof(ns__gasValve);
		}
		else
		{	cp->ptr = (void*)new ns__gasValve[n];
			if (size)
				*size = n * sizeof(ns__gasValve);
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns__gasValve*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns:curtain"))
	{	cp->type = SOAP_TYPE_cmxDeviceService_ns__curtain;
		if (n < 0)
		{	cp->ptr = (void*)new ns__curtain;
			if (size)
				*size = sizeof(ns__curtain);
		}
		else
		{	cp->ptr = (void*)new ns__curtain[n];
			if (size)
				*size = n * sizeof(ns__curtain);
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns__curtain*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns:bundleLight"))
	{	cp->type = SOAP_TYPE_cmxDeviceService_ns__bundleLight;
		if (n < 0)
		{	cp->ptr = (void*)new ns__bundleLight;
			if (size)
				*size = sizeof(ns__bundleLight);
		}
		else
		{	cp->ptr = (void*)new ns__bundleLight[n];
			if (size)
				*size = n * sizeof(ns__bundleLight);
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns__bundleLight*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns:systemAircon"))
	{	cp->type = SOAP_TYPE_cmxDeviceService_ns__systemAircon;
		if (n < 0)
		{	cp->ptr = (void*)new ns__systemAircon;
			if (size)
				*size = sizeof(ns__systemAircon);
		}
		else
		{	cp->ptr = (void*)new ns__systemAircon[n];
			if (size)
				*size = n * sizeof(ns__systemAircon);
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns__systemAircon*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns:fanSystem"))
	{	cp->type = SOAP_TYPE_cmxDeviceService_ns__fanSystem;
		if (n < 0)
		{	cp->ptr = (void*)new ns__fanSystem;
			if (size)
				*size = sizeof(ns__fanSystem);
		}
		else
		{	cp->ptr = (void*)new ns__fanSystem[n];
			if (size)
				*size = n * sizeof(ns__fanSystem);
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns__fanSystem*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns:sensorEmer"))
	{	cp->type = SOAP_TYPE_cmxDeviceService_ns__sensorEmer;
		if (n < 0)
		{	cp->ptr = (void*)new ns__sensorEmer;
			if (size)
				*size = sizeof(ns__sensorEmer);
		}
		else
		{	cp->ptr = (void*)new ns__sensorEmer[n];
			if (size)
				*size = n * sizeof(ns__sensorEmer);
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns__sensorEmer*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ns__rootDevice;
		if (size)
			*size = sizeof(ns__rootDevice);
	}
	else
	{	cp->ptr = (void*)new ns__rootDevice[n];
		if (size)
			*size = n * sizeof(ns__rootDevice);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns__rootDevice*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__rootDevice(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns__rootDevice %p -> %p\n", q, p));
	*(ns__rootDevice*)p = *(ns__rootDevice*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Fault), type);
	soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, "");
	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
	soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
	soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, "");
	soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Reason), type);
	soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	short soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Detail), type);
	soap_putelement(soap, a->fault, "fault", -1, a->__type);
	soap_outliteral(soap, "-any", &a->__any);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Code), type);
	soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Header), type);
	/* transient dummy skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient dummy skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__subcribeEvent(struct soap *soap, const struct ns__subcribeEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->port, SOAP_TYPE_cmxDeviceService_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__subcribeEvent(struct soap *soap, struct ns__subcribeEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->port);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__subcribeEvent(struct soap *soap, const struct ns__subcribeEvent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__subcribeEvent);
	if (soap_out_ns__subcribeEvent(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__subcribeEvent(struct soap *soap, const char *tag, int id, const struct ns__subcribeEvent *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__subcribeEvent), type);
	soap_out_int(soap, "port", -1, &a->port, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__subcribeEvent * SOAP_FMAC4 soap_get_ns__subcribeEvent(struct soap *soap, struct ns__subcribeEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__subcribeEvent(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__subcribeEvent * SOAP_FMAC4 soap_in_ns__subcribeEvent(struct soap *soap, const char *tag, struct ns__subcribeEvent *a, const char *type)
{
	short soap_flag_port = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__subcribeEvent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__subcribeEvent, sizeof(struct ns__subcribeEvent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__subcribeEvent(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_port && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "port", &a->port, "xsd:int"))
				{	soap_flag_port--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_port > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__subcribeEvent *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__subcribeEvent, 0, sizeof(struct ns__subcribeEvent), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__subcribeEvent * SOAP_FMAC6 soap_new_ns__subcribeEvent(struct soap *soap, int n)
{	return soap_instantiate_ns__subcribeEvent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__subcribeEvent(struct soap *soap, struct ns__subcribeEvent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__subcribeEvent * SOAP_FMAC4 soap_instantiate_ns__subcribeEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__subcribeEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__subcribeEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__subcribeEvent;
		if (size)
			*size = sizeof(struct ns__subcribeEvent);
	}
	else
	{	cp->ptr = (void*)new struct ns__subcribeEvent[n];
		if (size)
			*size = n * sizeof(struct ns__subcribeEvent);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__subcribeEvent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__subcribeEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__subcribeEvent %p -> %p\n", q, p));
	*(struct ns__subcribeEvent*)p = *(struct ns__subcribeEvent*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__subcribeEventResponse(struct soap *soap, const struct ns__subcribeEventResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__subcribeEventResponse(struct soap *soap, struct ns__subcribeEventResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->out = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__subcribeEventResponse(struct soap *soap, const struct ns__subcribeEventResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__subcribeEventResponse);
	if (soap_out_ns__subcribeEventResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__subcribeEventResponse(struct soap *soap, const char *tag, int id, const struct ns__subcribeEventResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__subcribeEventResponse), type);
	if (a->out)
		soap_element_result(soap, "out");
	soap_out_PointerToint(soap, "out", -1, &a->out, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__subcribeEventResponse * SOAP_FMAC4 soap_get_ns__subcribeEventResponse(struct soap *soap, struct ns__subcribeEventResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__subcribeEventResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__subcribeEventResponse * SOAP_FMAC4 soap_in_ns__subcribeEventResponse(struct soap *soap, const char *tag, struct ns__subcribeEventResponse *a, const char *type)
{
	short soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__subcribeEventResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__subcribeEventResponse, sizeof(struct ns__subcribeEventResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__subcribeEventResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "out", &a->out, "xsd:int"))
				{	soap_flag_out--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__subcribeEventResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__subcribeEventResponse, 0, sizeof(struct ns__subcribeEventResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__subcribeEventResponse * SOAP_FMAC6 soap_new_ns__subcribeEventResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__subcribeEventResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__subcribeEventResponse(struct soap *soap, struct ns__subcribeEventResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__subcribeEventResponse * SOAP_FMAC4 soap_instantiate_ns__subcribeEventResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__subcribeEventResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__subcribeEventResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__subcribeEventResponse;
		if (size)
			*size = sizeof(struct ns__subcribeEventResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__subcribeEventResponse[n];
		if (size)
			*size = n * sizeof(struct ns__subcribeEventResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__subcribeEventResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__subcribeEventResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__subcribeEventResponse %p -> %p\n", q, p));
	*(struct ns__subcribeEventResponse*)p = *(struct ns__subcribeEventResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__sensorEmerEvent(struct soap *soap, const struct ns__sensorEmerEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.soap_serialize(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__sensorEmerEvent(struct soap *soap, struct ns__sensorEmerEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.ns__sensorEmer::soap_default(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__sensorEmerEvent(struct soap *soap, const struct ns__sensorEmerEvent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__sensorEmerEvent);
	if (soap_out_ns__sensorEmerEvent(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__sensorEmerEvent(struct soap *soap, const char *tag, int id, const struct ns__sensorEmerEvent *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__sensorEmerEvent), type);
	a->in.soap_out(soap, "in", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__sensorEmerEvent * SOAP_FMAC4 soap_get_ns__sensorEmerEvent(struct soap *soap, struct ns__sensorEmerEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__sensorEmerEvent(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__sensorEmerEvent * SOAP_FMAC4 soap_in_ns__sensorEmerEvent(struct soap *soap, const char *tag, struct ns__sensorEmerEvent *a, const char *type)
{
	short soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__sensorEmerEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__sensorEmerEvent, sizeof(struct ns__sensorEmerEvent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__sensorEmerEvent(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && soap->error == SOAP_TAG_MISMATCH)
				if (a->in.soap_in(soap, "in", "ns:sensorEmer"))
				{	soap_flag_in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__sensorEmerEvent *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__sensorEmerEvent, 0, sizeof(struct ns__sensorEmerEvent), 0, soap_copy_ns__sensorEmerEvent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__sensorEmerEvent * SOAP_FMAC6 soap_new_ns__sensorEmerEvent(struct soap *soap, int n)
{	return soap_instantiate_ns__sensorEmerEvent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__sensorEmerEvent(struct soap *soap, struct ns__sensorEmerEvent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__sensorEmerEvent * SOAP_FMAC4 soap_instantiate_ns__sensorEmerEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__sensorEmerEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__sensorEmerEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__sensorEmerEvent;
		if (size)
			*size = sizeof(struct ns__sensorEmerEvent);
	}
	else
	{	cp->ptr = (void*)new struct ns__sensorEmerEvent[n];
		if (size)
			*size = n * sizeof(struct ns__sensorEmerEvent);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__sensorEmerEvent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__sensorEmerEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__sensorEmerEvent %p -> %p\n", q, p));
	*(struct ns__sensorEmerEvent*)p = *(struct ns__sensorEmerEvent*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__sensorEmerEventResponse(struct soap *soap, const struct ns__sensorEmerEventResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__sensorEmerEventResponse(struct soap *soap, struct ns__sensorEmerEventResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->out = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__sensorEmerEventResponse(struct soap *soap, const struct ns__sensorEmerEventResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__sensorEmerEventResponse);
	if (soap_out_ns__sensorEmerEventResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__sensorEmerEventResponse(struct soap *soap, const char *tag, int id, const struct ns__sensorEmerEventResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__sensorEmerEventResponse), type);
	if (a->out)
		soap_element_result(soap, "out");
	soap_out_PointerToint(soap, "out", -1, &a->out, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__sensorEmerEventResponse * SOAP_FMAC4 soap_get_ns__sensorEmerEventResponse(struct soap *soap, struct ns__sensorEmerEventResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__sensorEmerEventResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__sensorEmerEventResponse * SOAP_FMAC4 soap_in_ns__sensorEmerEventResponse(struct soap *soap, const char *tag, struct ns__sensorEmerEventResponse *a, const char *type)
{
	short soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__sensorEmerEventResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__sensorEmerEventResponse, sizeof(struct ns__sensorEmerEventResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__sensorEmerEventResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "out", &a->out, "xsd:int"))
				{	soap_flag_out--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__sensorEmerEventResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__sensorEmerEventResponse, 0, sizeof(struct ns__sensorEmerEventResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__sensorEmerEventResponse * SOAP_FMAC6 soap_new_ns__sensorEmerEventResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__sensorEmerEventResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__sensorEmerEventResponse(struct soap *soap, struct ns__sensorEmerEventResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__sensorEmerEventResponse * SOAP_FMAC4 soap_instantiate_ns__sensorEmerEventResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__sensorEmerEventResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__sensorEmerEventResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__sensorEmerEventResponse;
		if (size)
			*size = sizeof(struct ns__sensorEmerEventResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__sensorEmerEventResponse[n];
		if (size)
			*size = n * sizeof(struct ns__sensorEmerEventResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__sensorEmerEventResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__sensorEmerEventResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__sensorEmerEventResponse %p -> %p\n", q, p));
	*(struct ns__sensorEmerEventResponse*)p = *(struct ns__sensorEmerEventResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setSensorEmer(struct soap *soap, const struct ns__setSensorEmer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.soap_serialize(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setSensorEmer(struct soap *soap, struct ns__setSensorEmer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.ns__sensorEmer::soap_default(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setSensorEmer(struct soap *soap, const struct ns__setSensorEmer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__setSensorEmer);
	if (soap_out_ns__setSensorEmer(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setSensorEmer(struct soap *soap, const char *tag, int id, const struct ns__setSensorEmer *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__setSensorEmer), type);
	a->in.soap_out(soap, "in", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setSensorEmer * SOAP_FMAC4 soap_get_ns__setSensorEmer(struct soap *soap, struct ns__setSensorEmer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setSensorEmer(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setSensorEmer * SOAP_FMAC4 soap_in_ns__setSensorEmer(struct soap *soap, const char *tag, struct ns__setSensorEmer *a, const char *type)
{
	short soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setSensorEmer *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__setSensorEmer, sizeof(struct ns__setSensorEmer), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__setSensorEmer(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && soap->error == SOAP_TAG_MISMATCH)
				if (a->in.soap_in(soap, "in", "ns:sensorEmer"))
				{	soap_flag_in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setSensorEmer *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__setSensorEmer, 0, sizeof(struct ns__setSensorEmer), 0, soap_copy_ns__setSensorEmer);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setSensorEmer * SOAP_FMAC6 soap_new_ns__setSensorEmer(struct soap *soap, int n)
{	return soap_instantiate_ns__setSensorEmer(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setSensorEmer(struct soap *soap, struct ns__setSensorEmer *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setSensorEmer * SOAP_FMAC4 soap_instantiate_ns__setSensorEmer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setSensorEmer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__setSensorEmer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setSensorEmer;
		if (size)
			*size = sizeof(struct ns__setSensorEmer);
	}
	else
	{	cp->ptr = (void*)new struct ns__setSensorEmer[n];
		if (size)
			*size = n * sizeof(struct ns__setSensorEmer);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setSensorEmer*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setSensorEmer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setSensorEmer %p -> %p\n", q, p));
	*(struct ns__setSensorEmer*)p = *(struct ns__setSensorEmer*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getSensorEmer(struct soap *soap, const struct ns__getSensorEmer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.soap_serialize(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getSensorEmer(struct soap *soap, struct ns__getSensorEmer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.ns__sensorEmer::soap_default(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getSensorEmer(struct soap *soap, const struct ns__getSensorEmer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getSensorEmer);
	if (soap_out_ns__getSensorEmer(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getSensorEmer(struct soap *soap, const char *tag, int id, const struct ns__getSensorEmer *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getSensorEmer), type);
	a->in.soap_out(soap, "in", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getSensorEmer * SOAP_FMAC4 soap_get_ns__getSensorEmer(struct soap *soap, struct ns__getSensorEmer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getSensorEmer(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getSensorEmer * SOAP_FMAC4 soap_in_ns__getSensorEmer(struct soap *soap, const char *tag, struct ns__getSensorEmer *a, const char *type)
{
	short soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getSensorEmer *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getSensorEmer, sizeof(struct ns__getSensorEmer), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__getSensorEmer(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && soap->error == SOAP_TAG_MISMATCH)
				if (a->in.soap_in(soap, "in", "ns:sensorEmer"))
				{	soap_flag_in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getSensorEmer *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getSensorEmer, 0, sizeof(struct ns__getSensorEmer), 0, soap_copy_ns__getSensorEmer);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getSensorEmer * SOAP_FMAC6 soap_new_ns__getSensorEmer(struct soap *soap, int n)
{	return soap_instantiate_ns__getSensorEmer(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getSensorEmer(struct soap *soap, struct ns__getSensorEmer *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getSensorEmer * SOAP_FMAC4 soap_instantiate_ns__getSensorEmer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getSensorEmer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getSensorEmer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getSensorEmer;
		if (size)
			*size = sizeof(struct ns__getSensorEmer);
	}
	else
	{	cp->ptr = (void*)new struct ns__getSensorEmer[n];
		if (size)
			*size = n * sizeof(struct ns__getSensorEmer);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getSensorEmer*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getSensorEmer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getSensorEmer %p -> %p\n", q, p));
	*(struct ns__getSensorEmer*)p = *(struct ns__getSensorEmer*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getSensorEmerItem(struct soap *soap, const struct ns__getSensorEmerItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->order, SOAP_TYPE_cmxDeviceService_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getSensorEmerItem(struct soap *soap, struct ns__getSensorEmerItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->order);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getSensorEmerItem(struct soap *soap, const struct ns__getSensorEmerItem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerItem);
	if (soap_out_ns__getSensorEmerItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getSensorEmerItem(struct soap *soap, const char *tag, int id, const struct ns__getSensorEmerItem *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerItem), type);
	soap_out_int(soap, "order", -1, &a->order, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getSensorEmerItem * SOAP_FMAC4 soap_get_ns__getSensorEmerItem(struct soap *soap, struct ns__getSensorEmerItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getSensorEmerItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getSensorEmerItem * SOAP_FMAC4 soap_in_ns__getSensorEmerItem(struct soap *soap, const char *tag, struct ns__getSensorEmerItem *a, const char *type)
{
	short soap_flag_order = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getSensorEmerItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerItem, sizeof(struct ns__getSensorEmerItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getSensorEmerItem(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_order && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "order", &a->order, "xsd:int"))
				{	soap_flag_order--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_order > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getSensorEmerItem *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerItem, 0, sizeof(struct ns__getSensorEmerItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getSensorEmerItem * SOAP_FMAC6 soap_new_ns__getSensorEmerItem(struct soap *soap, int n)
{	return soap_instantiate_ns__getSensorEmerItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getSensorEmerItem(struct soap *soap, struct ns__getSensorEmerItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getSensorEmerItem * SOAP_FMAC4 soap_instantiate_ns__getSensorEmerItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getSensorEmerItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getSensorEmerItem;
		if (size)
			*size = sizeof(struct ns__getSensorEmerItem);
	}
	else
	{	cp->ptr = (void*)new struct ns__getSensorEmerItem[n];
		if (size)
			*size = n * sizeof(struct ns__getSensorEmerItem);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getSensorEmerItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getSensorEmerItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getSensorEmerItem %p -> %p\n", q, p));
	*(struct ns__getSensorEmerItem*)p = *(struct ns__getSensorEmerItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getSensorEmerCount(struct soap *soap, const struct ns__getSensorEmerCount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getSensorEmerCount(struct soap *soap, struct ns__getSensorEmerCount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getSensorEmerCount(struct soap *soap, const struct ns__getSensorEmerCount *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerCount);
	if (soap_out_ns__getSensorEmerCount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getSensorEmerCount(struct soap *soap, const char *tag, int id, const struct ns__getSensorEmerCount *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerCount), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getSensorEmerCount * SOAP_FMAC4 soap_get_ns__getSensorEmerCount(struct soap *soap, struct ns__getSensorEmerCount *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getSensorEmerCount(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getSensorEmerCount * SOAP_FMAC4 soap_in_ns__getSensorEmerCount(struct soap *soap, const char *tag, struct ns__getSensorEmerCount *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getSensorEmerCount *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerCount, sizeof(struct ns__getSensorEmerCount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getSensorEmerCount(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getSensorEmerCount *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerCount, 0, sizeof(struct ns__getSensorEmerCount), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getSensorEmerCount * SOAP_FMAC6 soap_new_ns__getSensorEmerCount(struct soap *soap, int n)
{	return soap_instantiate_ns__getSensorEmerCount(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getSensorEmerCount(struct soap *soap, struct ns__getSensorEmerCount *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getSensorEmerCount * SOAP_FMAC4 soap_instantiate_ns__getSensorEmerCount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getSensorEmerCount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerCount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getSensorEmerCount;
		if (size)
			*size = sizeof(struct ns__getSensorEmerCount);
	}
	else
	{	cp->ptr = (void*)new struct ns__getSensorEmerCount[n];
		if (size)
			*size = n * sizeof(struct ns__getSensorEmerCount);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getSensorEmerCount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getSensorEmerCount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getSensorEmerCount %p -> %p\n", q, p));
	*(struct ns__getSensorEmerCount*)p = *(struct ns__getSensorEmerCount*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getSensorEmerCountResponse(struct soap *soap, const struct ns__getSensorEmerCountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getSensorEmerCountResponse(struct soap *soap, struct ns__getSensorEmerCountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->out = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getSensorEmerCountResponse(struct soap *soap, const struct ns__getSensorEmerCountResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerCountResponse);
	if (soap_out_ns__getSensorEmerCountResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getSensorEmerCountResponse(struct soap *soap, const char *tag, int id, const struct ns__getSensorEmerCountResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerCountResponse), type);
	if (a->out)
		soap_element_result(soap, "out");
	soap_out_PointerToint(soap, "out", -1, &a->out, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getSensorEmerCountResponse * SOAP_FMAC4 soap_get_ns__getSensorEmerCountResponse(struct soap *soap, struct ns__getSensorEmerCountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getSensorEmerCountResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getSensorEmerCountResponse * SOAP_FMAC4 soap_in_ns__getSensorEmerCountResponse(struct soap *soap, const char *tag, struct ns__getSensorEmerCountResponse *a, const char *type)
{
	short soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getSensorEmerCountResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerCountResponse, sizeof(struct ns__getSensorEmerCountResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getSensorEmerCountResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "out", &a->out, "xsd:int"))
				{	soap_flag_out--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getSensorEmerCountResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerCountResponse, 0, sizeof(struct ns__getSensorEmerCountResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getSensorEmerCountResponse * SOAP_FMAC6 soap_new_ns__getSensorEmerCountResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getSensorEmerCountResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getSensorEmerCountResponse(struct soap *soap, struct ns__getSensorEmerCountResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getSensorEmerCountResponse * SOAP_FMAC4 soap_instantiate_ns__getSensorEmerCountResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getSensorEmerCountResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerCountResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getSensorEmerCountResponse;
		if (size)
			*size = sizeof(struct ns__getSensorEmerCountResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__getSensorEmerCountResponse[n];
		if (size)
			*size = n * sizeof(struct ns__getSensorEmerCountResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getSensorEmerCountResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getSensorEmerCountResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getSensorEmerCountResponse %p -> %p\n", q, p));
	*(struct ns__getSensorEmerCountResponse*)p = *(struct ns__getSensorEmerCountResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__FanSystemEvent(struct soap *soap, const struct ns__FanSystemEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.soap_serialize(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__FanSystemEvent(struct soap *soap, struct ns__FanSystemEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.ns__fanSystem::soap_default(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__FanSystemEvent(struct soap *soap, const struct ns__FanSystemEvent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__FanSystemEvent);
	if (soap_out_ns__FanSystemEvent(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__FanSystemEvent(struct soap *soap, const char *tag, int id, const struct ns__FanSystemEvent *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__FanSystemEvent), type);
	a->in.soap_out(soap, "in", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__FanSystemEvent * SOAP_FMAC4 soap_get_ns__FanSystemEvent(struct soap *soap, struct ns__FanSystemEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__FanSystemEvent(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__FanSystemEvent * SOAP_FMAC4 soap_in_ns__FanSystemEvent(struct soap *soap, const char *tag, struct ns__FanSystemEvent *a, const char *type)
{
	short soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__FanSystemEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__FanSystemEvent, sizeof(struct ns__FanSystemEvent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__FanSystemEvent(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && soap->error == SOAP_TAG_MISMATCH)
				if (a->in.soap_in(soap, "in", "ns:fanSystem"))
				{	soap_flag_in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__FanSystemEvent *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__FanSystemEvent, 0, sizeof(struct ns__FanSystemEvent), 0, soap_copy_ns__FanSystemEvent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__FanSystemEvent * SOAP_FMAC6 soap_new_ns__FanSystemEvent(struct soap *soap, int n)
{	return soap_instantiate_ns__FanSystemEvent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__FanSystemEvent(struct soap *soap, struct ns__FanSystemEvent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__FanSystemEvent * SOAP_FMAC4 soap_instantiate_ns__FanSystemEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__FanSystemEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__FanSystemEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__FanSystemEvent;
		if (size)
			*size = sizeof(struct ns__FanSystemEvent);
	}
	else
	{	cp->ptr = (void*)new struct ns__FanSystemEvent[n];
		if (size)
			*size = n * sizeof(struct ns__FanSystemEvent);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__FanSystemEvent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__FanSystemEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__FanSystemEvent %p -> %p\n", q, p));
	*(struct ns__FanSystemEvent*)p = *(struct ns__FanSystemEvent*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__FanSystemEventResponse(struct soap *soap, const struct ns__FanSystemEventResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__FanSystemEventResponse(struct soap *soap, struct ns__FanSystemEventResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->out = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__FanSystemEventResponse(struct soap *soap, const struct ns__FanSystemEventResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__FanSystemEventResponse);
	if (soap_out_ns__FanSystemEventResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__FanSystemEventResponse(struct soap *soap, const char *tag, int id, const struct ns__FanSystemEventResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__FanSystemEventResponse), type);
	if (a->out)
		soap_element_result(soap, "out");
	soap_out_PointerToint(soap, "out", -1, &a->out, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__FanSystemEventResponse * SOAP_FMAC4 soap_get_ns__FanSystemEventResponse(struct soap *soap, struct ns__FanSystemEventResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__FanSystemEventResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__FanSystemEventResponse * SOAP_FMAC4 soap_in_ns__FanSystemEventResponse(struct soap *soap, const char *tag, struct ns__FanSystemEventResponse *a, const char *type)
{
	short soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__FanSystemEventResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__FanSystemEventResponse, sizeof(struct ns__FanSystemEventResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__FanSystemEventResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "out", &a->out, "xsd:int"))
				{	soap_flag_out--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__FanSystemEventResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__FanSystemEventResponse, 0, sizeof(struct ns__FanSystemEventResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__FanSystemEventResponse * SOAP_FMAC6 soap_new_ns__FanSystemEventResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__FanSystemEventResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__FanSystemEventResponse(struct soap *soap, struct ns__FanSystemEventResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__FanSystemEventResponse * SOAP_FMAC4 soap_instantiate_ns__FanSystemEventResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__FanSystemEventResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__FanSystemEventResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__FanSystemEventResponse;
		if (size)
			*size = sizeof(struct ns__FanSystemEventResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__FanSystemEventResponse[n];
		if (size)
			*size = n * sizeof(struct ns__FanSystemEventResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__FanSystemEventResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__FanSystemEventResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__FanSystemEventResponse %p -> %p\n", q, p));
	*(struct ns__FanSystemEventResponse*)p = *(struct ns__FanSystemEventResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setFanSystem(struct soap *soap, const struct ns__setFanSystem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.soap_serialize(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setFanSystem(struct soap *soap, struct ns__setFanSystem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.ns__fanSystem::soap_default(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setFanSystem(struct soap *soap, const struct ns__setFanSystem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__setFanSystem);
	if (soap_out_ns__setFanSystem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setFanSystem(struct soap *soap, const char *tag, int id, const struct ns__setFanSystem *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__setFanSystem), type);
	a->in.soap_out(soap, "in", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setFanSystem * SOAP_FMAC4 soap_get_ns__setFanSystem(struct soap *soap, struct ns__setFanSystem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setFanSystem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setFanSystem * SOAP_FMAC4 soap_in_ns__setFanSystem(struct soap *soap, const char *tag, struct ns__setFanSystem *a, const char *type)
{
	short soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setFanSystem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__setFanSystem, sizeof(struct ns__setFanSystem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__setFanSystem(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && soap->error == SOAP_TAG_MISMATCH)
				if (a->in.soap_in(soap, "in", "ns:fanSystem"))
				{	soap_flag_in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setFanSystem *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__setFanSystem, 0, sizeof(struct ns__setFanSystem), 0, soap_copy_ns__setFanSystem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setFanSystem * SOAP_FMAC6 soap_new_ns__setFanSystem(struct soap *soap, int n)
{	return soap_instantiate_ns__setFanSystem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setFanSystem(struct soap *soap, struct ns__setFanSystem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setFanSystem * SOAP_FMAC4 soap_instantiate_ns__setFanSystem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setFanSystem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__setFanSystem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setFanSystem;
		if (size)
			*size = sizeof(struct ns__setFanSystem);
	}
	else
	{	cp->ptr = (void*)new struct ns__setFanSystem[n];
		if (size)
			*size = n * sizeof(struct ns__setFanSystem);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setFanSystem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setFanSystem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setFanSystem %p -> %p\n", q, p));
	*(struct ns__setFanSystem*)p = *(struct ns__setFanSystem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getFanSystem(struct soap *soap, const struct ns__getFanSystem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.soap_serialize(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getFanSystem(struct soap *soap, struct ns__getFanSystem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.ns__fanSystem::soap_default(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getFanSystem(struct soap *soap, const struct ns__getFanSystem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getFanSystem);
	if (soap_out_ns__getFanSystem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getFanSystem(struct soap *soap, const char *tag, int id, const struct ns__getFanSystem *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getFanSystem), type);
	a->in.soap_out(soap, "in", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getFanSystem * SOAP_FMAC4 soap_get_ns__getFanSystem(struct soap *soap, struct ns__getFanSystem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getFanSystem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getFanSystem * SOAP_FMAC4 soap_in_ns__getFanSystem(struct soap *soap, const char *tag, struct ns__getFanSystem *a, const char *type)
{
	short soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getFanSystem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getFanSystem, sizeof(struct ns__getFanSystem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__getFanSystem(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && soap->error == SOAP_TAG_MISMATCH)
				if (a->in.soap_in(soap, "in", "ns:fanSystem"))
				{	soap_flag_in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getFanSystem *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getFanSystem, 0, sizeof(struct ns__getFanSystem), 0, soap_copy_ns__getFanSystem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getFanSystem * SOAP_FMAC6 soap_new_ns__getFanSystem(struct soap *soap, int n)
{	return soap_instantiate_ns__getFanSystem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getFanSystem(struct soap *soap, struct ns__getFanSystem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getFanSystem * SOAP_FMAC4 soap_instantiate_ns__getFanSystem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getFanSystem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getFanSystem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getFanSystem;
		if (size)
			*size = sizeof(struct ns__getFanSystem);
	}
	else
	{	cp->ptr = (void*)new struct ns__getFanSystem[n];
		if (size)
			*size = n * sizeof(struct ns__getFanSystem);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getFanSystem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getFanSystem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getFanSystem %p -> %p\n", q, p));
	*(struct ns__getFanSystem*)p = *(struct ns__getFanSystem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getFanSystemItem(struct soap *soap, const struct ns__getFanSystemItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->order, SOAP_TYPE_cmxDeviceService_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getFanSystemItem(struct soap *soap, struct ns__getFanSystemItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->order);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getFanSystemItem(struct soap *soap, const struct ns__getFanSystemItem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getFanSystemItem);
	if (soap_out_ns__getFanSystemItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getFanSystemItem(struct soap *soap, const char *tag, int id, const struct ns__getFanSystemItem *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getFanSystemItem), type);
	soap_out_int(soap, "order", -1, &a->order, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getFanSystemItem * SOAP_FMAC4 soap_get_ns__getFanSystemItem(struct soap *soap, struct ns__getFanSystemItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getFanSystemItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getFanSystemItem * SOAP_FMAC4 soap_in_ns__getFanSystemItem(struct soap *soap, const char *tag, struct ns__getFanSystemItem *a, const char *type)
{
	short soap_flag_order = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getFanSystemItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getFanSystemItem, sizeof(struct ns__getFanSystemItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getFanSystemItem(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_order && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "order", &a->order, "xsd:int"))
				{	soap_flag_order--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_order > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getFanSystemItem *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getFanSystemItem, 0, sizeof(struct ns__getFanSystemItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getFanSystemItem * SOAP_FMAC6 soap_new_ns__getFanSystemItem(struct soap *soap, int n)
{	return soap_instantiate_ns__getFanSystemItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getFanSystemItem(struct soap *soap, struct ns__getFanSystemItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getFanSystemItem * SOAP_FMAC4 soap_instantiate_ns__getFanSystemItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getFanSystemItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getFanSystemItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getFanSystemItem;
		if (size)
			*size = sizeof(struct ns__getFanSystemItem);
	}
	else
	{	cp->ptr = (void*)new struct ns__getFanSystemItem[n];
		if (size)
			*size = n * sizeof(struct ns__getFanSystemItem);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getFanSystemItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getFanSystemItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getFanSystemItem %p -> %p\n", q, p));
	*(struct ns__getFanSystemItem*)p = *(struct ns__getFanSystemItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getFanSystemPropertyItem(struct soap *soap, const struct ns__getFanSystemPropertyItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->order, SOAP_TYPE_cmxDeviceService_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getFanSystemPropertyItem(struct soap *soap, struct ns__getFanSystemPropertyItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->order);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getFanSystemPropertyItem(struct soap *soap, const struct ns__getFanSystemPropertyItem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getFanSystemPropertyItem);
	if (soap_out_ns__getFanSystemPropertyItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getFanSystemPropertyItem(struct soap *soap, const char *tag, int id, const struct ns__getFanSystemPropertyItem *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getFanSystemPropertyItem), type);
	soap_out_int(soap, "order", -1, &a->order, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getFanSystemPropertyItem * SOAP_FMAC4 soap_get_ns__getFanSystemPropertyItem(struct soap *soap, struct ns__getFanSystemPropertyItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getFanSystemPropertyItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getFanSystemPropertyItem * SOAP_FMAC4 soap_in_ns__getFanSystemPropertyItem(struct soap *soap, const char *tag, struct ns__getFanSystemPropertyItem *a, const char *type)
{
	short soap_flag_order = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getFanSystemPropertyItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getFanSystemPropertyItem, sizeof(struct ns__getFanSystemPropertyItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getFanSystemPropertyItem(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_order && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "order", &a->order, "xsd:int"))
				{	soap_flag_order--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_order > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getFanSystemPropertyItem *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getFanSystemPropertyItem, 0, sizeof(struct ns__getFanSystemPropertyItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getFanSystemPropertyItem * SOAP_FMAC6 soap_new_ns__getFanSystemPropertyItem(struct soap *soap, int n)
{	return soap_instantiate_ns__getFanSystemPropertyItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getFanSystemPropertyItem(struct soap *soap, struct ns__getFanSystemPropertyItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getFanSystemPropertyItem * SOAP_FMAC4 soap_instantiate_ns__getFanSystemPropertyItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getFanSystemPropertyItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getFanSystemPropertyItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getFanSystemPropertyItem;
		if (size)
			*size = sizeof(struct ns__getFanSystemPropertyItem);
	}
	else
	{	cp->ptr = (void*)new struct ns__getFanSystemPropertyItem[n];
		if (size)
			*size = n * sizeof(struct ns__getFanSystemPropertyItem);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getFanSystemPropertyItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getFanSystemPropertyItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getFanSystemPropertyItem %p -> %p\n", q, p));
	*(struct ns__getFanSystemPropertyItem*)p = *(struct ns__getFanSystemPropertyItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getFanSystemCount(struct soap *soap, const struct ns__getFanSystemCount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getFanSystemCount(struct soap *soap, struct ns__getFanSystemCount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getFanSystemCount(struct soap *soap, const struct ns__getFanSystemCount *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getFanSystemCount);
	if (soap_out_ns__getFanSystemCount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getFanSystemCount(struct soap *soap, const char *tag, int id, const struct ns__getFanSystemCount *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getFanSystemCount), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getFanSystemCount * SOAP_FMAC4 soap_get_ns__getFanSystemCount(struct soap *soap, struct ns__getFanSystemCount *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getFanSystemCount(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getFanSystemCount * SOAP_FMAC4 soap_in_ns__getFanSystemCount(struct soap *soap, const char *tag, struct ns__getFanSystemCount *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getFanSystemCount *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getFanSystemCount, sizeof(struct ns__getFanSystemCount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getFanSystemCount(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getFanSystemCount *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getFanSystemCount, 0, sizeof(struct ns__getFanSystemCount), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getFanSystemCount * SOAP_FMAC6 soap_new_ns__getFanSystemCount(struct soap *soap, int n)
{	return soap_instantiate_ns__getFanSystemCount(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getFanSystemCount(struct soap *soap, struct ns__getFanSystemCount *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getFanSystemCount * SOAP_FMAC4 soap_instantiate_ns__getFanSystemCount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getFanSystemCount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getFanSystemCount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getFanSystemCount;
		if (size)
			*size = sizeof(struct ns__getFanSystemCount);
	}
	else
	{	cp->ptr = (void*)new struct ns__getFanSystemCount[n];
		if (size)
			*size = n * sizeof(struct ns__getFanSystemCount);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getFanSystemCount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getFanSystemCount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getFanSystemCount %p -> %p\n", q, p));
	*(struct ns__getFanSystemCount*)p = *(struct ns__getFanSystemCount*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getFanSystemCountResponse(struct soap *soap, const struct ns__getFanSystemCountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getFanSystemCountResponse(struct soap *soap, struct ns__getFanSystemCountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->out = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getFanSystemCountResponse(struct soap *soap, const struct ns__getFanSystemCountResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getFanSystemCountResponse);
	if (soap_out_ns__getFanSystemCountResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getFanSystemCountResponse(struct soap *soap, const char *tag, int id, const struct ns__getFanSystemCountResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getFanSystemCountResponse), type);
	if (a->out)
		soap_element_result(soap, "out");
	soap_out_PointerToint(soap, "out", -1, &a->out, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getFanSystemCountResponse * SOAP_FMAC4 soap_get_ns__getFanSystemCountResponse(struct soap *soap, struct ns__getFanSystemCountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getFanSystemCountResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getFanSystemCountResponse * SOAP_FMAC4 soap_in_ns__getFanSystemCountResponse(struct soap *soap, const char *tag, struct ns__getFanSystemCountResponse *a, const char *type)
{
	short soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getFanSystemCountResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getFanSystemCountResponse, sizeof(struct ns__getFanSystemCountResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getFanSystemCountResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "out", &a->out, "xsd:int"))
				{	soap_flag_out--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getFanSystemCountResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getFanSystemCountResponse, 0, sizeof(struct ns__getFanSystemCountResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getFanSystemCountResponse * SOAP_FMAC6 soap_new_ns__getFanSystemCountResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getFanSystemCountResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getFanSystemCountResponse(struct soap *soap, struct ns__getFanSystemCountResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getFanSystemCountResponse * SOAP_FMAC4 soap_instantiate_ns__getFanSystemCountResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getFanSystemCountResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getFanSystemCountResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getFanSystemCountResponse;
		if (size)
			*size = sizeof(struct ns__getFanSystemCountResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__getFanSystemCountResponse[n];
		if (size)
			*size = n * sizeof(struct ns__getFanSystemCountResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getFanSystemCountResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getFanSystemCountResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getFanSystemCountResponse %p -> %p\n", q, p));
	*(struct ns__getFanSystemCountResponse*)p = *(struct ns__getFanSystemCountResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd_fanSystemProperty(struct soap *soap, const struct xsd_fanSystemProperty *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd_fanSystemProperty(struct soap *soap, struct xsd_fanSystemProperty *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->_fanSystemDo_Power_Off);
	soap_default_unsignedInt(soap, &a->_fanSystemDo_Power_On);
	soap_default_unsignedInt(soap, &a->_fanSystemDo_AutoFan_ElectricHeat);
	soap_default_unsignedInt(soap, &a->_fanSystemDo_AutoFan_GeneralFan);
	soap_default_unsignedInt(soap, &a->_fanSystemDo_FanMode_ElectricHeat);
	soap_default_unsignedInt(soap, &a->_fanSystemDo_FanMode_GeneralFan);
	soap_default_unsignedInt(soap, &a->_fanSystemDo_FanMode_Schedule);
	soap_default_unsignedInt(soap, &a->_fanSystemDo_FanMode_SleepingMode);
	soap_default_unsignedInt(soap, &a->_fanSystemDo_Wind_Off);
	soap_default_unsignedInt(soap, &a->_fanSystemDo_Wind_Low);
	soap_default_unsignedInt(soap, &a->_fanSystemDo_Wind_Middle);
	soap_default_unsignedInt(soap, &a->_fanSystemDo_Wind_High);
	soap_default_unsignedInt(soap, &a->_fanSystemDo_ReservationSet);
	soap_default_unsignedInt(soap, &a->_fanSystemDo_ReservationSet_Release);
	soap_default_unsignedInt(soap, &a->_fanSystemDo_ReservationSet_Running);
	soap_default_unsignedInt(soap, &a->_fanSystemDo_ReservationSet_NotRunning);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_Power_Off);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_Power_On);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_AutoFan_ElectricHeat);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_AutoFan_GeneralFan);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_CurrentFanMode_AutoFan);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_FanMode_ElectricHeat);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_FanMode_GeneralFan);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_FanMode_Schedule);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_FanMode_SleepingMode);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_CurrentFanMode_Manual);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_Wind_Off);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_Wind_Low);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_Wind_Middle);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_Wind_High);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_ReservationSet);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_ReservationSet_Release);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_ReservationSet_Running);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_ReservationSet_NotRunning);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_FanReservationSetMode_Hour);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_FanReservationSetMode_Minute);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_FanReservation_Hour);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_FanReservation_Minute);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_SensorMode_NotExistSenosr);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_SensorMode_GasSenosr);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_SensorMode_CO2Senosr);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_DamperMode_NotExist);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_DamperMode_Exist);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_FilterEmpressMode_Clean);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_FilterEmpressMode_Change);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_FilterEmpressMode_FEChange);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_FilterEmpressMode_Normal);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_AlarmMode_Normal);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_AlarmMode_HighSpeedMotor);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_AlarmMode_VentilationMotor);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_AlarmMode_DamperMotor);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_AlarmMode_CO2);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_AlarmMode_TemperatureMotor);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_AlarmMode_OverHeating);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_AlarmMode_DeviceProtect);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_CO2_DensityMode_CO2High);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_CO2_DensityMode_CO2Low);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_CO2_Density_High);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_CO2_Density_Low);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_GAS_Density_Low);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_GAS_Density_Middle);
	soap_default_unsignedInt(soap, &a->_fanSystemSt_GAS_Density_High);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd_fanSystemProperty(struct soap *soap, const struct xsd_fanSystemProperty *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_xsd_fanSystemProperty);
	if (soap_out_xsd_fanSystemProperty(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd_fanSystemProperty(struct soap *soap, const char *tag, int id, const struct xsd_fanSystemProperty *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_xsd_fanSystemProperty), type);
	soap_out_unsignedInt(soap, "fanSystemDo-Power-Off", -1, &a->_fanSystemDo_Power_Off, "");
	soap_out_unsignedInt(soap, "fanSystemDo-Power-On", -1, &a->_fanSystemDo_Power_On, "");
	soap_out_unsignedInt(soap, "fanSystemDo-AutoFan-ElectricHeat", -1, &a->_fanSystemDo_AutoFan_ElectricHeat, "");
	soap_out_unsignedInt(soap, "fanSystemDo-AutoFan-GeneralFan", -1, &a->_fanSystemDo_AutoFan_GeneralFan, "");
	soap_out_unsignedInt(soap, "fanSystemDo-FanMode-ElectricHeat", -1, &a->_fanSystemDo_FanMode_ElectricHeat, "");
	soap_out_unsignedInt(soap, "fanSystemDo-FanMode-GeneralFan", -1, &a->_fanSystemDo_FanMode_GeneralFan, "");
	soap_out_unsignedInt(soap, "fanSystemDo-FanMode-Schedule", -1, &a->_fanSystemDo_FanMode_Schedule, "");
	soap_out_unsignedInt(soap, "fanSystemDo-FanMode-SleepingMode", -1, &a->_fanSystemDo_FanMode_SleepingMode, "");
	soap_out_unsignedInt(soap, "fanSystemDo-Wind-Off", -1, &a->_fanSystemDo_Wind_Off, "");
	soap_out_unsignedInt(soap, "fanSystemDo-Wind-Low", -1, &a->_fanSystemDo_Wind_Low, "");
	soap_out_unsignedInt(soap, "fanSystemDo-Wind-Middle", -1, &a->_fanSystemDo_Wind_Middle, "");
	soap_out_unsignedInt(soap, "fanSystemDo-Wind-High", -1, &a->_fanSystemDo_Wind_High, "");
	soap_out_unsignedInt(soap, "fanSystemDo-ReservationSet", -1, &a->_fanSystemDo_ReservationSet, "");
	soap_out_unsignedInt(soap, "fanSystemDo-ReservationSet-Release", -1, &a->_fanSystemDo_ReservationSet_Release, "");
	soap_out_unsignedInt(soap, "fanSystemDo-ReservationSet-Running", -1, &a->_fanSystemDo_ReservationSet_Running, "");
	soap_out_unsignedInt(soap, "fanSystemDo-ReservationSet-NotRunning", -1, &a->_fanSystemDo_ReservationSet_NotRunning, "");
	soap_out_unsignedInt(soap, "fanSystemSt-Power-Off", -1, &a->_fanSystemSt_Power_Off, "");
	soap_out_unsignedInt(soap, "fanSystemSt-Power-On", -1, &a->_fanSystemSt_Power_On, "");
	soap_out_unsignedInt(soap, "fanSystemSt-AutoFan-ElectricHeat", -1, &a->_fanSystemSt_AutoFan_ElectricHeat, "");
	soap_out_unsignedInt(soap, "fanSystemSt-AutoFan-GeneralFan", -1, &a->_fanSystemSt_AutoFan_GeneralFan, "");
	soap_out_unsignedInt(soap, "fanSystemSt-CurrentFanMode-AutoFan", -1, &a->_fanSystemSt_CurrentFanMode_AutoFan, "");
	soap_out_unsignedInt(soap, "fanSystemSt-FanMode-ElectricHeat", -1, &a->_fanSystemSt_FanMode_ElectricHeat, "");
	soap_out_unsignedInt(soap, "fanSystemSt-FanMode-GeneralFan", -1, &a->_fanSystemSt_FanMode_GeneralFan, "");
	soap_out_unsignedInt(soap, "fanSystemSt-FanMode-Schedule", -1, &a->_fanSystemSt_FanMode_Schedule, "");
	soap_out_unsignedInt(soap, "fanSystemSt-FanMode-SleepingMode", -1, &a->_fanSystemSt_FanMode_SleepingMode, "");
	soap_out_unsignedInt(soap, "fanSystemSt-CurrentFanMode-Manual", -1, &a->_fanSystemSt_CurrentFanMode_Manual, "");
	soap_out_unsignedInt(soap, "fanSystemSt-Wind-Off", -1, &a->_fanSystemSt_Wind_Off, "");
	soap_out_unsignedInt(soap, "fanSystemSt-Wind-Low", -1, &a->_fanSystemSt_Wind_Low, "");
	soap_out_unsignedInt(soap, "fanSystemSt-Wind-Middle", -1, &a->_fanSystemSt_Wind_Middle, "");
	soap_out_unsignedInt(soap, "fanSystemSt-Wind-High", -1, &a->_fanSystemSt_Wind_High, "");
	soap_out_unsignedInt(soap, "fanSystemSt-ReservationSet", -1, &a->_fanSystemSt_ReservationSet, "");
	soap_out_unsignedInt(soap, "fanSystemSt-ReservationSet-Release", -1, &a->_fanSystemSt_ReservationSet_Release, "");
	soap_out_unsignedInt(soap, "fanSystemSt-ReservationSet-Running", -1, &a->_fanSystemSt_ReservationSet_Running, "");
	soap_out_unsignedInt(soap, "fanSystemSt-ReservationSet-NotRunning", -1, &a->_fanSystemSt_ReservationSet_NotRunning, "");
	soap_out_unsignedInt(soap, "fanSystemSt-FanReservationSetMode-Hour", -1, &a->_fanSystemSt_FanReservationSetMode_Hour, "");
	soap_out_unsignedInt(soap, "fanSystemSt-FanReservationSetMode-Minute", -1, &a->_fanSystemSt_FanReservationSetMode_Minute, "");
	soap_out_unsignedInt(soap, "fanSystemSt-FanReservation-Hour", -1, &a->_fanSystemSt_FanReservation_Hour, "");
	soap_out_unsignedInt(soap, "fanSystemSt-FanReservation-Minute", -1, &a->_fanSystemSt_FanReservation_Minute, "");
	soap_out_unsignedInt(soap, "fanSystemSt-SensorMode-NotExistSenosr", -1, &a->_fanSystemSt_SensorMode_NotExistSenosr, "");
	soap_out_unsignedInt(soap, "fanSystemSt-SensorMode-GasSenosr", -1, &a->_fanSystemSt_SensorMode_GasSenosr, "");
	soap_out_unsignedInt(soap, "fanSystemSt-SensorMode-CO2Senosr", -1, &a->_fanSystemSt_SensorMode_CO2Senosr, "");
	soap_out_unsignedInt(soap, "fanSystemSt-DamperMode-NotExist", -1, &a->_fanSystemSt_DamperMode_NotExist, "");
	soap_out_unsignedInt(soap, "fanSystemSt-DamperMode-Exist", -1, &a->_fanSystemSt_DamperMode_Exist, "");
	soap_out_unsignedInt(soap, "fanSystemSt-FilterEmpressMode-Clean", -1, &a->_fanSystemSt_FilterEmpressMode_Clean, "");
	soap_out_unsignedInt(soap, "fanSystemSt-FilterEmpressMode-Change", -1, &a->_fanSystemSt_FilterEmpressMode_Change, "");
	soap_out_unsignedInt(soap, "fanSystemSt-FilterEmpressMode-FEChange", -1, &a->_fanSystemSt_FilterEmpressMode_FEChange, "");
	soap_out_unsignedInt(soap, "fanSystemSt-FilterEmpressMode-Normal", -1, &a->_fanSystemSt_FilterEmpressMode_Normal, "");
	soap_out_unsignedInt(soap, "fanSystemSt-AlarmMode-Normal", -1, &a->_fanSystemSt_AlarmMode_Normal, "");
	soap_out_unsignedInt(soap, "fanSystemSt-AlarmMode-HighSpeedMotor", -1, &a->_fanSystemSt_AlarmMode_HighSpeedMotor, "");
	soap_out_unsignedInt(soap, "fanSystemSt-AlarmMode-VentilationMotor", -1, &a->_fanSystemSt_AlarmMode_VentilationMotor, "");
	soap_out_unsignedInt(soap, "fanSystemSt-AlarmMode-DamperMotor", -1, &a->_fanSystemSt_AlarmMode_DamperMotor, "");
	soap_out_unsignedInt(soap, "fanSystemSt-AlarmMode-CO2", -1, &a->_fanSystemSt_AlarmMode_CO2, "");
	soap_out_unsignedInt(soap, "fanSystemSt-AlarmMode-TemperatureMotor", -1, &a->_fanSystemSt_AlarmMode_TemperatureMotor, "");
	soap_out_unsignedInt(soap, "fanSystemSt-AlarmMode-OverHeating", -1, &a->_fanSystemSt_AlarmMode_OverHeating, "");
	soap_out_unsignedInt(soap, "fanSystemSt-AlarmMode-DeviceProtect", -1, &a->_fanSystemSt_AlarmMode_DeviceProtect, "");
	soap_out_unsignedInt(soap, "fanSystemSt-CO2-DensityMode-CO2High", -1, &a->_fanSystemSt_CO2_DensityMode_CO2High, "");
	soap_out_unsignedInt(soap, "fanSystemSt-CO2-DensityMode-CO2Low", -1, &a->_fanSystemSt_CO2_DensityMode_CO2Low, "");
	soap_out_unsignedInt(soap, "fanSystemSt-CO2-Density-High", -1, &a->_fanSystemSt_CO2_Density_High, "");
	soap_out_unsignedInt(soap, "fanSystemSt-CO2-Density-Low", -1, &a->_fanSystemSt_CO2_Density_Low, "");
	soap_out_unsignedInt(soap, "fanSystemSt-GAS-Density-Low", -1, &a->_fanSystemSt_GAS_Density_Low, "");
	soap_out_unsignedInt(soap, "fanSystemSt-GAS-Density-Middle", -1, &a->_fanSystemSt_GAS_Density_Middle, "");
	soap_out_unsignedInt(soap, "fanSystemSt-GAS-Density-High", -1, &a->_fanSystemSt_GAS_Density_High, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct xsd_fanSystemProperty * SOAP_FMAC4 soap_get_xsd_fanSystemProperty(struct soap *soap, struct xsd_fanSystemProperty *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd_fanSystemProperty(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct xsd_fanSystemProperty * SOAP_FMAC4 soap_in_xsd_fanSystemProperty(struct soap *soap, const char *tag, struct xsd_fanSystemProperty *a, const char *type)
{
	short soap_flag__fanSystemDo_Power_Off = 1, soap_flag__fanSystemDo_Power_On = 1, soap_flag__fanSystemDo_AutoFan_ElectricHeat = 1, soap_flag__fanSystemDo_AutoFan_GeneralFan = 1, soap_flag__fanSystemDo_FanMode_ElectricHeat = 1, soap_flag__fanSystemDo_FanMode_GeneralFan = 1, soap_flag__fanSystemDo_FanMode_Schedule = 1, soap_flag__fanSystemDo_FanMode_SleepingMode = 1, soap_flag__fanSystemDo_Wind_Off = 1, soap_flag__fanSystemDo_Wind_Low = 1, soap_flag__fanSystemDo_Wind_Middle = 1, soap_flag__fanSystemDo_Wind_High = 1, soap_flag__fanSystemDo_ReservationSet = 1, soap_flag__fanSystemDo_ReservationSet_Release = 1, soap_flag__fanSystemDo_ReservationSet_Running = 1, soap_flag__fanSystemDo_ReservationSet_NotRunning = 1, soap_flag__fanSystemSt_Power_Off = 1, soap_flag__fanSystemSt_Power_On = 1, soap_flag__fanSystemSt_AutoFan_ElectricHeat = 1, soap_flag__fanSystemSt_AutoFan_GeneralFan = 1, soap_flag__fanSystemSt_CurrentFanMode_AutoFan = 1, soap_flag__fanSystemSt_FanMode_ElectricHeat = 1, soap_flag__fanSystemSt_FanMode_GeneralFan = 1, soap_flag__fanSystemSt_FanMode_Schedule = 1, soap_flag__fanSystemSt_FanMode_SleepingMode = 1, soap_flag__fanSystemSt_CurrentFanMode_Manual = 1, soap_flag__fanSystemSt_Wind_Off = 1, soap_flag__fanSystemSt_Wind_Low = 1, soap_flag__fanSystemSt_Wind_Middle = 1, soap_flag__fanSystemSt_Wind_High = 1, soap_flag__fanSystemSt_ReservationSet = 1, soap_flag__fanSystemSt_ReservationSet_Release = 1, soap_flag__fanSystemSt_ReservationSet_Running = 1, soap_flag__fanSystemSt_ReservationSet_NotRunning = 1, soap_flag__fanSystemSt_FanReservationSetMode_Hour = 1, soap_flag__fanSystemSt_FanReservationSetMode_Minute = 1, soap_flag__fanSystemSt_FanReservation_Hour = 7, soap_flag__fanSystemSt_FanReservation_Minute = 7, soap_flag__fanSystemSt_SensorMode_NotExistSenosr = 1, soap_flag__fanSystemSt_SensorMode_GasSenosr = 1, soap_flag__fanSystemSt_SensorMode_CO2Senosr = 1, soap_flag__fanSystemSt_DamperMode_NotExist = 1, soap_flag__fanSystemSt_DamperMode_Exist = 1, soap_flag__fanSystemSt_FilterEmpressMode_Clean = 1, soap_flag__fanSystemSt_FilterEmpressMode_Change = 1, soap_flag__fanSystemSt_FilterEmpressMode_FEChange = 1, soap_flag__fanSystemSt_FilterEmpressMode_Normal = 1, soap_flag__fanSystemSt_AlarmMode_Normal = 1, soap_flag__fanSystemSt_AlarmMode_HighSpeedMotor = 1, soap_flag__fanSystemSt_AlarmMode_VentilationMotor = 1, soap_flag__fanSystemSt_AlarmMode_DamperMotor = 1, soap_flag__fanSystemSt_AlarmMode_CO2 = 1, soap_flag__fanSystemSt_AlarmMode_TemperatureMotor = 1, soap_flag__fanSystemSt_AlarmMode_OverHeating = 1, soap_flag__fanSystemSt_AlarmMode_DeviceProtect = 1, soap_flag__fanSystemSt_CO2_DensityMode_CO2High = 1, soap_flag__fanSystemSt_CO2_DensityMode_CO2Low = 1, soap_flag__fanSystemSt_CO2_Density_High = 7, soap_flag__fanSystemSt_CO2_Density_Low = 7, soap_flag__fanSystemSt_GAS_Density_Low = 1, soap_flag__fanSystemSt_GAS_Density_Middle = 1, soap_flag__fanSystemSt_GAS_Density_High = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct xsd_fanSystemProperty *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_xsd_fanSystemProperty, sizeof(struct xsd_fanSystemProperty), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xsd_fanSystemProperty(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__fanSystemDo_Power_Off && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemDo_Power_Off, "xsd:unsignedInt"))
				{	soap_flag__fanSystemDo_Power_Off--;
					continue;
				}
			if (soap_flag__fanSystemDo_Power_On && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemDo_Power_On, "xsd:unsignedInt"))
				{	soap_flag__fanSystemDo_Power_On--;
					continue;
				}
			if (soap_flag__fanSystemDo_AutoFan_ElectricHeat && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemDo_AutoFan_ElectricHeat, "xsd:unsignedInt"))
				{	soap_flag__fanSystemDo_AutoFan_ElectricHeat--;
					continue;
				}
			if (soap_flag__fanSystemDo_AutoFan_GeneralFan && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemDo_AutoFan_GeneralFan, "xsd:unsignedInt"))
				{	soap_flag__fanSystemDo_AutoFan_GeneralFan--;
					continue;
				}
			if (soap_flag__fanSystemDo_FanMode_ElectricHeat && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemDo_FanMode_ElectricHeat, "xsd:unsignedInt"))
				{	soap_flag__fanSystemDo_FanMode_ElectricHeat--;
					continue;
				}
			if (soap_flag__fanSystemDo_FanMode_GeneralFan && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemDo_FanMode_GeneralFan, "xsd:unsignedInt"))
				{	soap_flag__fanSystemDo_FanMode_GeneralFan--;
					continue;
				}
			if (soap_flag__fanSystemDo_FanMode_Schedule && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemDo_FanMode_Schedule, "xsd:unsignedInt"))
				{	soap_flag__fanSystemDo_FanMode_Schedule--;
					continue;
				}
			if (soap_flag__fanSystemDo_FanMode_SleepingMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemDo_FanMode_SleepingMode, "xsd:unsignedInt"))
				{	soap_flag__fanSystemDo_FanMode_SleepingMode--;
					continue;
				}
			if (soap_flag__fanSystemDo_Wind_Off && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemDo_Wind_Off, "xsd:unsignedInt"))
				{	soap_flag__fanSystemDo_Wind_Off--;
					continue;
				}
			if (soap_flag__fanSystemDo_Wind_Low && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemDo_Wind_Low, "xsd:unsignedInt"))
				{	soap_flag__fanSystemDo_Wind_Low--;
					continue;
				}
			if (soap_flag__fanSystemDo_Wind_Middle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemDo_Wind_Middle, "xsd:unsignedInt"))
				{	soap_flag__fanSystemDo_Wind_Middle--;
					continue;
				}
			if (soap_flag__fanSystemDo_Wind_High && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemDo_Wind_High, "xsd:unsignedInt"))
				{	soap_flag__fanSystemDo_Wind_High--;
					continue;
				}
			if (soap_flag__fanSystemDo_ReservationSet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemDo_ReservationSet, "xsd:unsignedInt"))
				{	soap_flag__fanSystemDo_ReservationSet--;
					continue;
				}
			if (soap_flag__fanSystemDo_ReservationSet_Release && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemDo_ReservationSet_Release, "xsd:unsignedInt"))
				{	soap_flag__fanSystemDo_ReservationSet_Release--;
					continue;
				}
			if (soap_flag__fanSystemDo_ReservationSet_Running && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemDo_ReservationSet_Running, "xsd:unsignedInt"))
				{	soap_flag__fanSystemDo_ReservationSet_Running--;
					continue;
				}
			if (soap_flag__fanSystemDo_ReservationSet_NotRunning && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemDo_ReservationSet_NotRunning, "xsd:unsignedInt"))
				{	soap_flag__fanSystemDo_ReservationSet_NotRunning--;
					continue;
				}
			if (soap_flag__fanSystemSt_Power_Off && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_Power_Off, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_Power_Off--;
					continue;
				}
			if (soap_flag__fanSystemSt_Power_On && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_Power_On, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_Power_On--;
					continue;
				}
			if (soap_flag__fanSystemSt_AutoFan_ElectricHeat && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_AutoFan_ElectricHeat, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_AutoFan_ElectricHeat--;
					continue;
				}
			if (soap_flag__fanSystemSt_AutoFan_GeneralFan && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_AutoFan_GeneralFan, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_AutoFan_GeneralFan--;
					continue;
				}
			if (soap_flag__fanSystemSt_CurrentFanMode_AutoFan && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_CurrentFanMode_AutoFan, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_CurrentFanMode_AutoFan--;
					continue;
				}
			if (soap_flag__fanSystemSt_FanMode_ElectricHeat && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_FanMode_ElectricHeat, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_FanMode_ElectricHeat--;
					continue;
				}
			if (soap_flag__fanSystemSt_FanMode_GeneralFan && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_FanMode_GeneralFan, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_FanMode_GeneralFan--;
					continue;
				}
			if (soap_flag__fanSystemSt_FanMode_Schedule && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_FanMode_Schedule, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_FanMode_Schedule--;
					continue;
				}
			if (soap_flag__fanSystemSt_FanMode_SleepingMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_FanMode_SleepingMode, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_FanMode_SleepingMode--;
					continue;
				}
			if (soap_flag__fanSystemSt_CurrentFanMode_Manual && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_CurrentFanMode_Manual, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_CurrentFanMode_Manual--;
					continue;
				}
			if (soap_flag__fanSystemSt_Wind_Off && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_Wind_Off, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_Wind_Off--;
					continue;
				}
			if (soap_flag__fanSystemSt_Wind_Low && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_Wind_Low, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_Wind_Low--;
					continue;
				}
			if (soap_flag__fanSystemSt_Wind_Middle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_Wind_Middle, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_Wind_Middle--;
					continue;
				}
			if (soap_flag__fanSystemSt_Wind_High && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_Wind_High, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_Wind_High--;
					continue;
				}
			if (soap_flag__fanSystemSt_ReservationSet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_ReservationSet, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_ReservationSet--;
					continue;
				}
			if (soap_flag__fanSystemSt_ReservationSet_Release && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_ReservationSet_Release, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_ReservationSet_Release--;
					continue;
				}
			if (soap_flag__fanSystemSt_ReservationSet_Running && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_ReservationSet_Running, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_ReservationSet_Running--;
					continue;
				}
			if (soap_flag__fanSystemSt_ReservationSet_NotRunning && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_ReservationSet_NotRunning, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_ReservationSet_NotRunning--;
					continue;
				}
			if (soap_flag__fanSystemSt_FanReservationSetMode_Hour && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_FanReservationSetMode_Hour, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_FanReservationSetMode_Hour--;
					continue;
				}
			if (soap_flag__fanSystemSt_FanReservationSetMode_Minute && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_FanReservationSetMode_Minute, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_FanReservationSetMode_Minute--;
					continue;
				}
			if (soap_flag__fanSystemSt_FanReservation_Hour && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_FanReservation_Hour, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_FanReservation_Hour--;
					continue;
				}
			if (soap_flag__fanSystemSt_FanReservation_Minute && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_FanReservation_Minute, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_FanReservation_Minute--;
					continue;
				}
			if (soap_flag__fanSystemSt_SensorMode_NotExistSenosr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_SensorMode_NotExistSenosr, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_SensorMode_NotExistSenosr--;
					continue;
				}
			if (soap_flag__fanSystemSt_SensorMode_GasSenosr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_SensorMode_GasSenosr, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_SensorMode_GasSenosr--;
					continue;
				}
			if (soap_flag__fanSystemSt_SensorMode_CO2Senosr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_SensorMode_CO2Senosr, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_SensorMode_CO2Senosr--;
					continue;
				}
			if (soap_flag__fanSystemSt_DamperMode_NotExist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_DamperMode_NotExist, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_DamperMode_NotExist--;
					continue;
				}
			if (soap_flag__fanSystemSt_DamperMode_Exist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_DamperMode_Exist, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_DamperMode_Exist--;
					continue;
				}
			if (soap_flag__fanSystemSt_FilterEmpressMode_Clean && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_FilterEmpressMode_Clean, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_FilterEmpressMode_Clean--;
					continue;
				}
			if (soap_flag__fanSystemSt_FilterEmpressMode_Change && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_FilterEmpressMode_Change, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_FilterEmpressMode_Change--;
					continue;
				}
			if (soap_flag__fanSystemSt_FilterEmpressMode_FEChange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_FilterEmpressMode_FEChange, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_FilterEmpressMode_FEChange--;
					continue;
				}
			if (soap_flag__fanSystemSt_FilterEmpressMode_Normal && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_FilterEmpressMode_Normal, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_FilterEmpressMode_Normal--;
					continue;
				}
			if (soap_flag__fanSystemSt_AlarmMode_Normal && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_AlarmMode_Normal, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_AlarmMode_Normal--;
					continue;
				}
			if (soap_flag__fanSystemSt_AlarmMode_HighSpeedMotor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_AlarmMode_HighSpeedMotor, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_AlarmMode_HighSpeedMotor--;
					continue;
				}
			if (soap_flag__fanSystemSt_AlarmMode_VentilationMotor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_AlarmMode_VentilationMotor, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_AlarmMode_VentilationMotor--;
					continue;
				}
			if (soap_flag__fanSystemSt_AlarmMode_DamperMotor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_AlarmMode_DamperMotor, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_AlarmMode_DamperMotor--;
					continue;
				}
			if (soap_flag__fanSystemSt_AlarmMode_CO2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_AlarmMode_CO2, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_AlarmMode_CO2--;
					continue;
				}
			if (soap_flag__fanSystemSt_AlarmMode_TemperatureMotor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_AlarmMode_TemperatureMotor, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_AlarmMode_TemperatureMotor--;
					continue;
				}
			if (soap_flag__fanSystemSt_AlarmMode_OverHeating && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_AlarmMode_OverHeating, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_AlarmMode_OverHeating--;
					continue;
				}
			if (soap_flag__fanSystemSt_AlarmMode_DeviceProtect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_AlarmMode_DeviceProtect, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_AlarmMode_DeviceProtect--;
					continue;
				}
			if (soap_flag__fanSystemSt_CO2_DensityMode_CO2High && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_CO2_DensityMode_CO2High, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_CO2_DensityMode_CO2High--;
					continue;
				}
			if (soap_flag__fanSystemSt_CO2_DensityMode_CO2Low && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_CO2_DensityMode_CO2Low, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_CO2_DensityMode_CO2Low--;
					continue;
				}
			if (soap_flag__fanSystemSt_CO2_Density_High && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_CO2_Density_High, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_CO2_Density_High--;
					continue;
				}
			if (soap_flag__fanSystemSt_CO2_Density_Low && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_CO2_Density_Low, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_CO2_Density_Low--;
					continue;
				}
			if (soap_flag__fanSystemSt_GAS_Density_Low && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_GAS_Density_Low, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_GAS_Density_Low--;
					continue;
				}
			if (soap_flag__fanSystemSt_GAS_Density_Middle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_GAS_Density_Middle, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_GAS_Density_Middle--;
					continue;
				}
			if (soap_flag__fanSystemSt_GAS_Density_High && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystemSt_GAS_Density_High, "xsd:unsignedInt"))
				{	soap_flag__fanSystemSt_GAS_Density_High--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__fanSystemDo_Power_Off > 0 || soap_flag__fanSystemDo_Power_On > 0 || soap_flag__fanSystemDo_AutoFan_ElectricHeat > 0 || soap_flag__fanSystemDo_AutoFan_GeneralFan > 0 || soap_flag__fanSystemDo_FanMode_ElectricHeat > 0 || soap_flag__fanSystemDo_FanMode_GeneralFan > 0 || soap_flag__fanSystemDo_FanMode_Schedule > 0 || soap_flag__fanSystemDo_FanMode_SleepingMode > 0 || soap_flag__fanSystemDo_Wind_Off > 0 || soap_flag__fanSystemDo_Wind_Low > 0 || soap_flag__fanSystemDo_Wind_Middle > 0 || soap_flag__fanSystemDo_Wind_High > 0 || soap_flag__fanSystemDo_ReservationSet > 0 || soap_flag__fanSystemDo_ReservationSet_Release > 0 || soap_flag__fanSystemDo_ReservationSet_Running > 0 || soap_flag__fanSystemDo_ReservationSet_NotRunning > 0 || soap_flag__fanSystemSt_Power_Off > 0 || soap_flag__fanSystemSt_Power_On > 0 || soap_flag__fanSystemSt_AutoFan_ElectricHeat > 0 || soap_flag__fanSystemSt_AutoFan_GeneralFan > 0 || soap_flag__fanSystemSt_CurrentFanMode_AutoFan > 0 || soap_flag__fanSystemSt_FanMode_ElectricHeat > 0 || soap_flag__fanSystemSt_FanMode_GeneralFan > 0 || soap_flag__fanSystemSt_FanMode_Schedule > 0 || soap_flag__fanSystemSt_FanMode_SleepingMode > 0 || soap_flag__fanSystemSt_CurrentFanMode_Manual > 0 || soap_flag__fanSystemSt_Wind_Off > 0 || soap_flag__fanSystemSt_Wind_Low > 0 || soap_flag__fanSystemSt_Wind_Middle > 0 || soap_flag__fanSystemSt_Wind_High > 0 || soap_flag__fanSystemSt_ReservationSet > 0 || soap_flag__fanSystemSt_ReservationSet_Release > 0 || soap_flag__fanSystemSt_ReservationSet_Running > 0 || soap_flag__fanSystemSt_ReservationSet_NotRunning > 0 || soap_flag__fanSystemSt_FanReservationSetMode_Hour > 0 || soap_flag__fanSystemSt_FanReservationSetMode_Minute > 0 || soap_flag__fanSystemSt_FanReservation_Hour > 6 || soap_flag__fanSystemSt_FanReservation_Minute > 6 || soap_flag__fanSystemSt_SensorMode_NotExistSenosr > 0 || soap_flag__fanSystemSt_SensorMode_GasSenosr > 0 || soap_flag__fanSystemSt_SensorMode_CO2Senosr > 0 || soap_flag__fanSystemSt_DamperMode_NotExist > 0 || soap_flag__fanSystemSt_DamperMode_Exist > 0 || soap_flag__fanSystemSt_FilterEmpressMode_Clean > 0 || soap_flag__fanSystemSt_FilterEmpressMode_Change > 0 || soap_flag__fanSystemSt_FilterEmpressMode_FEChange > 0 || soap_flag__fanSystemSt_FilterEmpressMode_Normal > 0 || soap_flag__fanSystemSt_AlarmMode_Normal > 0 || soap_flag__fanSystemSt_AlarmMode_HighSpeedMotor > 0 || soap_flag__fanSystemSt_AlarmMode_VentilationMotor > 0 || soap_flag__fanSystemSt_AlarmMode_DamperMotor > 0 || soap_flag__fanSystemSt_AlarmMode_CO2 > 0 || soap_flag__fanSystemSt_AlarmMode_TemperatureMotor > 0 || soap_flag__fanSystemSt_AlarmMode_OverHeating > 0 || soap_flag__fanSystemSt_AlarmMode_DeviceProtect > 0 || soap_flag__fanSystemSt_CO2_DensityMode_CO2High > 0 || soap_flag__fanSystemSt_CO2_DensityMode_CO2Low > 0 || soap_flag__fanSystemSt_CO2_Density_High > 6 || soap_flag__fanSystemSt_CO2_Density_Low > 6 || soap_flag__fanSystemSt_GAS_Density_Low > 0 || soap_flag__fanSystemSt_GAS_Density_Middle > 0 || soap_flag__fanSystemSt_GAS_Density_High > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xsd_fanSystemProperty *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_xsd_fanSystemProperty, 0, sizeof(struct xsd_fanSystemProperty), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct xsd_fanSystemProperty * SOAP_FMAC6 soap_new_xsd_fanSystemProperty(struct soap *soap, int n)
{	return soap_instantiate_xsd_fanSystemProperty(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd_fanSystemProperty(struct soap *soap, struct xsd_fanSystemProperty *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct xsd_fanSystemProperty * SOAP_FMAC4 soap_instantiate_xsd_fanSystemProperty(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd_fanSystemProperty(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_xsd_fanSystemProperty, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct xsd_fanSystemProperty;
		if (size)
			*size = sizeof(struct xsd_fanSystemProperty);
	}
	else
	{	cp->ptr = (void*)new struct xsd_fanSystemProperty[n];
		if (size)
			*size = n * sizeof(struct xsd_fanSystemProperty);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct xsd_fanSystemProperty*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd_fanSystemProperty(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct xsd_fanSystemProperty %p -> %p\n", q, p));
	*(struct xsd_fanSystemProperty*)p = *(struct xsd_fanSystemProperty*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__systemAirconEvent(struct soap *soap, const struct ns__systemAirconEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.soap_serialize(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__systemAirconEvent(struct soap *soap, struct ns__systemAirconEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.ns__systemAircon::soap_default(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__systemAirconEvent(struct soap *soap, const struct ns__systemAirconEvent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__systemAirconEvent);
	if (soap_out_ns__systemAirconEvent(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__systemAirconEvent(struct soap *soap, const char *tag, int id, const struct ns__systemAirconEvent *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__systemAirconEvent), type);
	a->in.soap_out(soap, "in", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__systemAirconEvent * SOAP_FMAC4 soap_get_ns__systemAirconEvent(struct soap *soap, struct ns__systemAirconEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__systemAirconEvent(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__systemAirconEvent * SOAP_FMAC4 soap_in_ns__systemAirconEvent(struct soap *soap, const char *tag, struct ns__systemAirconEvent *a, const char *type)
{
	short soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__systemAirconEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__systemAirconEvent, sizeof(struct ns__systemAirconEvent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__systemAirconEvent(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && soap->error == SOAP_TAG_MISMATCH)
				if (a->in.soap_in(soap, "in", "ns:systemAircon"))
				{	soap_flag_in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__systemAirconEvent *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__systemAirconEvent, 0, sizeof(struct ns__systemAirconEvent), 0, soap_copy_ns__systemAirconEvent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__systemAirconEvent * SOAP_FMAC6 soap_new_ns__systemAirconEvent(struct soap *soap, int n)
{	return soap_instantiate_ns__systemAirconEvent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__systemAirconEvent(struct soap *soap, struct ns__systemAirconEvent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__systemAirconEvent * SOAP_FMAC4 soap_instantiate_ns__systemAirconEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__systemAirconEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__systemAirconEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__systemAirconEvent;
		if (size)
			*size = sizeof(struct ns__systemAirconEvent);
	}
	else
	{	cp->ptr = (void*)new struct ns__systemAirconEvent[n];
		if (size)
			*size = n * sizeof(struct ns__systemAirconEvent);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__systemAirconEvent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__systemAirconEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__systemAirconEvent %p -> %p\n", q, p));
	*(struct ns__systemAirconEvent*)p = *(struct ns__systemAirconEvent*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__systemAirconEventResponse(struct soap *soap, const struct ns__systemAirconEventResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__systemAirconEventResponse(struct soap *soap, struct ns__systemAirconEventResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->out = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__systemAirconEventResponse(struct soap *soap, const struct ns__systemAirconEventResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__systemAirconEventResponse);
	if (soap_out_ns__systemAirconEventResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__systemAirconEventResponse(struct soap *soap, const char *tag, int id, const struct ns__systemAirconEventResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__systemAirconEventResponse), type);
	if (a->out)
		soap_element_result(soap, "out");
	soap_out_PointerToint(soap, "out", -1, &a->out, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__systemAirconEventResponse * SOAP_FMAC4 soap_get_ns__systemAirconEventResponse(struct soap *soap, struct ns__systemAirconEventResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__systemAirconEventResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__systemAirconEventResponse * SOAP_FMAC4 soap_in_ns__systemAirconEventResponse(struct soap *soap, const char *tag, struct ns__systemAirconEventResponse *a, const char *type)
{
	short soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__systemAirconEventResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__systemAirconEventResponse, sizeof(struct ns__systemAirconEventResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__systemAirconEventResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "out", &a->out, "xsd:int"))
				{	soap_flag_out--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__systemAirconEventResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__systemAirconEventResponse, 0, sizeof(struct ns__systemAirconEventResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__systemAirconEventResponse * SOAP_FMAC6 soap_new_ns__systemAirconEventResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__systemAirconEventResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__systemAirconEventResponse(struct soap *soap, struct ns__systemAirconEventResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__systemAirconEventResponse * SOAP_FMAC4 soap_instantiate_ns__systemAirconEventResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__systemAirconEventResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__systemAirconEventResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__systemAirconEventResponse;
		if (size)
			*size = sizeof(struct ns__systemAirconEventResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__systemAirconEventResponse[n];
		if (size)
			*size = n * sizeof(struct ns__systemAirconEventResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__systemAirconEventResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__systemAirconEventResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__systemAirconEventResponse %p -> %p\n", q, p));
	*(struct ns__systemAirconEventResponse*)p = *(struct ns__systemAirconEventResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setSystemAircon(struct soap *soap, const struct ns__setSystemAircon *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.soap_serialize(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setSystemAircon(struct soap *soap, struct ns__setSystemAircon *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.ns__systemAircon::soap_default(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setSystemAircon(struct soap *soap, const struct ns__setSystemAircon *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__setSystemAircon);
	if (soap_out_ns__setSystemAircon(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setSystemAircon(struct soap *soap, const char *tag, int id, const struct ns__setSystemAircon *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__setSystemAircon), type);
	a->in.soap_out(soap, "in", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setSystemAircon * SOAP_FMAC4 soap_get_ns__setSystemAircon(struct soap *soap, struct ns__setSystemAircon *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setSystemAircon(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setSystemAircon * SOAP_FMAC4 soap_in_ns__setSystemAircon(struct soap *soap, const char *tag, struct ns__setSystemAircon *a, const char *type)
{
	short soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setSystemAircon *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__setSystemAircon, sizeof(struct ns__setSystemAircon), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__setSystemAircon(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && soap->error == SOAP_TAG_MISMATCH)
				if (a->in.soap_in(soap, "in", "ns:systemAircon"))
				{	soap_flag_in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setSystemAircon *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__setSystemAircon, 0, sizeof(struct ns__setSystemAircon), 0, soap_copy_ns__setSystemAircon);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setSystemAircon * SOAP_FMAC6 soap_new_ns__setSystemAircon(struct soap *soap, int n)
{	return soap_instantiate_ns__setSystemAircon(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setSystemAircon(struct soap *soap, struct ns__setSystemAircon *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setSystemAircon * SOAP_FMAC4 soap_instantiate_ns__setSystemAircon(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setSystemAircon(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__setSystemAircon, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setSystemAircon;
		if (size)
			*size = sizeof(struct ns__setSystemAircon);
	}
	else
	{	cp->ptr = (void*)new struct ns__setSystemAircon[n];
		if (size)
			*size = n * sizeof(struct ns__setSystemAircon);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setSystemAircon*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setSystemAircon(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setSystemAircon %p -> %p\n", q, p));
	*(struct ns__setSystemAircon*)p = *(struct ns__setSystemAircon*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getSystemAircon(struct soap *soap, const struct ns__getSystemAircon *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.soap_serialize(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getSystemAircon(struct soap *soap, struct ns__getSystemAircon *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.ns__systemAircon::soap_default(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getSystemAircon(struct soap *soap, const struct ns__getSystemAircon *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getSystemAircon);
	if (soap_out_ns__getSystemAircon(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getSystemAircon(struct soap *soap, const char *tag, int id, const struct ns__getSystemAircon *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getSystemAircon), type);
	a->in.soap_out(soap, "in", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getSystemAircon * SOAP_FMAC4 soap_get_ns__getSystemAircon(struct soap *soap, struct ns__getSystemAircon *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getSystemAircon(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getSystemAircon * SOAP_FMAC4 soap_in_ns__getSystemAircon(struct soap *soap, const char *tag, struct ns__getSystemAircon *a, const char *type)
{
	short soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getSystemAircon *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getSystemAircon, sizeof(struct ns__getSystemAircon), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__getSystemAircon(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && soap->error == SOAP_TAG_MISMATCH)
				if (a->in.soap_in(soap, "in", "ns:systemAircon"))
				{	soap_flag_in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getSystemAircon *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getSystemAircon, 0, sizeof(struct ns__getSystemAircon), 0, soap_copy_ns__getSystemAircon);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getSystemAircon * SOAP_FMAC6 soap_new_ns__getSystemAircon(struct soap *soap, int n)
{	return soap_instantiate_ns__getSystemAircon(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getSystemAircon(struct soap *soap, struct ns__getSystemAircon *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getSystemAircon * SOAP_FMAC4 soap_instantiate_ns__getSystemAircon(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getSystemAircon(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getSystemAircon, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getSystemAircon;
		if (size)
			*size = sizeof(struct ns__getSystemAircon);
	}
	else
	{	cp->ptr = (void*)new struct ns__getSystemAircon[n];
		if (size)
			*size = n * sizeof(struct ns__getSystemAircon);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getSystemAircon*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getSystemAircon(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getSystemAircon %p -> %p\n", q, p));
	*(struct ns__getSystemAircon*)p = *(struct ns__getSystemAircon*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getSystemAirconItem(struct soap *soap, const struct ns__getSystemAirconItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->order, SOAP_TYPE_cmxDeviceService_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getSystemAirconItem(struct soap *soap, struct ns__getSystemAirconItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->order);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getSystemAirconItem(struct soap *soap, const struct ns__getSystemAirconItem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconItem);
	if (soap_out_ns__getSystemAirconItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getSystemAirconItem(struct soap *soap, const char *tag, int id, const struct ns__getSystemAirconItem *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconItem), type);
	soap_out_int(soap, "order", -1, &a->order, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getSystemAirconItem * SOAP_FMAC4 soap_get_ns__getSystemAirconItem(struct soap *soap, struct ns__getSystemAirconItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getSystemAirconItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getSystemAirconItem * SOAP_FMAC4 soap_in_ns__getSystemAirconItem(struct soap *soap, const char *tag, struct ns__getSystemAirconItem *a, const char *type)
{
	short soap_flag_order = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getSystemAirconItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconItem, sizeof(struct ns__getSystemAirconItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getSystemAirconItem(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_order && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "order", &a->order, "xsd:int"))
				{	soap_flag_order--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_order > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getSystemAirconItem *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconItem, 0, sizeof(struct ns__getSystemAirconItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getSystemAirconItem * SOAP_FMAC6 soap_new_ns__getSystemAirconItem(struct soap *soap, int n)
{	return soap_instantiate_ns__getSystemAirconItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getSystemAirconItem(struct soap *soap, struct ns__getSystemAirconItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getSystemAirconItem * SOAP_FMAC4 soap_instantiate_ns__getSystemAirconItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getSystemAirconItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getSystemAirconItem;
		if (size)
			*size = sizeof(struct ns__getSystemAirconItem);
	}
	else
	{	cp->ptr = (void*)new struct ns__getSystemAirconItem[n];
		if (size)
			*size = n * sizeof(struct ns__getSystemAirconItem);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getSystemAirconItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getSystemAirconItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getSystemAirconItem %p -> %p\n", q, p));
	*(struct ns__getSystemAirconItem*)p = *(struct ns__getSystemAirconItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getSystemAirconPropertyItem(struct soap *soap, const struct ns__getSystemAirconPropertyItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->order, SOAP_TYPE_cmxDeviceService_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getSystemAirconPropertyItem(struct soap *soap, struct ns__getSystemAirconPropertyItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->order);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getSystemAirconPropertyItem(struct soap *soap, const struct ns__getSystemAirconPropertyItem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconPropertyItem);
	if (soap_out_ns__getSystemAirconPropertyItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getSystemAirconPropertyItem(struct soap *soap, const char *tag, int id, const struct ns__getSystemAirconPropertyItem *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconPropertyItem), type);
	soap_out_int(soap, "order", -1, &a->order, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getSystemAirconPropertyItem * SOAP_FMAC4 soap_get_ns__getSystemAirconPropertyItem(struct soap *soap, struct ns__getSystemAirconPropertyItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getSystemAirconPropertyItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getSystemAirconPropertyItem * SOAP_FMAC4 soap_in_ns__getSystemAirconPropertyItem(struct soap *soap, const char *tag, struct ns__getSystemAirconPropertyItem *a, const char *type)
{
	short soap_flag_order = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getSystemAirconPropertyItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconPropertyItem, sizeof(struct ns__getSystemAirconPropertyItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getSystemAirconPropertyItem(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_order && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "order", &a->order, "xsd:int"))
				{	soap_flag_order--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_order > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getSystemAirconPropertyItem *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconPropertyItem, 0, sizeof(struct ns__getSystemAirconPropertyItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getSystemAirconPropertyItem * SOAP_FMAC6 soap_new_ns__getSystemAirconPropertyItem(struct soap *soap, int n)
{	return soap_instantiate_ns__getSystemAirconPropertyItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getSystemAirconPropertyItem(struct soap *soap, struct ns__getSystemAirconPropertyItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getSystemAirconPropertyItem * SOAP_FMAC4 soap_instantiate_ns__getSystemAirconPropertyItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getSystemAirconPropertyItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconPropertyItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getSystemAirconPropertyItem;
		if (size)
			*size = sizeof(struct ns__getSystemAirconPropertyItem);
	}
	else
	{	cp->ptr = (void*)new struct ns__getSystemAirconPropertyItem[n];
		if (size)
			*size = n * sizeof(struct ns__getSystemAirconPropertyItem);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getSystemAirconPropertyItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getSystemAirconPropertyItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getSystemAirconPropertyItem %p -> %p\n", q, p));
	*(struct ns__getSystemAirconPropertyItem*)p = *(struct ns__getSystemAirconPropertyItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getSystemAirconCount(struct soap *soap, const struct ns__getSystemAirconCount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getSystemAirconCount(struct soap *soap, struct ns__getSystemAirconCount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getSystemAirconCount(struct soap *soap, const struct ns__getSystemAirconCount *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconCount);
	if (soap_out_ns__getSystemAirconCount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getSystemAirconCount(struct soap *soap, const char *tag, int id, const struct ns__getSystemAirconCount *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconCount), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getSystemAirconCount * SOAP_FMAC4 soap_get_ns__getSystemAirconCount(struct soap *soap, struct ns__getSystemAirconCount *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getSystemAirconCount(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getSystemAirconCount * SOAP_FMAC4 soap_in_ns__getSystemAirconCount(struct soap *soap, const char *tag, struct ns__getSystemAirconCount *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getSystemAirconCount *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconCount, sizeof(struct ns__getSystemAirconCount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getSystemAirconCount(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getSystemAirconCount *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconCount, 0, sizeof(struct ns__getSystemAirconCount), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getSystemAirconCount * SOAP_FMAC6 soap_new_ns__getSystemAirconCount(struct soap *soap, int n)
{	return soap_instantiate_ns__getSystemAirconCount(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getSystemAirconCount(struct soap *soap, struct ns__getSystemAirconCount *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getSystemAirconCount * SOAP_FMAC4 soap_instantiate_ns__getSystemAirconCount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getSystemAirconCount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconCount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getSystemAirconCount;
		if (size)
			*size = sizeof(struct ns__getSystemAirconCount);
	}
	else
	{	cp->ptr = (void*)new struct ns__getSystemAirconCount[n];
		if (size)
			*size = n * sizeof(struct ns__getSystemAirconCount);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getSystemAirconCount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getSystemAirconCount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getSystemAirconCount %p -> %p\n", q, p));
	*(struct ns__getSystemAirconCount*)p = *(struct ns__getSystemAirconCount*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getSystemAirconCountResponse(struct soap *soap, const struct ns__getSystemAirconCountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getSystemAirconCountResponse(struct soap *soap, struct ns__getSystemAirconCountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->out = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getSystemAirconCountResponse(struct soap *soap, const struct ns__getSystemAirconCountResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconCountResponse);
	if (soap_out_ns__getSystemAirconCountResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getSystemAirconCountResponse(struct soap *soap, const char *tag, int id, const struct ns__getSystemAirconCountResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconCountResponse), type);
	if (a->out)
		soap_element_result(soap, "out");
	soap_out_PointerToint(soap, "out", -1, &a->out, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getSystemAirconCountResponse * SOAP_FMAC4 soap_get_ns__getSystemAirconCountResponse(struct soap *soap, struct ns__getSystemAirconCountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getSystemAirconCountResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getSystemAirconCountResponse * SOAP_FMAC4 soap_in_ns__getSystemAirconCountResponse(struct soap *soap, const char *tag, struct ns__getSystemAirconCountResponse *a, const char *type)
{
	short soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getSystemAirconCountResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconCountResponse, sizeof(struct ns__getSystemAirconCountResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getSystemAirconCountResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "out", &a->out, "xsd:int"))
				{	soap_flag_out--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getSystemAirconCountResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconCountResponse, 0, sizeof(struct ns__getSystemAirconCountResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getSystemAirconCountResponse * SOAP_FMAC6 soap_new_ns__getSystemAirconCountResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getSystemAirconCountResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getSystemAirconCountResponse(struct soap *soap, struct ns__getSystemAirconCountResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getSystemAirconCountResponse * SOAP_FMAC4 soap_instantiate_ns__getSystemAirconCountResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getSystemAirconCountResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconCountResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getSystemAirconCountResponse;
		if (size)
			*size = sizeof(struct ns__getSystemAirconCountResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__getSystemAirconCountResponse[n];
		if (size)
			*size = n * sizeof(struct ns__getSystemAirconCountResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getSystemAirconCountResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getSystemAirconCountResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getSystemAirconCountResponse %p -> %p\n", q, p));
	*(struct ns__getSystemAirconCountResponse*)p = *(struct ns__getSystemAirconCountResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd_systemAirconProperty(struct soap *soap, const struct xsd_systemAirconProperty *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd_systemAirconProperty(struct soap *soap, struct xsd_systemAirconProperty *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->_systemAirconDo_Power_Start);
	soap_default_unsignedInt(soap, &a->_systemAirconDo_Power_Stop);
	soap_default_unsignedInt(soap, &a->_systemAirconDo_Power_AllRunning);
	soap_default_unsignedInt(soap, &a->_systemAirconDo_Power_AllStop);
	soap_default_unsignedInt(soap, &a->_systemAirconDo_WindDirection_UpDown);
	soap_default_unsignedInt(soap, &a->_systemAirconDo_WindDirection_LeftRight);
	soap_default_unsignedInt(soap, &a->_systemAirconDo_WindDirection_UpDownLeftRight);
	soap_default_unsignedInt(soap, &a->_systemAirconDo_WindDirection_Stop);
	soap_default_unsignedInt(soap, &a->_systemAirconDo_WindPower_Auto);
	soap_default_unsignedInt(soap, &a->_systemAirconDo_WindPower_Breeze);
	soap_default_unsignedInt(soap, &a->_systemAirconDo_WindPower_Middle);
	soap_default_unsignedInt(soap, &a->_systemAirconDo_WindPower_Super);
	soap_default_unsignedInt(soap, &a->_systemAirconDo_WindPower_Natural);
	soap_default_unsignedInt(soap, &a->_systemAirconDo_Drive_Auto);
	soap_default_unsignedInt(soap, &a->_systemAirconDo_Drive_Cool);
	soap_default_unsignedInt(soap, &a->_systemAirconDo_Drive_Humidity);
	soap_default_unsignedInt(soap, &a->_systemAirconDo_Drive_Ventilation);
	soap_default_unsignedInt(soap, &a->_systemAirconDo_Drive_Heating);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_Power_Start);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_Power_Stop);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_WindDirection_UpDown);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_WindDirection_LeftRight);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_WindDirection_UpDownLeftRight);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_WindDirection_Stop);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_WindPower_Auto);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_WindPower_Breeze);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_WindPower_Middle);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_WindPower_Super);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_WindPower_Natural);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_Drive_Driving);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_Drive_EventRelease);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_Drive_Auto);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_Drive_JaeSang);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_Drive_Ventilation);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_Drive_Humidity);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_Drive_Cooling);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_Drive_Heating);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_Tracking_Success);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_Tracking_Fail);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_Tracking_Searching);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_Tracking_End);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_Installation_Not_Exist);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_InnerRoom_Error_Normal);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_InnerRoom_Error_InnerTemperature);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_InnerRoom_Error_EVA_IN);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_InnerRoom_Error_FAN);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_InnerRoom_Error_Communication);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_InnerRoom_Error_Floating_Switch);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_InnerRoom_Error_Open_Two);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_InnerRoom_Error_EVA_OUT);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_OutRoom_Error_Normal);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_OutRoom_Error_Temp);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_OutRoom_Error_Sensor);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_OutRoom_Error_Cond);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_OutRoom_Error_Commnuication);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_OutRoom_Error_Error);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_OutRoom_Error_lowPower);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_OutRoom_Error_MagicalPower);
	soap_default_unsignedInt(soap, &a->_systemAirconSt_OutRoom_Error_InitCommunication);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd_systemAirconProperty(struct soap *soap, const struct xsd_systemAirconProperty *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_xsd_systemAirconProperty);
	if (soap_out_xsd_systemAirconProperty(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd_systemAirconProperty(struct soap *soap, const char *tag, int id, const struct xsd_systemAirconProperty *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_xsd_systemAirconProperty), type);
	soap_out_unsignedInt(soap, "systemAirconDo-Power-Start", -1, &a->_systemAirconDo_Power_Start, "");
	soap_out_unsignedInt(soap, "systemAirconDo-Power-Stop", -1, &a->_systemAirconDo_Power_Stop, "");
	soap_out_unsignedInt(soap, "systemAirconDo-Power-AllRunning", -1, &a->_systemAirconDo_Power_AllRunning, "");
	soap_out_unsignedInt(soap, "systemAirconDo-Power-AllStop", -1, &a->_systemAirconDo_Power_AllStop, "");
	soap_out_unsignedInt(soap, "systemAirconDo-WindDirection-UpDown", -1, &a->_systemAirconDo_WindDirection_UpDown, "");
	soap_out_unsignedInt(soap, "systemAirconDo-WindDirection-LeftRight", -1, &a->_systemAirconDo_WindDirection_LeftRight, "");
	soap_out_unsignedInt(soap, "systemAirconDo-WindDirection-UpDownLeftRight", -1, &a->_systemAirconDo_WindDirection_UpDownLeftRight, "");
	soap_out_unsignedInt(soap, "systemAirconDo-WindDirection-Stop", -1, &a->_systemAirconDo_WindDirection_Stop, "");
	soap_out_unsignedInt(soap, "systemAirconDo-WindPower-Auto", -1, &a->_systemAirconDo_WindPower_Auto, "");
	soap_out_unsignedInt(soap, "systemAirconDo-WindPower-Breeze", -1, &a->_systemAirconDo_WindPower_Breeze, "");
	soap_out_unsignedInt(soap, "systemAirconDo-WindPower-Middle", -1, &a->_systemAirconDo_WindPower_Middle, "");
	soap_out_unsignedInt(soap, "systemAirconDo-WindPower-Super", -1, &a->_systemAirconDo_WindPower_Super, "");
	soap_out_unsignedInt(soap, "systemAirconDo-WindPower-Natural", -1, &a->_systemAirconDo_WindPower_Natural, "");
	soap_out_unsignedInt(soap, "systemAirconDo-Drive-Auto", -1, &a->_systemAirconDo_Drive_Auto, "");
	soap_out_unsignedInt(soap, "systemAirconDo-Drive-Cool", -1, &a->_systemAirconDo_Drive_Cool, "");
	soap_out_unsignedInt(soap, "systemAirconDo-Drive-Humidity", -1, &a->_systemAirconDo_Drive_Humidity, "");
	soap_out_unsignedInt(soap, "systemAirconDo-Drive-Ventilation", -1, &a->_systemAirconDo_Drive_Ventilation, "");
	soap_out_unsignedInt(soap, "systemAirconDo-Drive-Heating", -1, &a->_systemAirconDo_Drive_Heating, "");
	soap_out_unsignedInt(soap, "systemAirconSt-Power-Start", -1, &a->_systemAirconSt_Power_Start, "");
	soap_out_unsignedInt(soap, "systemAirconSt-Power-Stop", -1, &a->_systemAirconSt_Power_Stop, "");
	soap_out_unsignedInt(soap, "systemAirconSt-WindDirection-UpDown", -1, &a->_systemAirconSt_WindDirection_UpDown, "");
	soap_out_unsignedInt(soap, "systemAirconSt-WindDirection-LeftRight", -1, &a->_systemAirconSt_WindDirection_LeftRight, "");
	soap_out_unsignedInt(soap, "systemAirconSt-WindDirection-UpDownLeftRight", -1, &a->_systemAirconSt_WindDirection_UpDownLeftRight, "");
	soap_out_unsignedInt(soap, "systemAirconSt-WindDirection-Stop", -1, &a->_systemAirconSt_WindDirection_Stop, "");
	soap_out_unsignedInt(soap, "systemAirconSt-WindPower-Auto", -1, &a->_systemAirconSt_WindPower_Auto, "");
	soap_out_unsignedInt(soap, "systemAirconSt-WindPower-Breeze", -1, &a->_systemAirconSt_WindPower_Breeze, "");
	soap_out_unsignedInt(soap, "systemAirconSt-WindPower-Middle", -1, &a->_systemAirconSt_WindPower_Middle, "");
	soap_out_unsignedInt(soap, "systemAirconSt-WindPower-Super", -1, &a->_systemAirconSt_WindPower_Super, "");
	soap_out_unsignedInt(soap, "systemAirconSt-WindPower-Natural", -1, &a->_systemAirconSt_WindPower_Natural, "");
	soap_out_unsignedInt(soap, "systemAirconSt-Drive-Driving", -1, &a->_systemAirconSt_Drive_Driving, "");
	soap_out_unsignedInt(soap, "systemAirconSt-Drive-EventRelease", -1, &a->_systemAirconSt_Drive_EventRelease, "");
	soap_out_unsignedInt(soap, "systemAirconSt-Drive-Auto", -1, &a->_systemAirconSt_Drive_Auto, "");
	soap_out_unsignedInt(soap, "systemAirconSt-Drive-JaeSang", -1, &a->_systemAirconSt_Drive_JaeSang, "");
	soap_out_unsignedInt(soap, "systemAirconSt-Drive-Ventilation", -1, &a->_systemAirconSt_Drive_Ventilation, "");
	soap_out_unsignedInt(soap, "systemAirconSt-Drive-Humidity", -1, &a->_systemAirconSt_Drive_Humidity, "");
	soap_out_unsignedInt(soap, "systemAirconSt-Drive-Cooling", -1, &a->_systemAirconSt_Drive_Cooling, "");
	soap_out_unsignedInt(soap, "systemAirconSt-Drive-Heating", -1, &a->_systemAirconSt_Drive_Heating, "");
	soap_out_unsignedInt(soap, "systemAirconSt-Tracking-Success", -1, &a->_systemAirconSt_Tracking_Success, "");
	soap_out_unsignedInt(soap, "systemAirconSt-Tracking-Fail", -1, &a->_systemAirconSt_Tracking_Fail, "");
	soap_out_unsignedInt(soap, "systemAirconSt-Tracking-Searching", -1, &a->_systemAirconSt_Tracking_Searching, "");
	soap_out_unsignedInt(soap, "systemAirconSt-Tracking-End", -1, &a->_systemAirconSt_Tracking_End, "");
	soap_out_unsignedInt(soap, "systemAirconSt-Installation-Not-Exist", -1, &a->_systemAirconSt_Installation_Not_Exist, "");
	soap_out_unsignedInt(soap, "systemAirconSt-InnerRoom-Error-Normal", -1, &a->_systemAirconSt_InnerRoom_Error_Normal, "");
	soap_out_unsignedInt(soap, "systemAirconSt-InnerRoom-Error-InnerTemperature", -1, &a->_systemAirconSt_InnerRoom_Error_InnerTemperature, "");
	soap_out_unsignedInt(soap, "systemAirconSt-InnerRoom-Error-EVA-IN", -1, &a->_systemAirconSt_InnerRoom_Error_EVA_IN, "");
	soap_out_unsignedInt(soap, "systemAirconSt-InnerRoom-Error-FAN", -1, &a->_systemAirconSt_InnerRoom_Error_FAN, "");
	soap_out_unsignedInt(soap, "systemAirconSt-InnerRoom-Error-Communication", -1, &a->_systemAirconSt_InnerRoom_Error_Communication, "");
	soap_out_unsignedInt(soap, "systemAirconSt-InnerRoom-Error-Floating-Switch", -1, &a->_systemAirconSt_InnerRoom_Error_Floating_Switch, "");
	soap_out_unsignedInt(soap, "systemAirconSt-InnerRoom-Error-Open-Two", -1, &a->_systemAirconSt_InnerRoom_Error_Open_Two, "");
	soap_out_unsignedInt(soap, "systemAirconSt-InnerRoom-Error-EVA-OUT", -1, &a->_systemAirconSt_InnerRoom_Error_EVA_OUT, "");
	soap_out_unsignedInt(soap, "systemAirconSt-OutRoom-Error-Normal", -1, &a->_systemAirconSt_OutRoom_Error_Normal, "");
	soap_out_unsignedInt(soap, "systemAirconSt-OutRoom-Error-Temp", -1, &a->_systemAirconSt_OutRoom_Error_Temp, "");
	soap_out_unsignedInt(soap, "systemAirconSt-OutRoom-Error-Sensor", -1, &a->_systemAirconSt_OutRoom_Error_Sensor, "");
	soap_out_unsignedInt(soap, "systemAirconSt-OutRoom-Error-Cond", -1, &a->_systemAirconSt_OutRoom_Error_Cond, "");
	soap_out_unsignedInt(soap, "systemAirconSt-OutRoom-Error-Commnuication", -1, &a->_systemAirconSt_OutRoom_Error_Commnuication, "");
	soap_out_unsignedInt(soap, "systemAirconSt-OutRoom-Error-Error", -1, &a->_systemAirconSt_OutRoom_Error_Error, "");
	soap_out_unsignedInt(soap, "systemAirconSt-OutRoom-Error-lowPower", -1, &a->_systemAirconSt_OutRoom_Error_lowPower, "");
	soap_out_unsignedInt(soap, "systemAirconSt-OutRoom-Error-MagicalPower", -1, &a->_systemAirconSt_OutRoom_Error_MagicalPower, "");
	soap_out_unsignedInt(soap, "systemAirconSt-OutRoom-Error-InitCommunication", -1, &a->_systemAirconSt_OutRoom_Error_InitCommunication, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct xsd_systemAirconProperty * SOAP_FMAC4 soap_get_xsd_systemAirconProperty(struct soap *soap, struct xsd_systemAirconProperty *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd_systemAirconProperty(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct xsd_systemAirconProperty * SOAP_FMAC4 soap_in_xsd_systemAirconProperty(struct soap *soap, const char *tag, struct xsd_systemAirconProperty *a, const char *type)
{
	short soap_flag__systemAirconDo_Power_Start = 1, soap_flag__systemAirconDo_Power_Stop = 1, soap_flag__systemAirconDo_Power_AllRunning = 1, soap_flag__systemAirconDo_Power_AllStop = 1, soap_flag__systemAirconDo_WindDirection_UpDown = 1, soap_flag__systemAirconDo_WindDirection_LeftRight = 1, soap_flag__systemAirconDo_WindDirection_UpDownLeftRight = 1, soap_flag__systemAirconDo_WindDirection_Stop = 1, soap_flag__systemAirconDo_WindPower_Auto = 1, soap_flag__systemAirconDo_WindPower_Breeze = 1, soap_flag__systemAirconDo_WindPower_Middle = 1, soap_flag__systemAirconDo_WindPower_Super = 1, soap_flag__systemAirconDo_WindPower_Natural = 1, soap_flag__systemAirconDo_Drive_Auto = 1, soap_flag__systemAirconDo_Drive_Cool = 1, soap_flag__systemAirconDo_Drive_Humidity = 1, soap_flag__systemAirconDo_Drive_Ventilation = 1, soap_flag__systemAirconDo_Drive_Heating = 1, soap_flag__systemAirconSt_Power_Start = 1, soap_flag__systemAirconSt_Power_Stop = 1, soap_flag__systemAirconSt_WindDirection_UpDown = 1, soap_flag__systemAirconSt_WindDirection_LeftRight = 1, soap_flag__systemAirconSt_WindDirection_UpDownLeftRight = 1, soap_flag__systemAirconSt_WindDirection_Stop = 1, soap_flag__systemAirconSt_WindPower_Auto = 1, soap_flag__systemAirconSt_WindPower_Breeze = 1, soap_flag__systemAirconSt_WindPower_Middle = 1, soap_flag__systemAirconSt_WindPower_Super = 1, soap_flag__systemAirconSt_WindPower_Natural = 1, soap_flag__systemAirconSt_Drive_Driving = 1, soap_flag__systemAirconSt_Drive_EventRelease = 1, soap_flag__systemAirconSt_Drive_Auto = 1, soap_flag__systemAirconSt_Drive_JaeSang = 1, soap_flag__systemAirconSt_Drive_Ventilation = 1, soap_flag__systemAirconSt_Drive_Humidity = 1, soap_flag__systemAirconSt_Drive_Cooling = 1, soap_flag__systemAirconSt_Drive_Heating = 1, soap_flag__systemAirconSt_Tracking_Success = 1, soap_flag__systemAirconSt_Tracking_Fail = 1, soap_flag__systemAirconSt_Tracking_Searching = 1, soap_flag__systemAirconSt_Tracking_End = 1, soap_flag__systemAirconSt_Installation_Not_Exist = 1, soap_flag__systemAirconSt_InnerRoom_Error_Normal = 1, soap_flag__systemAirconSt_InnerRoom_Error_InnerTemperature = 1, soap_flag__systemAirconSt_InnerRoom_Error_EVA_IN = 1, soap_flag__systemAirconSt_InnerRoom_Error_FAN = 1, soap_flag__systemAirconSt_InnerRoom_Error_Communication = 1, soap_flag__systemAirconSt_InnerRoom_Error_Floating_Switch = 1, soap_flag__systemAirconSt_InnerRoom_Error_Open_Two = 1, soap_flag__systemAirconSt_InnerRoom_Error_EVA_OUT = 1, soap_flag__systemAirconSt_OutRoom_Error_Normal = 1, soap_flag__systemAirconSt_OutRoom_Error_Temp = 1, soap_flag__systemAirconSt_OutRoom_Error_Sensor = 1, soap_flag__systemAirconSt_OutRoom_Error_Cond = 1, soap_flag__systemAirconSt_OutRoom_Error_Commnuication = 1, soap_flag__systemAirconSt_OutRoom_Error_Error = 1, soap_flag__systemAirconSt_OutRoom_Error_lowPower = 1, soap_flag__systemAirconSt_OutRoom_Error_MagicalPower = 1, soap_flag__systemAirconSt_OutRoom_Error_InitCommunication = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct xsd_systemAirconProperty *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_xsd_systemAirconProperty, sizeof(struct xsd_systemAirconProperty), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xsd_systemAirconProperty(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__systemAirconDo_Power_Start && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconDo_Power_Start, "xsd:unsignedInt"))
				{	soap_flag__systemAirconDo_Power_Start--;
					continue;
				}
			if (soap_flag__systemAirconDo_Power_Stop && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconDo_Power_Stop, "xsd:unsignedInt"))
				{	soap_flag__systemAirconDo_Power_Stop--;
					continue;
				}
			if (soap_flag__systemAirconDo_Power_AllRunning && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconDo_Power_AllRunning, "xsd:unsignedInt"))
				{	soap_flag__systemAirconDo_Power_AllRunning--;
					continue;
				}
			if (soap_flag__systemAirconDo_Power_AllStop && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconDo_Power_AllStop, "xsd:unsignedInt"))
				{	soap_flag__systemAirconDo_Power_AllStop--;
					continue;
				}
			if (soap_flag__systemAirconDo_WindDirection_UpDown && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconDo_WindDirection_UpDown, "xsd:unsignedInt"))
				{	soap_flag__systemAirconDo_WindDirection_UpDown--;
					continue;
				}
			if (soap_flag__systemAirconDo_WindDirection_LeftRight && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconDo_WindDirection_LeftRight, "xsd:unsignedInt"))
				{	soap_flag__systemAirconDo_WindDirection_LeftRight--;
					continue;
				}
			if (soap_flag__systemAirconDo_WindDirection_UpDownLeftRight && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconDo_WindDirection_UpDownLeftRight, "xsd:unsignedInt"))
				{	soap_flag__systemAirconDo_WindDirection_UpDownLeftRight--;
					continue;
				}
			if (soap_flag__systemAirconDo_WindDirection_Stop && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconDo_WindDirection_Stop, "xsd:unsignedInt"))
				{	soap_flag__systemAirconDo_WindDirection_Stop--;
					continue;
				}
			if (soap_flag__systemAirconDo_WindPower_Auto && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconDo_WindPower_Auto, "xsd:unsignedInt"))
				{	soap_flag__systemAirconDo_WindPower_Auto--;
					continue;
				}
			if (soap_flag__systemAirconDo_WindPower_Breeze && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconDo_WindPower_Breeze, "xsd:unsignedInt"))
				{	soap_flag__systemAirconDo_WindPower_Breeze--;
					continue;
				}
			if (soap_flag__systemAirconDo_WindPower_Middle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconDo_WindPower_Middle, "xsd:unsignedInt"))
				{	soap_flag__systemAirconDo_WindPower_Middle--;
					continue;
				}
			if (soap_flag__systemAirconDo_WindPower_Super && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconDo_WindPower_Super, "xsd:unsignedInt"))
				{	soap_flag__systemAirconDo_WindPower_Super--;
					continue;
				}
			if (soap_flag__systemAirconDo_WindPower_Natural && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconDo_WindPower_Natural, "xsd:unsignedInt"))
				{	soap_flag__systemAirconDo_WindPower_Natural--;
					continue;
				}
			if (soap_flag__systemAirconDo_Drive_Auto && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconDo_Drive_Auto, "xsd:unsignedInt"))
				{	soap_flag__systemAirconDo_Drive_Auto--;
					continue;
				}
			if (soap_flag__systemAirconDo_Drive_Cool && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconDo_Drive_Cool, "xsd:unsignedInt"))
				{	soap_flag__systemAirconDo_Drive_Cool--;
					continue;
				}
			if (soap_flag__systemAirconDo_Drive_Humidity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconDo_Drive_Humidity, "xsd:unsignedInt"))
				{	soap_flag__systemAirconDo_Drive_Humidity--;
					continue;
				}
			if (soap_flag__systemAirconDo_Drive_Ventilation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconDo_Drive_Ventilation, "xsd:unsignedInt"))
				{	soap_flag__systemAirconDo_Drive_Ventilation--;
					continue;
				}
			if (soap_flag__systemAirconDo_Drive_Heating && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconDo_Drive_Heating, "xsd:unsignedInt"))
				{	soap_flag__systemAirconDo_Drive_Heating--;
					continue;
				}
			if (soap_flag__systemAirconSt_Power_Start && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_Power_Start, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_Power_Start--;
					continue;
				}
			if (soap_flag__systemAirconSt_Power_Stop && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_Power_Stop, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_Power_Stop--;
					continue;
				}
			if (soap_flag__systemAirconSt_WindDirection_UpDown && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_WindDirection_UpDown, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_WindDirection_UpDown--;
					continue;
				}
			if (soap_flag__systemAirconSt_WindDirection_LeftRight && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_WindDirection_LeftRight, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_WindDirection_LeftRight--;
					continue;
				}
			if (soap_flag__systemAirconSt_WindDirection_UpDownLeftRight && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_WindDirection_UpDownLeftRight, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_WindDirection_UpDownLeftRight--;
					continue;
				}
			if (soap_flag__systemAirconSt_WindDirection_Stop && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_WindDirection_Stop, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_WindDirection_Stop--;
					continue;
				}
			if (soap_flag__systemAirconSt_WindPower_Auto && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_WindPower_Auto, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_WindPower_Auto--;
					continue;
				}
			if (soap_flag__systemAirconSt_WindPower_Breeze && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_WindPower_Breeze, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_WindPower_Breeze--;
					continue;
				}
			if (soap_flag__systemAirconSt_WindPower_Middle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_WindPower_Middle, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_WindPower_Middle--;
					continue;
				}
			if (soap_flag__systemAirconSt_WindPower_Super && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_WindPower_Super, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_WindPower_Super--;
					continue;
				}
			if (soap_flag__systemAirconSt_WindPower_Natural && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_WindPower_Natural, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_WindPower_Natural--;
					continue;
				}
			if (soap_flag__systemAirconSt_Drive_Driving && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_Drive_Driving, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_Drive_Driving--;
					continue;
				}
			if (soap_flag__systemAirconSt_Drive_EventRelease && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_Drive_EventRelease, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_Drive_EventRelease--;
					continue;
				}
			if (soap_flag__systemAirconSt_Drive_Auto && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_Drive_Auto, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_Drive_Auto--;
					continue;
				}
			if (soap_flag__systemAirconSt_Drive_JaeSang && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_Drive_JaeSang, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_Drive_JaeSang--;
					continue;
				}
			if (soap_flag__systemAirconSt_Drive_Ventilation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_Drive_Ventilation, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_Drive_Ventilation--;
					continue;
				}
			if (soap_flag__systemAirconSt_Drive_Humidity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_Drive_Humidity, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_Drive_Humidity--;
					continue;
				}
			if (soap_flag__systemAirconSt_Drive_Cooling && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_Drive_Cooling, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_Drive_Cooling--;
					continue;
				}
			if (soap_flag__systemAirconSt_Drive_Heating && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_Drive_Heating, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_Drive_Heating--;
					continue;
				}
			if (soap_flag__systemAirconSt_Tracking_Success && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_Tracking_Success, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_Tracking_Success--;
					continue;
				}
			if (soap_flag__systemAirconSt_Tracking_Fail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_Tracking_Fail, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_Tracking_Fail--;
					continue;
				}
			if (soap_flag__systemAirconSt_Tracking_Searching && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_Tracking_Searching, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_Tracking_Searching--;
					continue;
				}
			if (soap_flag__systemAirconSt_Tracking_End && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_Tracking_End, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_Tracking_End--;
					continue;
				}
			if (soap_flag__systemAirconSt_Installation_Not_Exist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_Installation_Not_Exist, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_Installation_Not_Exist--;
					continue;
				}
			if (soap_flag__systemAirconSt_InnerRoom_Error_Normal && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_InnerRoom_Error_Normal, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_InnerRoom_Error_Normal--;
					continue;
				}
			if (soap_flag__systemAirconSt_InnerRoom_Error_InnerTemperature && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_InnerRoom_Error_InnerTemperature, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_InnerRoom_Error_InnerTemperature--;
					continue;
				}
			if (soap_flag__systemAirconSt_InnerRoom_Error_EVA_IN && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_InnerRoom_Error_EVA_IN, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_InnerRoom_Error_EVA_IN--;
					continue;
				}
			if (soap_flag__systemAirconSt_InnerRoom_Error_FAN && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_InnerRoom_Error_FAN, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_InnerRoom_Error_FAN--;
					continue;
				}
			if (soap_flag__systemAirconSt_InnerRoom_Error_Communication && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_InnerRoom_Error_Communication, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_InnerRoom_Error_Communication--;
					continue;
				}
			if (soap_flag__systemAirconSt_InnerRoom_Error_Floating_Switch && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_InnerRoom_Error_Floating_Switch, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_InnerRoom_Error_Floating_Switch--;
					continue;
				}
			if (soap_flag__systemAirconSt_InnerRoom_Error_Open_Two && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_InnerRoom_Error_Open_Two, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_InnerRoom_Error_Open_Two--;
					continue;
				}
			if (soap_flag__systemAirconSt_InnerRoom_Error_EVA_OUT && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_InnerRoom_Error_EVA_OUT, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_InnerRoom_Error_EVA_OUT--;
					continue;
				}
			if (soap_flag__systemAirconSt_OutRoom_Error_Normal && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_OutRoom_Error_Normal, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_OutRoom_Error_Normal--;
					continue;
				}
			if (soap_flag__systemAirconSt_OutRoom_Error_Temp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_OutRoom_Error_Temp, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_OutRoom_Error_Temp--;
					continue;
				}
			if (soap_flag__systemAirconSt_OutRoom_Error_Sensor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_OutRoom_Error_Sensor, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_OutRoom_Error_Sensor--;
					continue;
				}
			if (soap_flag__systemAirconSt_OutRoom_Error_Cond && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_OutRoom_Error_Cond, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_OutRoom_Error_Cond--;
					continue;
				}
			if (soap_flag__systemAirconSt_OutRoom_Error_Commnuication && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_OutRoom_Error_Commnuication, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_OutRoom_Error_Commnuication--;
					continue;
				}
			if (soap_flag__systemAirconSt_OutRoom_Error_Error && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_OutRoom_Error_Error, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_OutRoom_Error_Error--;
					continue;
				}
			if (soap_flag__systemAirconSt_OutRoom_Error_lowPower && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_OutRoom_Error_lowPower, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_OutRoom_Error_lowPower--;
					continue;
				}
			if (soap_flag__systemAirconSt_OutRoom_Error_MagicalPower && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_OutRoom_Error_MagicalPower, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_OutRoom_Error_MagicalPower--;
					continue;
				}
			if (soap_flag__systemAirconSt_OutRoom_Error_InitCommunication && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAirconSt_OutRoom_Error_InitCommunication, "xsd:unsignedInt"))
				{	soap_flag__systemAirconSt_OutRoom_Error_InitCommunication--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__systemAirconDo_Power_Start > 0 || soap_flag__systemAirconDo_Power_Stop > 0 || soap_flag__systemAirconDo_Power_AllRunning > 0 || soap_flag__systemAirconDo_Power_AllStop > 0 || soap_flag__systemAirconDo_WindDirection_UpDown > 0 || soap_flag__systemAirconDo_WindDirection_LeftRight > 0 || soap_flag__systemAirconDo_WindDirection_UpDownLeftRight > 0 || soap_flag__systemAirconDo_WindDirection_Stop > 0 || soap_flag__systemAirconDo_WindPower_Auto > 0 || soap_flag__systemAirconDo_WindPower_Breeze > 0 || soap_flag__systemAirconDo_WindPower_Middle > 0 || soap_flag__systemAirconDo_WindPower_Super > 0 || soap_flag__systemAirconDo_WindPower_Natural > 0 || soap_flag__systemAirconDo_Drive_Auto > 0 || soap_flag__systemAirconDo_Drive_Cool > 0 || soap_flag__systemAirconDo_Drive_Humidity > 0 || soap_flag__systemAirconDo_Drive_Ventilation > 0 || soap_flag__systemAirconDo_Drive_Heating > 0 || soap_flag__systemAirconSt_Power_Start > 0 || soap_flag__systemAirconSt_Power_Stop > 0 || soap_flag__systemAirconSt_WindDirection_UpDown > 0 || soap_flag__systemAirconSt_WindDirection_LeftRight > 0 || soap_flag__systemAirconSt_WindDirection_UpDownLeftRight > 0 || soap_flag__systemAirconSt_WindDirection_Stop > 0 || soap_flag__systemAirconSt_WindPower_Auto > 0 || soap_flag__systemAirconSt_WindPower_Breeze > 0 || soap_flag__systemAirconSt_WindPower_Middle > 0 || soap_flag__systemAirconSt_WindPower_Super > 0 || soap_flag__systemAirconSt_WindPower_Natural > 0 || soap_flag__systemAirconSt_Drive_Driving > 0 || soap_flag__systemAirconSt_Drive_EventRelease > 0 || soap_flag__systemAirconSt_Drive_Auto > 0 || soap_flag__systemAirconSt_Drive_JaeSang > 0 || soap_flag__systemAirconSt_Drive_Ventilation > 0 || soap_flag__systemAirconSt_Drive_Humidity > 0 || soap_flag__systemAirconSt_Drive_Cooling > 0 || soap_flag__systemAirconSt_Drive_Heating > 0 || soap_flag__systemAirconSt_Tracking_Success > 0 || soap_flag__systemAirconSt_Tracking_Fail > 0 || soap_flag__systemAirconSt_Tracking_Searching > 0 || soap_flag__systemAirconSt_Tracking_End > 0 || soap_flag__systemAirconSt_Installation_Not_Exist > 0 || soap_flag__systemAirconSt_InnerRoom_Error_Normal > 0 || soap_flag__systemAirconSt_InnerRoom_Error_InnerTemperature > 0 || soap_flag__systemAirconSt_InnerRoom_Error_EVA_IN > 0 || soap_flag__systemAirconSt_InnerRoom_Error_FAN > 0 || soap_flag__systemAirconSt_InnerRoom_Error_Communication > 0 || soap_flag__systemAirconSt_InnerRoom_Error_Floating_Switch > 0 || soap_flag__systemAirconSt_InnerRoom_Error_Open_Two > 0 || soap_flag__systemAirconSt_InnerRoom_Error_EVA_OUT > 0 || soap_flag__systemAirconSt_OutRoom_Error_Normal > 0 || soap_flag__systemAirconSt_OutRoom_Error_Temp > 0 || soap_flag__systemAirconSt_OutRoom_Error_Sensor > 0 || soap_flag__systemAirconSt_OutRoom_Error_Cond > 0 || soap_flag__systemAirconSt_OutRoom_Error_Commnuication > 0 || soap_flag__systemAirconSt_OutRoom_Error_Error > 0 || soap_flag__systemAirconSt_OutRoom_Error_lowPower > 0 || soap_flag__systemAirconSt_OutRoom_Error_MagicalPower > 0 || soap_flag__systemAirconSt_OutRoom_Error_InitCommunication > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xsd_systemAirconProperty *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_xsd_systemAirconProperty, 0, sizeof(struct xsd_systemAirconProperty), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct xsd_systemAirconProperty * SOAP_FMAC6 soap_new_xsd_systemAirconProperty(struct soap *soap, int n)
{	return soap_instantiate_xsd_systemAirconProperty(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd_systemAirconProperty(struct soap *soap, struct xsd_systemAirconProperty *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct xsd_systemAirconProperty * SOAP_FMAC4 soap_instantiate_xsd_systemAirconProperty(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd_systemAirconProperty(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_xsd_systemAirconProperty, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct xsd_systemAirconProperty;
		if (size)
			*size = sizeof(struct xsd_systemAirconProperty);
	}
	else
	{	cp->ptr = (void*)new struct xsd_systemAirconProperty[n];
		if (size)
			*size = n * sizeof(struct xsd_systemAirconProperty);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct xsd_systemAirconProperty*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd_systemAirconProperty(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct xsd_systemAirconProperty %p -> %p\n", q, p));
	*(struct xsd_systemAirconProperty*)p = *(struct xsd_systemAirconProperty*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__BundleLightEvent(struct soap *soap, const struct ns__BundleLightEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.soap_serialize(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__BundleLightEvent(struct soap *soap, struct ns__BundleLightEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.ns__bundleLight::soap_default(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__BundleLightEvent(struct soap *soap, const struct ns__BundleLightEvent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__BundleLightEvent);
	if (soap_out_ns__BundleLightEvent(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__BundleLightEvent(struct soap *soap, const char *tag, int id, const struct ns__BundleLightEvent *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__BundleLightEvent), type);
	a->in.soap_out(soap, "in", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__BundleLightEvent * SOAP_FMAC4 soap_get_ns__BundleLightEvent(struct soap *soap, struct ns__BundleLightEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__BundleLightEvent(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__BundleLightEvent * SOAP_FMAC4 soap_in_ns__BundleLightEvent(struct soap *soap, const char *tag, struct ns__BundleLightEvent *a, const char *type)
{
	short soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__BundleLightEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__BundleLightEvent, sizeof(struct ns__BundleLightEvent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__BundleLightEvent(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && soap->error == SOAP_TAG_MISMATCH)
				if (a->in.soap_in(soap, "in", "ns:bundleLight"))
				{	soap_flag_in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__BundleLightEvent *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__BundleLightEvent, 0, sizeof(struct ns__BundleLightEvent), 0, soap_copy_ns__BundleLightEvent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__BundleLightEvent * SOAP_FMAC6 soap_new_ns__BundleLightEvent(struct soap *soap, int n)
{	return soap_instantiate_ns__BundleLightEvent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__BundleLightEvent(struct soap *soap, struct ns__BundleLightEvent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__BundleLightEvent * SOAP_FMAC4 soap_instantiate_ns__BundleLightEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__BundleLightEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__BundleLightEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__BundleLightEvent;
		if (size)
			*size = sizeof(struct ns__BundleLightEvent);
	}
	else
	{	cp->ptr = (void*)new struct ns__BundleLightEvent[n];
		if (size)
			*size = n * sizeof(struct ns__BundleLightEvent);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__BundleLightEvent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__BundleLightEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__BundleLightEvent %p -> %p\n", q, p));
	*(struct ns__BundleLightEvent*)p = *(struct ns__BundleLightEvent*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__BundleLightEventResponse(struct soap *soap, const struct ns__BundleLightEventResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__BundleLightEventResponse(struct soap *soap, struct ns__BundleLightEventResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->out = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__BundleLightEventResponse(struct soap *soap, const struct ns__BundleLightEventResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__BundleLightEventResponse);
	if (soap_out_ns__BundleLightEventResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__BundleLightEventResponse(struct soap *soap, const char *tag, int id, const struct ns__BundleLightEventResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__BundleLightEventResponse), type);
	if (a->out)
		soap_element_result(soap, "out");
	soap_out_PointerToint(soap, "out", -1, &a->out, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__BundleLightEventResponse * SOAP_FMAC4 soap_get_ns__BundleLightEventResponse(struct soap *soap, struct ns__BundleLightEventResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__BundleLightEventResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__BundleLightEventResponse * SOAP_FMAC4 soap_in_ns__BundleLightEventResponse(struct soap *soap, const char *tag, struct ns__BundleLightEventResponse *a, const char *type)
{
	short soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__BundleLightEventResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__BundleLightEventResponse, sizeof(struct ns__BundleLightEventResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__BundleLightEventResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "out", &a->out, "xsd:int"))
				{	soap_flag_out--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__BundleLightEventResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__BundleLightEventResponse, 0, sizeof(struct ns__BundleLightEventResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__BundleLightEventResponse * SOAP_FMAC6 soap_new_ns__BundleLightEventResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__BundleLightEventResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__BundleLightEventResponse(struct soap *soap, struct ns__BundleLightEventResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__BundleLightEventResponse * SOAP_FMAC4 soap_instantiate_ns__BundleLightEventResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__BundleLightEventResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__BundleLightEventResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__BundleLightEventResponse;
		if (size)
			*size = sizeof(struct ns__BundleLightEventResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__BundleLightEventResponse[n];
		if (size)
			*size = n * sizeof(struct ns__BundleLightEventResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__BundleLightEventResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__BundleLightEventResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__BundleLightEventResponse %p -> %p\n", q, p));
	*(struct ns__BundleLightEventResponse*)p = *(struct ns__BundleLightEventResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setBundleLight(struct soap *soap, const struct ns__setBundleLight *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.soap_serialize(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setBundleLight(struct soap *soap, struct ns__setBundleLight *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.ns__bundleLight::soap_default(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setBundleLight(struct soap *soap, const struct ns__setBundleLight *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__setBundleLight);
	if (soap_out_ns__setBundleLight(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setBundleLight(struct soap *soap, const char *tag, int id, const struct ns__setBundleLight *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__setBundleLight), type);
	a->in.soap_out(soap, "in", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setBundleLight * SOAP_FMAC4 soap_get_ns__setBundleLight(struct soap *soap, struct ns__setBundleLight *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setBundleLight(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setBundleLight * SOAP_FMAC4 soap_in_ns__setBundleLight(struct soap *soap, const char *tag, struct ns__setBundleLight *a, const char *type)
{
	short soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setBundleLight *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__setBundleLight, sizeof(struct ns__setBundleLight), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__setBundleLight(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && soap->error == SOAP_TAG_MISMATCH)
				if (a->in.soap_in(soap, "in", "ns:bundleLight"))
				{	soap_flag_in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setBundleLight *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__setBundleLight, 0, sizeof(struct ns__setBundleLight), 0, soap_copy_ns__setBundleLight);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setBundleLight * SOAP_FMAC6 soap_new_ns__setBundleLight(struct soap *soap, int n)
{	return soap_instantiate_ns__setBundleLight(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setBundleLight(struct soap *soap, struct ns__setBundleLight *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setBundleLight * SOAP_FMAC4 soap_instantiate_ns__setBundleLight(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setBundleLight(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__setBundleLight, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setBundleLight;
		if (size)
			*size = sizeof(struct ns__setBundleLight);
	}
	else
	{	cp->ptr = (void*)new struct ns__setBundleLight[n];
		if (size)
			*size = n * sizeof(struct ns__setBundleLight);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setBundleLight*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setBundleLight(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setBundleLight %p -> %p\n", q, p));
	*(struct ns__setBundleLight*)p = *(struct ns__setBundleLight*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getBundleLight(struct soap *soap, const struct ns__getBundleLight *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.soap_serialize(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getBundleLight(struct soap *soap, struct ns__getBundleLight *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.ns__bundleLight::soap_default(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getBundleLight(struct soap *soap, const struct ns__getBundleLight *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getBundleLight);
	if (soap_out_ns__getBundleLight(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getBundleLight(struct soap *soap, const char *tag, int id, const struct ns__getBundleLight *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getBundleLight), type);
	a->in.soap_out(soap, "in", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getBundleLight * SOAP_FMAC4 soap_get_ns__getBundleLight(struct soap *soap, struct ns__getBundleLight *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getBundleLight(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getBundleLight * SOAP_FMAC4 soap_in_ns__getBundleLight(struct soap *soap, const char *tag, struct ns__getBundleLight *a, const char *type)
{
	short soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getBundleLight *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getBundleLight, sizeof(struct ns__getBundleLight), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__getBundleLight(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && soap->error == SOAP_TAG_MISMATCH)
				if (a->in.soap_in(soap, "in", "ns:bundleLight"))
				{	soap_flag_in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getBundleLight *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getBundleLight, 0, sizeof(struct ns__getBundleLight), 0, soap_copy_ns__getBundleLight);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getBundleLight * SOAP_FMAC6 soap_new_ns__getBundleLight(struct soap *soap, int n)
{	return soap_instantiate_ns__getBundleLight(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getBundleLight(struct soap *soap, struct ns__getBundleLight *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getBundleLight * SOAP_FMAC4 soap_instantiate_ns__getBundleLight(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getBundleLight(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getBundleLight, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getBundleLight;
		if (size)
			*size = sizeof(struct ns__getBundleLight);
	}
	else
	{	cp->ptr = (void*)new struct ns__getBundleLight[n];
		if (size)
			*size = n * sizeof(struct ns__getBundleLight);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getBundleLight*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getBundleLight(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getBundleLight %p -> %p\n", q, p));
	*(struct ns__getBundleLight*)p = *(struct ns__getBundleLight*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getBundleLightItem(struct soap *soap, const struct ns__getBundleLightItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->order, SOAP_TYPE_cmxDeviceService_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getBundleLightItem(struct soap *soap, struct ns__getBundleLightItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->order);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getBundleLightItem(struct soap *soap, const struct ns__getBundleLightItem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getBundleLightItem);
	if (soap_out_ns__getBundleLightItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getBundleLightItem(struct soap *soap, const char *tag, int id, const struct ns__getBundleLightItem *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getBundleLightItem), type);
	soap_out_int(soap, "order", -1, &a->order, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getBundleLightItem * SOAP_FMAC4 soap_get_ns__getBundleLightItem(struct soap *soap, struct ns__getBundleLightItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getBundleLightItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getBundleLightItem * SOAP_FMAC4 soap_in_ns__getBundleLightItem(struct soap *soap, const char *tag, struct ns__getBundleLightItem *a, const char *type)
{
	short soap_flag_order = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getBundleLightItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getBundleLightItem, sizeof(struct ns__getBundleLightItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getBundleLightItem(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_order && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "order", &a->order, "xsd:int"))
				{	soap_flag_order--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_order > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getBundleLightItem *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getBundleLightItem, 0, sizeof(struct ns__getBundleLightItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getBundleLightItem * SOAP_FMAC6 soap_new_ns__getBundleLightItem(struct soap *soap, int n)
{	return soap_instantiate_ns__getBundleLightItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getBundleLightItem(struct soap *soap, struct ns__getBundleLightItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getBundleLightItem * SOAP_FMAC4 soap_instantiate_ns__getBundleLightItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getBundleLightItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getBundleLightItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getBundleLightItem;
		if (size)
			*size = sizeof(struct ns__getBundleLightItem);
	}
	else
	{	cp->ptr = (void*)new struct ns__getBundleLightItem[n];
		if (size)
			*size = n * sizeof(struct ns__getBundleLightItem);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getBundleLightItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getBundleLightItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getBundleLightItem %p -> %p\n", q, p));
	*(struct ns__getBundleLightItem*)p = *(struct ns__getBundleLightItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getBundleLightPropertyItem(struct soap *soap, const struct ns__getBundleLightPropertyItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->order, SOAP_TYPE_cmxDeviceService_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getBundleLightPropertyItem(struct soap *soap, struct ns__getBundleLightPropertyItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->order);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getBundleLightPropertyItem(struct soap *soap, const struct ns__getBundleLightPropertyItem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getBundleLightPropertyItem);
	if (soap_out_ns__getBundleLightPropertyItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getBundleLightPropertyItem(struct soap *soap, const char *tag, int id, const struct ns__getBundleLightPropertyItem *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getBundleLightPropertyItem), type);
	soap_out_int(soap, "order", -1, &a->order, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getBundleLightPropertyItem * SOAP_FMAC4 soap_get_ns__getBundleLightPropertyItem(struct soap *soap, struct ns__getBundleLightPropertyItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getBundleLightPropertyItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getBundleLightPropertyItem * SOAP_FMAC4 soap_in_ns__getBundleLightPropertyItem(struct soap *soap, const char *tag, struct ns__getBundleLightPropertyItem *a, const char *type)
{
	short soap_flag_order = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getBundleLightPropertyItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getBundleLightPropertyItem, sizeof(struct ns__getBundleLightPropertyItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getBundleLightPropertyItem(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_order && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "order", &a->order, "xsd:int"))
				{	soap_flag_order--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_order > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getBundleLightPropertyItem *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getBundleLightPropertyItem, 0, sizeof(struct ns__getBundleLightPropertyItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getBundleLightPropertyItem * SOAP_FMAC6 soap_new_ns__getBundleLightPropertyItem(struct soap *soap, int n)
{	return soap_instantiate_ns__getBundleLightPropertyItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getBundleLightPropertyItem(struct soap *soap, struct ns__getBundleLightPropertyItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getBundleLightPropertyItem * SOAP_FMAC4 soap_instantiate_ns__getBundleLightPropertyItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getBundleLightPropertyItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getBundleLightPropertyItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getBundleLightPropertyItem;
		if (size)
			*size = sizeof(struct ns__getBundleLightPropertyItem);
	}
	else
	{	cp->ptr = (void*)new struct ns__getBundleLightPropertyItem[n];
		if (size)
			*size = n * sizeof(struct ns__getBundleLightPropertyItem);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getBundleLightPropertyItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getBundleLightPropertyItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getBundleLightPropertyItem %p -> %p\n", q, p));
	*(struct ns__getBundleLightPropertyItem*)p = *(struct ns__getBundleLightPropertyItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getBundleLightCount(struct soap *soap, const struct ns__getBundleLightCount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getBundleLightCount(struct soap *soap, struct ns__getBundleLightCount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getBundleLightCount(struct soap *soap, const struct ns__getBundleLightCount *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getBundleLightCount);
	if (soap_out_ns__getBundleLightCount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getBundleLightCount(struct soap *soap, const char *tag, int id, const struct ns__getBundleLightCount *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getBundleLightCount), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getBundleLightCount * SOAP_FMAC4 soap_get_ns__getBundleLightCount(struct soap *soap, struct ns__getBundleLightCount *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getBundleLightCount(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getBundleLightCount * SOAP_FMAC4 soap_in_ns__getBundleLightCount(struct soap *soap, const char *tag, struct ns__getBundleLightCount *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getBundleLightCount *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getBundleLightCount, sizeof(struct ns__getBundleLightCount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getBundleLightCount(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getBundleLightCount *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getBundleLightCount, 0, sizeof(struct ns__getBundleLightCount), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getBundleLightCount * SOAP_FMAC6 soap_new_ns__getBundleLightCount(struct soap *soap, int n)
{	return soap_instantiate_ns__getBundleLightCount(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getBundleLightCount(struct soap *soap, struct ns__getBundleLightCount *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getBundleLightCount * SOAP_FMAC4 soap_instantiate_ns__getBundleLightCount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getBundleLightCount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getBundleLightCount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getBundleLightCount;
		if (size)
			*size = sizeof(struct ns__getBundleLightCount);
	}
	else
	{	cp->ptr = (void*)new struct ns__getBundleLightCount[n];
		if (size)
			*size = n * sizeof(struct ns__getBundleLightCount);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getBundleLightCount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getBundleLightCount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getBundleLightCount %p -> %p\n", q, p));
	*(struct ns__getBundleLightCount*)p = *(struct ns__getBundleLightCount*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getBundleLightCountResponse(struct soap *soap, const struct ns__getBundleLightCountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getBundleLightCountResponse(struct soap *soap, struct ns__getBundleLightCountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->out = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getBundleLightCountResponse(struct soap *soap, const struct ns__getBundleLightCountResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getBundleLightCountResponse);
	if (soap_out_ns__getBundleLightCountResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getBundleLightCountResponse(struct soap *soap, const char *tag, int id, const struct ns__getBundleLightCountResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getBundleLightCountResponse), type);
	if (a->out)
		soap_element_result(soap, "out");
	soap_out_PointerToint(soap, "out", -1, &a->out, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getBundleLightCountResponse * SOAP_FMAC4 soap_get_ns__getBundleLightCountResponse(struct soap *soap, struct ns__getBundleLightCountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getBundleLightCountResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getBundleLightCountResponse * SOAP_FMAC4 soap_in_ns__getBundleLightCountResponse(struct soap *soap, const char *tag, struct ns__getBundleLightCountResponse *a, const char *type)
{
	short soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getBundleLightCountResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getBundleLightCountResponse, sizeof(struct ns__getBundleLightCountResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getBundleLightCountResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "out", &a->out, "xsd:int"))
				{	soap_flag_out--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getBundleLightCountResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getBundleLightCountResponse, 0, sizeof(struct ns__getBundleLightCountResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getBundleLightCountResponse * SOAP_FMAC6 soap_new_ns__getBundleLightCountResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getBundleLightCountResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getBundleLightCountResponse(struct soap *soap, struct ns__getBundleLightCountResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getBundleLightCountResponse * SOAP_FMAC4 soap_instantiate_ns__getBundleLightCountResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getBundleLightCountResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getBundleLightCountResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getBundleLightCountResponse;
		if (size)
			*size = sizeof(struct ns__getBundleLightCountResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__getBundleLightCountResponse[n];
		if (size)
			*size = n * sizeof(struct ns__getBundleLightCountResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getBundleLightCountResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getBundleLightCountResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getBundleLightCountResponse %p -> %p\n", q, p));
	*(struct ns__getBundleLightCountResponse*)p = *(struct ns__getBundleLightCountResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd_bundleLightProperty(struct soap *soap, const struct xsd_bundleLightProperty *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd_bundleLightProperty(struct soap *soap, struct xsd_bundleLightProperty *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->_bundleLightPower_Off);
	soap_default_unsignedInt(soap, &a->_bundleLightPower_On);
	soap_default_unsignedInt(soap, &a->_bundleLightPower_AllOff);
	soap_default_unsignedInt(soap, &a->_bundleLightPower_AllOn);
	soap_default_unsignedInt(soap, &a->_readyEnergyPower_Off);
	soap_default_unsignedInt(soap, &a->_readyEnergyPower_On);
	soap_default_unsignedInt(soap, &a->_readyEnergyPower_AllOff);
	soap_default_unsignedInt(soap, &a->_readyEnergyPower_AllOn);
	soap_default_unsignedInt(soap, &a->_bundleLightExit_Notify);
	soap_default_unsignedInt(soap, &a->_bundleLightExit_Entry_Accept);
	soap_default_unsignedInt(soap, &a->_bundleLightExit_Entry_Deny);
	soap_default_unsignedInt(soap, &a->_bundleLightExit_Setting);
	soap_default_unsignedInt(soap, &a->_bundleLightExit_Release);
	soap_default_unsignedInt(soap, &a->_bundleLightElevator_Up);
	soap_default_unsignedInt(soap, &a->_bundleLightElevator_Down);
	soap_default_unsignedInt(soap, &a->_gasValve_Entry_Accept);
	soap_default_unsignedInt(soap, &a->_gasValve_Entry_Deny);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd_bundleLightProperty(struct soap *soap, const struct xsd_bundleLightProperty *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_xsd_bundleLightProperty);
	if (soap_out_xsd_bundleLightProperty(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd_bundleLightProperty(struct soap *soap, const char *tag, int id, const struct xsd_bundleLightProperty *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_xsd_bundleLightProperty), type);
	soap_out_unsignedInt(soap, "bundleLightPower-Off", -1, &a->_bundleLightPower_Off, "");
	soap_out_unsignedInt(soap, "bundleLightPower-On", -1, &a->_bundleLightPower_On, "");
	soap_out_unsignedInt(soap, "bundleLightPower-AllOff", -1, &a->_bundleLightPower_AllOff, "");
	soap_out_unsignedInt(soap, "bundleLightPower-AllOn", -1, &a->_bundleLightPower_AllOn, "");
	soap_out_unsignedInt(soap, "readyEnergyPower-Off", -1, &a->_readyEnergyPower_Off, "");
	soap_out_unsignedInt(soap, "readyEnergyPower-On", -1, &a->_readyEnergyPower_On, "");
	soap_out_unsignedInt(soap, "readyEnergyPower-AllOff", -1, &a->_readyEnergyPower_AllOff, "");
	soap_out_unsignedInt(soap, "readyEnergyPower-AllOn", -1, &a->_readyEnergyPower_AllOn, "");
	soap_out_unsignedInt(soap, "bundleLightExit-Notify", -1, &a->_bundleLightExit_Notify, "");
	soap_out_unsignedInt(soap, "bundleLightExit-Entry-Accept", -1, &a->_bundleLightExit_Entry_Accept, "");
	soap_out_unsignedInt(soap, "bundleLightExit-Entry-Deny", -1, &a->_bundleLightExit_Entry_Deny, "");
	soap_out_unsignedInt(soap, "bundleLightExit-Setting", -1, &a->_bundleLightExit_Setting, "");
	soap_out_unsignedInt(soap, "bundleLightExit-Release", -1, &a->_bundleLightExit_Release, "");
	soap_out_unsignedInt(soap, "bundleLightElevator-Up", -1, &a->_bundleLightElevator_Up, "");
	soap_out_unsignedInt(soap, "bundleLightElevator-Down", -1, &a->_bundleLightElevator_Down, "");
	soap_out_unsignedInt(soap, "gasValve-Entry-Accept", -1, &a->_gasValve_Entry_Accept, "");
	soap_out_unsignedInt(soap, "gasValve-Entry-Deny", -1, &a->_gasValve_Entry_Deny, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct xsd_bundleLightProperty * SOAP_FMAC4 soap_get_xsd_bundleLightProperty(struct soap *soap, struct xsd_bundleLightProperty *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd_bundleLightProperty(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct xsd_bundleLightProperty * SOAP_FMAC4 soap_in_xsd_bundleLightProperty(struct soap *soap, const char *tag, struct xsd_bundleLightProperty *a, const char *type)
{
	short soap_flag__bundleLightPower_Off = 1, soap_flag__bundleLightPower_On = 1, soap_flag__bundleLightPower_AllOff = 1, soap_flag__bundleLightPower_AllOn = 1, soap_flag__readyEnergyPower_Off = 1, soap_flag__readyEnergyPower_On = 1, soap_flag__readyEnergyPower_AllOff = 1, soap_flag__readyEnergyPower_AllOn = 1, soap_flag__bundleLightExit_Notify = 1, soap_flag__bundleLightExit_Entry_Accept = 1, soap_flag__bundleLightExit_Entry_Deny = 1, soap_flag__bundleLightExit_Setting = 1, soap_flag__bundleLightExit_Release = 1, soap_flag__bundleLightElevator_Up = 1, soap_flag__bundleLightElevator_Down = 1, soap_flag__gasValve_Entry_Accept = 1, soap_flag__gasValve_Entry_Deny = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct xsd_bundleLightProperty *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_xsd_bundleLightProperty, sizeof(struct xsd_bundleLightProperty), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xsd_bundleLightProperty(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__bundleLightPower_Off && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_bundleLightPower_Off, "xsd:unsignedInt"))
				{	soap_flag__bundleLightPower_Off--;
					continue;
				}
			if (soap_flag__bundleLightPower_On && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_bundleLightPower_On, "xsd:unsignedInt"))
				{	soap_flag__bundleLightPower_On--;
					continue;
				}
			if (soap_flag__bundleLightPower_AllOff && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_bundleLightPower_AllOff, "xsd:unsignedInt"))
				{	soap_flag__bundleLightPower_AllOff--;
					continue;
				}
			if (soap_flag__bundleLightPower_AllOn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_bundleLightPower_AllOn, "xsd:unsignedInt"))
				{	soap_flag__bundleLightPower_AllOn--;
					continue;
				}
			if (soap_flag__readyEnergyPower_Off && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_readyEnergyPower_Off, "xsd:unsignedInt"))
				{	soap_flag__readyEnergyPower_Off--;
					continue;
				}
			if (soap_flag__readyEnergyPower_On && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_readyEnergyPower_On, "xsd:unsignedInt"))
				{	soap_flag__readyEnergyPower_On--;
					continue;
				}
			if (soap_flag__readyEnergyPower_AllOff && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_readyEnergyPower_AllOff, "xsd:unsignedInt"))
				{	soap_flag__readyEnergyPower_AllOff--;
					continue;
				}
			if (soap_flag__readyEnergyPower_AllOn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_readyEnergyPower_AllOn, "xsd:unsignedInt"))
				{	soap_flag__readyEnergyPower_AllOn--;
					continue;
				}
			if (soap_flag__bundleLightExit_Notify && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_bundleLightExit_Notify, "xsd:unsignedInt"))
				{	soap_flag__bundleLightExit_Notify--;
					continue;
				}
			if (soap_flag__bundleLightExit_Entry_Accept && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_bundleLightExit_Entry_Accept, "xsd:unsignedInt"))
				{	soap_flag__bundleLightExit_Entry_Accept--;
					continue;
				}
			if (soap_flag__bundleLightExit_Entry_Deny && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_bundleLightExit_Entry_Deny, "xsd:unsignedInt"))
				{	soap_flag__bundleLightExit_Entry_Deny--;
					continue;
				}
			if (soap_flag__bundleLightExit_Setting && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_bundleLightExit_Setting, "xsd:unsignedInt"))
				{	soap_flag__bundleLightExit_Setting--;
					continue;
				}
			if (soap_flag__bundleLightExit_Release && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_bundleLightExit_Release, "xsd:unsignedInt"))
				{	soap_flag__bundleLightExit_Release--;
					continue;
				}
			if (soap_flag__bundleLightElevator_Up && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_bundleLightElevator_Up, "xsd:unsignedInt"))
				{	soap_flag__bundleLightElevator_Up--;
					continue;
				}
			if (soap_flag__bundleLightElevator_Down && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_bundleLightElevator_Down, "xsd:unsignedInt"))
				{	soap_flag__bundleLightElevator_Down--;
					continue;
				}
			if (soap_flag__gasValve_Entry_Accept && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_gasValve_Entry_Accept, "xsd:unsignedInt"))
				{	soap_flag__gasValve_Entry_Accept--;
					continue;
				}
			if (soap_flag__gasValve_Entry_Deny && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_gasValve_Entry_Deny, "xsd:unsignedInt"))
				{	soap_flag__gasValve_Entry_Deny--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__bundleLightPower_Off > 0 || soap_flag__bundleLightPower_On > 0 || soap_flag__bundleLightPower_AllOff > 0 || soap_flag__bundleLightPower_AllOn > 0 || soap_flag__readyEnergyPower_Off > 0 || soap_flag__readyEnergyPower_On > 0 || soap_flag__readyEnergyPower_AllOff > 0 || soap_flag__readyEnergyPower_AllOn > 0 || soap_flag__bundleLightExit_Notify > 0 || soap_flag__bundleLightExit_Entry_Accept > 0 || soap_flag__bundleLightExit_Entry_Deny > 0 || soap_flag__bundleLightExit_Setting > 0 || soap_flag__bundleLightExit_Release > 0 || soap_flag__bundleLightElevator_Up > 0 || soap_flag__bundleLightElevator_Down > 0 || soap_flag__gasValve_Entry_Accept > 0 || soap_flag__gasValve_Entry_Deny > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xsd_bundleLightProperty *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_xsd_bundleLightProperty, 0, sizeof(struct xsd_bundleLightProperty), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct xsd_bundleLightProperty * SOAP_FMAC6 soap_new_xsd_bundleLightProperty(struct soap *soap, int n)
{	return soap_instantiate_xsd_bundleLightProperty(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd_bundleLightProperty(struct soap *soap, struct xsd_bundleLightProperty *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct xsd_bundleLightProperty * SOAP_FMAC4 soap_instantiate_xsd_bundleLightProperty(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd_bundleLightProperty(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_xsd_bundleLightProperty, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct xsd_bundleLightProperty;
		if (size)
			*size = sizeof(struct xsd_bundleLightProperty);
	}
	else
	{	cp->ptr = (void*)new struct xsd_bundleLightProperty[n];
		if (size)
			*size = n * sizeof(struct xsd_bundleLightProperty);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct xsd_bundleLightProperty*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd_bundleLightProperty(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct xsd_bundleLightProperty %p -> %p\n", q, p));
	*(struct xsd_bundleLightProperty*)p = *(struct xsd_bundleLightProperty*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__curtainEvent(struct soap *soap, const struct ns__curtainEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.soap_serialize(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__curtainEvent(struct soap *soap, struct ns__curtainEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.ns__curtain::soap_default(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__curtainEvent(struct soap *soap, const struct ns__curtainEvent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__curtainEvent);
	if (soap_out_ns__curtainEvent(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__curtainEvent(struct soap *soap, const char *tag, int id, const struct ns__curtainEvent *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__curtainEvent), type);
	a->in.soap_out(soap, "in", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__curtainEvent * SOAP_FMAC4 soap_get_ns__curtainEvent(struct soap *soap, struct ns__curtainEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__curtainEvent(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__curtainEvent * SOAP_FMAC4 soap_in_ns__curtainEvent(struct soap *soap, const char *tag, struct ns__curtainEvent *a, const char *type)
{
	short soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__curtainEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__curtainEvent, sizeof(struct ns__curtainEvent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__curtainEvent(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && soap->error == SOAP_TAG_MISMATCH)
				if (a->in.soap_in(soap, "in", "ns:curtain"))
				{	soap_flag_in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__curtainEvent *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__curtainEvent, 0, sizeof(struct ns__curtainEvent), 0, soap_copy_ns__curtainEvent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__curtainEvent * SOAP_FMAC6 soap_new_ns__curtainEvent(struct soap *soap, int n)
{	return soap_instantiate_ns__curtainEvent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__curtainEvent(struct soap *soap, struct ns__curtainEvent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__curtainEvent * SOAP_FMAC4 soap_instantiate_ns__curtainEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__curtainEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__curtainEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__curtainEvent;
		if (size)
			*size = sizeof(struct ns__curtainEvent);
	}
	else
	{	cp->ptr = (void*)new struct ns__curtainEvent[n];
		if (size)
			*size = n * sizeof(struct ns__curtainEvent);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__curtainEvent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__curtainEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__curtainEvent %p -> %p\n", q, p));
	*(struct ns__curtainEvent*)p = *(struct ns__curtainEvent*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__curtainEventResponse(struct soap *soap, const struct ns__curtainEventResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__curtainEventResponse(struct soap *soap, struct ns__curtainEventResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->out = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__curtainEventResponse(struct soap *soap, const struct ns__curtainEventResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__curtainEventResponse);
	if (soap_out_ns__curtainEventResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__curtainEventResponse(struct soap *soap, const char *tag, int id, const struct ns__curtainEventResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__curtainEventResponse), type);
	if (a->out)
		soap_element_result(soap, "out");
	soap_out_PointerToint(soap, "out", -1, &a->out, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__curtainEventResponse * SOAP_FMAC4 soap_get_ns__curtainEventResponse(struct soap *soap, struct ns__curtainEventResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__curtainEventResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__curtainEventResponse * SOAP_FMAC4 soap_in_ns__curtainEventResponse(struct soap *soap, const char *tag, struct ns__curtainEventResponse *a, const char *type)
{
	short soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__curtainEventResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__curtainEventResponse, sizeof(struct ns__curtainEventResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__curtainEventResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "out", &a->out, "xsd:int"))
				{	soap_flag_out--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__curtainEventResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__curtainEventResponse, 0, sizeof(struct ns__curtainEventResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__curtainEventResponse * SOAP_FMAC6 soap_new_ns__curtainEventResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__curtainEventResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__curtainEventResponse(struct soap *soap, struct ns__curtainEventResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__curtainEventResponse * SOAP_FMAC4 soap_instantiate_ns__curtainEventResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__curtainEventResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__curtainEventResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__curtainEventResponse;
		if (size)
			*size = sizeof(struct ns__curtainEventResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__curtainEventResponse[n];
		if (size)
			*size = n * sizeof(struct ns__curtainEventResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__curtainEventResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__curtainEventResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__curtainEventResponse %p -> %p\n", q, p));
	*(struct ns__curtainEventResponse*)p = *(struct ns__curtainEventResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setCurtain(struct soap *soap, const struct ns__setCurtain *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.soap_serialize(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setCurtain(struct soap *soap, struct ns__setCurtain *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.ns__curtain::soap_default(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setCurtain(struct soap *soap, const struct ns__setCurtain *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__setCurtain);
	if (soap_out_ns__setCurtain(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setCurtain(struct soap *soap, const char *tag, int id, const struct ns__setCurtain *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__setCurtain), type);
	a->in.soap_out(soap, "in", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setCurtain * SOAP_FMAC4 soap_get_ns__setCurtain(struct soap *soap, struct ns__setCurtain *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setCurtain(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setCurtain * SOAP_FMAC4 soap_in_ns__setCurtain(struct soap *soap, const char *tag, struct ns__setCurtain *a, const char *type)
{
	short soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setCurtain *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__setCurtain, sizeof(struct ns__setCurtain), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__setCurtain(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && soap->error == SOAP_TAG_MISMATCH)
				if (a->in.soap_in(soap, "in", "ns:curtain"))
				{	soap_flag_in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setCurtain *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__setCurtain, 0, sizeof(struct ns__setCurtain), 0, soap_copy_ns__setCurtain);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setCurtain * SOAP_FMAC6 soap_new_ns__setCurtain(struct soap *soap, int n)
{	return soap_instantiate_ns__setCurtain(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setCurtain(struct soap *soap, struct ns__setCurtain *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setCurtain * SOAP_FMAC4 soap_instantiate_ns__setCurtain(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setCurtain(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__setCurtain, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setCurtain;
		if (size)
			*size = sizeof(struct ns__setCurtain);
	}
	else
	{	cp->ptr = (void*)new struct ns__setCurtain[n];
		if (size)
			*size = n * sizeof(struct ns__setCurtain);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setCurtain*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setCurtain(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setCurtain %p -> %p\n", q, p));
	*(struct ns__setCurtain*)p = *(struct ns__setCurtain*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getCurtain(struct soap *soap, const struct ns__getCurtain *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.soap_serialize(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getCurtain(struct soap *soap, struct ns__getCurtain *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.ns__curtain::soap_default(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getCurtain(struct soap *soap, const struct ns__getCurtain *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getCurtain);
	if (soap_out_ns__getCurtain(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getCurtain(struct soap *soap, const char *tag, int id, const struct ns__getCurtain *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getCurtain), type);
	a->in.soap_out(soap, "in", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getCurtain * SOAP_FMAC4 soap_get_ns__getCurtain(struct soap *soap, struct ns__getCurtain *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getCurtain(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getCurtain * SOAP_FMAC4 soap_in_ns__getCurtain(struct soap *soap, const char *tag, struct ns__getCurtain *a, const char *type)
{
	short soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getCurtain *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getCurtain, sizeof(struct ns__getCurtain), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__getCurtain(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && soap->error == SOAP_TAG_MISMATCH)
				if (a->in.soap_in(soap, "in", "ns:curtain"))
				{	soap_flag_in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getCurtain *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getCurtain, 0, sizeof(struct ns__getCurtain), 0, soap_copy_ns__getCurtain);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getCurtain * SOAP_FMAC6 soap_new_ns__getCurtain(struct soap *soap, int n)
{	return soap_instantiate_ns__getCurtain(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getCurtain(struct soap *soap, struct ns__getCurtain *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getCurtain * SOAP_FMAC4 soap_instantiate_ns__getCurtain(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getCurtain(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getCurtain, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getCurtain;
		if (size)
			*size = sizeof(struct ns__getCurtain);
	}
	else
	{	cp->ptr = (void*)new struct ns__getCurtain[n];
		if (size)
			*size = n * sizeof(struct ns__getCurtain);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getCurtain*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getCurtain(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getCurtain %p -> %p\n", q, p));
	*(struct ns__getCurtain*)p = *(struct ns__getCurtain*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getCurtainItem(struct soap *soap, const struct ns__getCurtainItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->order, SOAP_TYPE_cmxDeviceService_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getCurtainItem(struct soap *soap, struct ns__getCurtainItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->order);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getCurtainItem(struct soap *soap, const struct ns__getCurtainItem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getCurtainItem);
	if (soap_out_ns__getCurtainItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getCurtainItem(struct soap *soap, const char *tag, int id, const struct ns__getCurtainItem *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getCurtainItem), type);
	soap_out_int(soap, "order", -1, &a->order, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getCurtainItem * SOAP_FMAC4 soap_get_ns__getCurtainItem(struct soap *soap, struct ns__getCurtainItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getCurtainItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getCurtainItem * SOAP_FMAC4 soap_in_ns__getCurtainItem(struct soap *soap, const char *tag, struct ns__getCurtainItem *a, const char *type)
{
	short soap_flag_order = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getCurtainItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getCurtainItem, sizeof(struct ns__getCurtainItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getCurtainItem(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_order && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "order", &a->order, "xsd:int"))
				{	soap_flag_order--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_order > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getCurtainItem *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getCurtainItem, 0, sizeof(struct ns__getCurtainItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getCurtainItem * SOAP_FMAC6 soap_new_ns__getCurtainItem(struct soap *soap, int n)
{	return soap_instantiate_ns__getCurtainItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getCurtainItem(struct soap *soap, struct ns__getCurtainItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getCurtainItem * SOAP_FMAC4 soap_instantiate_ns__getCurtainItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getCurtainItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getCurtainItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getCurtainItem;
		if (size)
			*size = sizeof(struct ns__getCurtainItem);
	}
	else
	{	cp->ptr = (void*)new struct ns__getCurtainItem[n];
		if (size)
			*size = n * sizeof(struct ns__getCurtainItem);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getCurtainItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getCurtainItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getCurtainItem %p -> %p\n", q, p));
	*(struct ns__getCurtainItem*)p = *(struct ns__getCurtainItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getCurtainPropertyItem(struct soap *soap, const struct ns__getCurtainPropertyItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->order, SOAP_TYPE_cmxDeviceService_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getCurtainPropertyItem(struct soap *soap, struct ns__getCurtainPropertyItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->order);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getCurtainPropertyItem(struct soap *soap, const struct ns__getCurtainPropertyItem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getCurtainPropertyItem);
	if (soap_out_ns__getCurtainPropertyItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getCurtainPropertyItem(struct soap *soap, const char *tag, int id, const struct ns__getCurtainPropertyItem *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getCurtainPropertyItem), type);
	soap_out_int(soap, "order", -1, &a->order, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getCurtainPropertyItem * SOAP_FMAC4 soap_get_ns__getCurtainPropertyItem(struct soap *soap, struct ns__getCurtainPropertyItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getCurtainPropertyItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getCurtainPropertyItem * SOAP_FMAC4 soap_in_ns__getCurtainPropertyItem(struct soap *soap, const char *tag, struct ns__getCurtainPropertyItem *a, const char *type)
{
	short soap_flag_order = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getCurtainPropertyItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getCurtainPropertyItem, sizeof(struct ns__getCurtainPropertyItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getCurtainPropertyItem(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_order && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "order", &a->order, "xsd:int"))
				{	soap_flag_order--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_order > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getCurtainPropertyItem *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getCurtainPropertyItem, 0, sizeof(struct ns__getCurtainPropertyItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getCurtainPropertyItem * SOAP_FMAC6 soap_new_ns__getCurtainPropertyItem(struct soap *soap, int n)
{	return soap_instantiate_ns__getCurtainPropertyItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getCurtainPropertyItem(struct soap *soap, struct ns__getCurtainPropertyItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getCurtainPropertyItem * SOAP_FMAC4 soap_instantiate_ns__getCurtainPropertyItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getCurtainPropertyItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getCurtainPropertyItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getCurtainPropertyItem;
		if (size)
			*size = sizeof(struct ns__getCurtainPropertyItem);
	}
	else
	{	cp->ptr = (void*)new struct ns__getCurtainPropertyItem[n];
		if (size)
			*size = n * sizeof(struct ns__getCurtainPropertyItem);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getCurtainPropertyItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getCurtainPropertyItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getCurtainPropertyItem %p -> %p\n", q, p));
	*(struct ns__getCurtainPropertyItem*)p = *(struct ns__getCurtainPropertyItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getCurtainCount(struct soap *soap, const struct ns__getCurtainCount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getCurtainCount(struct soap *soap, struct ns__getCurtainCount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getCurtainCount(struct soap *soap, const struct ns__getCurtainCount *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getCurtainCount);
	if (soap_out_ns__getCurtainCount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getCurtainCount(struct soap *soap, const char *tag, int id, const struct ns__getCurtainCount *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getCurtainCount), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getCurtainCount * SOAP_FMAC4 soap_get_ns__getCurtainCount(struct soap *soap, struct ns__getCurtainCount *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getCurtainCount(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getCurtainCount * SOAP_FMAC4 soap_in_ns__getCurtainCount(struct soap *soap, const char *tag, struct ns__getCurtainCount *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getCurtainCount *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getCurtainCount, sizeof(struct ns__getCurtainCount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getCurtainCount(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getCurtainCount *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getCurtainCount, 0, sizeof(struct ns__getCurtainCount), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getCurtainCount * SOAP_FMAC6 soap_new_ns__getCurtainCount(struct soap *soap, int n)
{	return soap_instantiate_ns__getCurtainCount(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getCurtainCount(struct soap *soap, struct ns__getCurtainCount *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getCurtainCount * SOAP_FMAC4 soap_instantiate_ns__getCurtainCount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getCurtainCount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getCurtainCount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getCurtainCount;
		if (size)
			*size = sizeof(struct ns__getCurtainCount);
	}
	else
	{	cp->ptr = (void*)new struct ns__getCurtainCount[n];
		if (size)
			*size = n * sizeof(struct ns__getCurtainCount);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getCurtainCount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getCurtainCount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getCurtainCount %p -> %p\n", q, p));
	*(struct ns__getCurtainCount*)p = *(struct ns__getCurtainCount*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getCurtainCountResponse(struct soap *soap, const struct ns__getCurtainCountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getCurtainCountResponse(struct soap *soap, struct ns__getCurtainCountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->out = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getCurtainCountResponse(struct soap *soap, const struct ns__getCurtainCountResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getCurtainCountResponse);
	if (soap_out_ns__getCurtainCountResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getCurtainCountResponse(struct soap *soap, const char *tag, int id, const struct ns__getCurtainCountResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getCurtainCountResponse), type);
	if (a->out)
		soap_element_result(soap, "out");
	soap_out_PointerToint(soap, "out", -1, &a->out, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getCurtainCountResponse * SOAP_FMAC4 soap_get_ns__getCurtainCountResponse(struct soap *soap, struct ns__getCurtainCountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getCurtainCountResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getCurtainCountResponse * SOAP_FMAC4 soap_in_ns__getCurtainCountResponse(struct soap *soap, const char *tag, struct ns__getCurtainCountResponse *a, const char *type)
{
	short soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getCurtainCountResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getCurtainCountResponse, sizeof(struct ns__getCurtainCountResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getCurtainCountResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "out", &a->out, "xsd:int"))
				{	soap_flag_out--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getCurtainCountResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getCurtainCountResponse, 0, sizeof(struct ns__getCurtainCountResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getCurtainCountResponse * SOAP_FMAC6 soap_new_ns__getCurtainCountResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getCurtainCountResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getCurtainCountResponse(struct soap *soap, struct ns__getCurtainCountResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getCurtainCountResponse * SOAP_FMAC4 soap_instantiate_ns__getCurtainCountResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getCurtainCountResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getCurtainCountResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getCurtainCountResponse;
		if (size)
			*size = sizeof(struct ns__getCurtainCountResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__getCurtainCountResponse[n];
		if (size)
			*size = n * sizeof(struct ns__getCurtainCountResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getCurtainCountResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getCurtainCountResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getCurtainCountResponse %p -> %p\n", q, p));
	*(struct ns__getCurtainCountResponse*)p = *(struct ns__getCurtainCountResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd_curtainProperty(struct soap *soap, const struct xsd_curtainProperty *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd_curtainProperty(struct soap *soap, struct xsd_curtainProperty *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->_curtainDo_Close);
	soap_default_unsignedInt(soap, &a->_curtainDo_Open);
	soap_default_unsignedInt(soap, &a->_curtainDo_Stop);
	soap_default_unsignedInt(soap, &a->_curtainAngular);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd_curtainProperty(struct soap *soap, const struct xsd_curtainProperty *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_xsd_curtainProperty);
	if (soap_out_xsd_curtainProperty(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd_curtainProperty(struct soap *soap, const char *tag, int id, const struct xsd_curtainProperty *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_xsd_curtainProperty), type);
	soap_out_unsignedInt(soap, "curtainDo-Close", -1, &a->_curtainDo_Close, "");
	soap_out_unsignedInt(soap, "curtainDo-Open", -1, &a->_curtainDo_Open, "");
	soap_out_unsignedInt(soap, "curtainDo-Stop", -1, &a->_curtainDo_Stop, "");
	soap_out_unsignedInt(soap, "curtainAngular", -1, &a->_curtainAngular, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct xsd_curtainProperty * SOAP_FMAC4 soap_get_xsd_curtainProperty(struct soap *soap, struct xsd_curtainProperty *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd_curtainProperty(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct xsd_curtainProperty * SOAP_FMAC4 soap_in_xsd_curtainProperty(struct soap *soap, const char *tag, struct xsd_curtainProperty *a, const char *type)
{
	short soap_flag__curtainDo_Close = 1, soap_flag__curtainDo_Open = 1, soap_flag__curtainDo_Stop = 1, soap_flag__curtainAngular = 9;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct xsd_curtainProperty *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_xsd_curtainProperty, sizeof(struct xsd_curtainProperty), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xsd_curtainProperty(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__curtainDo_Close && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_curtainDo_Close, "xsd:unsignedInt"))
				{	soap_flag__curtainDo_Close--;
					continue;
				}
			if (soap_flag__curtainDo_Open && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_curtainDo_Open, "xsd:unsignedInt"))
				{	soap_flag__curtainDo_Open--;
					continue;
				}
			if (soap_flag__curtainDo_Stop && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_curtainDo_Stop, "xsd:unsignedInt"))
				{	soap_flag__curtainDo_Stop--;
					continue;
				}
			if (soap_flag__curtainAngular && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_curtainAngular, "xsd:unsignedInt"))
				{	soap_flag__curtainAngular--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__curtainDo_Close > 0 || soap_flag__curtainDo_Open > 0 || soap_flag__curtainDo_Stop > 0 || soap_flag__curtainAngular > 8))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xsd_curtainProperty *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_xsd_curtainProperty, 0, sizeof(struct xsd_curtainProperty), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct xsd_curtainProperty * SOAP_FMAC6 soap_new_xsd_curtainProperty(struct soap *soap, int n)
{	return soap_instantiate_xsd_curtainProperty(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd_curtainProperty(struct soap *soap, struct xsd_curtainProperty *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct xsd_curtainProperty * SOAP_FMAC4 soap_instantiate_xsd_curtainProperty(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd_curtainProperty(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_xsd_curtainProperty, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct xsd_curtainProperty;
		if (size)
			*size = sizeof(struct xsd_curtainProperty);
	}
	else
	{	cp->ptr = (void*)new struct xsd_curtainProperty[n];
		if (size)
			*size = n * sizeof(struct xsd_curtainProperty);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct xsd_curtainProperty*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd_curtainProperty(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct xsd_curtainProperty %p -> %p\n", q, p));
	*(struct xsd_curtainProperty*)p = *(struct xsd_curtainProperty*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gasValveEvent(struct soap *soap, const struct ns__gasValveEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.soap_serialize(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gasValveEvent(struct soap *soap, struct ns__gasValveEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.ns__gasValve::soap_default(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gasValveEvent(struct soap *soap, const struct ns__gasValveEvent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__gasValveEvent);
	if (soap_out_ns__gasValveEvent(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gasValveEvent(struct soap *soap, const char *tag, int id, const struct ns__gasValveEvent *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__gasValveEvent), type);
	a->in.soap_out(soap, "in", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__gasValveEvent * SOAP_FMAC4 soap_get_ns__gasValveEvent(struct soap *soap, struct ns__gasValveEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gasValveEvent(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__gasValveEvent * SOAP_FMAC4 soap_in_ns__gasValveEvent(struct soap *soap, const char *tag, struct ns__gasValveEvent *a, const char *type)
{
	short soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__gasValveEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__gasValveEvent, sizeof(struct ns__gasValveEvent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__gasValveEvent(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && soap->error == SOAP_TAG_MISMATCH)
				if (a->in.soap_in(soap, "in", "ns:gasValve"))
				{	soap_flag_in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gasValveEvent *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__gasValveEvent, 0, sizeof(struct ns__gasValveEvent), 0, soap_copy_ns__gasValveEvent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__gasValveEvent * SOAP_FMAC6 soap_new_ns__gasValveEvent(struct soap *soap, int n)
{	return soap_instantiate_ns__gasValveEvent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__gasValveEvent(struct soap *soap, struct ns__gasValveEvent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__gasValveEvent * SOAP_FMAC4 soap_instantiate_ns__gasValveEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__gasValveEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__gasValveEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__gasValveEvent;
		if (size)
			*size = sizeof(struct ns__gasValveEvent);
	}
	else
	{	cp->ptr = (void*)new struct ns__gasValveEvent[n];
		if (size)
			*size = n * sizeof(struct ns__gasValveEvent);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__gasValveEvent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__gasValveEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__gasValveEvent %p -> %p\n", q, p));
	*(struct ns__gasValveEvent*)p = *(struct ns__gasValveEvent*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__gasValveEventResponse(struct soap *soap, const struct ns__gasValveEventResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__gasValveEventResponse(struct soap *soap, struct ns__gasValveEventResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->out = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__gasValveEventResponse(struct soap *soap, const struct ns__gasValveEventResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__gasValveEventResponse);
	if (soap_out_ns__gasValveEventResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__gasValveEventResponse(struct soap *soap, const char *tag, int id, const struct ns__gasValveEventResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__gasValveEventResponse), type);
	if (a->out)
		soap_element_result(soap, "out");
	soap_out_PointerToint(soap, "out", -1, &a->out, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__gasValveEventResponse * SOAP_FMAC4 soap_get_ns__gasValveEventResponse(struct soap *soap, struct ns__gasValveEventResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__gasValveEventResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__gasValveEventResponse * SOAP_FMAC4 soap_in_ns__gasValveEventResponse(struct soap *soap, const char *tag, struct ns__gasValveEventResponse *a, const char *type)
{
	short soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__gasValveEventResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__gasValveEventResponse, sizeof(struct ns__gasValveEventResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__gasValveEventResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "out", &a->out, "xsd:int"))
				{	soap_flag_out--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__gasValveEventResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__gasValveEventResponse, 0, sizeof(struct ns__gasValveEventResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__gasValveEventResponse * SOAP_FMAC6 soap_new_ns__gasValveEventResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__gasValveEventResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__gasValveEventResponse(struct soap *soap, struct ns__gasValveEventResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__gasValveEventResponse * SOAP_FMAC4 soap_instantiate_ns__gasValveEventResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__gasValveEventResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__gasValveEventResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__gasValveEventResponse;
		if (size)
			*size = sizeof(struct ns__gasValveEventResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__gasValveEventResponse[n];
		if (size)
			*size = n * sizeof(struct ns__gasValveEventResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__gasValveEventResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__gasValveEventResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__gasValveEventResponse %p -> %p\n", q, p));
	*(struct ns__gasValveEventResponse*)p = *(struct ns__gasValveEventResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setGasValve(struct soap *soap, const struct ns__setGasValve *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.soap_serialize(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setGasValve(struct soap *soap, struct ns__setGasValve *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.ns__gasValve::soap_default(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setGasValve(struct soap *soap, const struct ns__setGasValve *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__setGasValve);
	if (soap_out_ns__setGasValve(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setGasValve(struct soap *soap, const char *tag, int id, const struct ns__setGasValve *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__setGasValve), type);
	a->in.soap_out(soap, "in", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setGasValve * SOAP_FMAC4 soap_get_ns__setGasValve(struct soap *soap, struct ns__setGasValve *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setGasValve(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setGasValve * SOAP_FMAC4 soap_in_ns__setGasValve(struct soap *soap, const char *tag, struct ns__setGasValve *a, const char *type)
{
	short soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setGasValve *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__setGasValve, sizeof(struct ns__setGasValve), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__setGasValve(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && soap->error == SOAP_TAG_MISMATCH)
				if (a->in.soap_in(soap, "in", "ns:gasValve"))
				{	soap_flag_in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setGasValve *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__setGasValve, 0, sizeof(struct ns__setGasValve), 0, soap_copy_ns__setGasValve);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setGasValve * SOAP_FMAC6 soap_new_ns__setGasValve(struct soap *soap, int n)
{	return soap_instantiate_ns__setGasValve(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setGasValve(struct soap *soap, struct ns__setGasValve *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setGasValve * SOAP_FMAC4 soap_instantiate_ns__setGasValve(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setGasValve(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__setGasValve, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setGasValve;
		if (size)
			*size = sizeof(struct ns__setGasValve);
	}
	else
	{	cp->ptr = (void*)new struct ns__setGasValve[n];
		if (size)
			*size = n * sizeof(struct ns__setGasValve);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setGasValve*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setGasValve(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setGasValve %p -> %p\n", q, p));
	*(struct ns__setGasValve*)p = *(struct ns__setGasValve*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getGasValve(struct soap *soap, const struct ns__getGasValve *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.soap_serialize(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getGasValve(struct soap *soap, struct ns__getGasValve *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.ns__gasValve::soap_default(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getGasValve(struct soap *soap, const struct ns__getGasValve *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getGasValve);
	if (soap_out_ns__getGasValve(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getGasValve(struct soap *soap, const char *tag, int id, const struct ns__getGasValve *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getGasValve), type);
	a->in.soap_out(soap, "in", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getGasValve * SOAP_FMAC4 soap_get_ns__getGasValve(struct soap *soap, struct ns__getGasValve *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getGasValve(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getGasValve * SOAP_FMAC4 soap_in_ns__getGasValve(struct soap *soap, const char *tag, struct ns__getGasValve *a, const char *type)
{
	short soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getGasValve *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getGasValve, sizeof(struct ns__getGasValve), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__getGasValve(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && soap->error == SOAP_TAG_MISMATCH)
				if (a->in.soap_in(soap, "in", "ns:gasValve"))
				{	soap_flag_in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getGasValve *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getGasValve, 0, sizeof(struct ns__getGasValve), 0, soap_copy_ns__getGasValve);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getGasValve * SOAP_FMAC6 soap_new_ns__getGasValve(struct soap *soap, int n)
{	return soap_instantiate_ns__getGasValve(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getGasValve(struct soap *soap, struct ns__getGasValve *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getGasValve * SOAP_FMAC4 soap_instantiate_ns__getGasValve(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getGasValve(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getGasValve, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getGasValve;
		if (size)
			*size = sizeof(struct ns__getGasValve);
	}
	else
	{	cp->ptr = (void*)new struct ns__getGasValve[n];
		if (size)
			*size = n * sizeof(struct ns__getGasValve);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getGasValve*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getGasValve(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getGasValve %p -> %p\n", q, p));
	*(struct ns__getGasValve*)p = *(struct ns__getGasValve*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getGasValveItem(struct soap *soap, const struct ns__getGasValveItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->order, SOAP_TYPE_cmxDeviceService_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getGasValveItem(struct soap *soap, struct ns__getGasValveItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->order);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getGasValveItem(struct soap *soap, const struct ns__getGasValveItem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getGasValveItem);
	if (soap_out_ns__getGasValveItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getGasValveItem(struct soap *soap, const char *tag, int id, const struct ns__getGasValveItem *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getGasValveItem), type);
	soap_out_int(soap, "order", -1, &a->order, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getGasValveItem * SOAP_FMAC4 soap_get_ns__getGasValveItem(struct soap *soap, struct ns__getGasValveItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getGasValveItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getGasValveItem * SOAP_FMAC4 soap_in_ns__getGasValveItem(struct soap *soap, const char *tag, struct ns__getGasValveItem *a, const char *type)
{
	short soap_flag_order = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getGasValveItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getGasValveItem, sizeof(struct ns__getGasValveItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getGasValveItem(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_order && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "order", &a->order, "xsd:int"))
				{	soap_flag_order--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_order > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getGasValveItem *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getGasValveItem, 0, sizeof(struct ns__getGasValveItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getGasValveItem * SOAP_FMAC6 soap_new_ns__getGasValveItem(struct soap *soap, int n)
{	return soap_instantiate_ns__getGasValveItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getGasValveItem(struct soap *soap, struct ns__getGasValveItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getGasValveItem * SOAP_FMAC4 soap_instantiate_ns__getGasValveItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getGasValveItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getGasValveItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getGasValveItem;
		if (size)
			*size = sizeof(struct ns__getGasValveItem);
	}
	else
	{	cp->ptr = (void*)new struct ns__getGasValveItem[n];
		if (size)
			*size = n * sizeof(struct ns__getGasValveItem);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getGasValveItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getGasValveItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getGasValveItem %p -> %p\n", q, p));
	*(struct ns__getGasValveItem*)p = *(struct ns__getGasValveItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getGasValvePropertyItem(struct soap *soap, const struct ns__getGasValvePropertyItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->order, SOAP_TYPE_cmxDeviceService_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getGasValvePropertyItem(struct soap *soap, struct ns__getGasValvePropertyItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->order);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getGasValvePropertyItem(struct soap *soap, const struct ns__getGasValvePropertyItem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getGasValvePropertyItem);
	if (soap_out_ns__getGasValvePropertyItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getGasValvePropertyItem(struct soap *soap, const char *tag, int id, const struct ns__getGasValvePropertyItem *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getGasValvePropertyItem), type);
	soap_out_int(soap, "order", -1, &a->order, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getGasValvePropertyItem * SOAP_FMAC4 soap_get_ns__getGasValvePropertyItem(struct soap *soap, struct ns__getGasValvePropertyItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getGasValvePropertyItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getGasValvePropertyItem * SOAP_FMAC4 soap_in_ns__getGasValvePropertyItem(struct soap *soap, const char *tag, struct ns__getGasValvePropertyItem *a, const char *type)
{
	short soap_flag_order = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getGasValvePropertyItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getGasValvePropertyItem, sizeof(struct ns__getGasValvePropertyItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getGasValvePropertyItem(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_order && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "order", &a->order, "xsd:int"))
				{	soap_flag_order--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_order > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getGasValvePropertyItem *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getGasValvePropertyItem, 0, sizeof(struct ns__getGasValvePropertyItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getGasValvePropertyItem * SOAP_FMAC6 soap_new_ns__getGasValvePropertyItem(struct soap *soap, int n)
{	return soap_instantiate_ns__getGasValvePropertyItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getGasValvePropertyItem(struct soap *soap, struct ns__getGasValvePropertyItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getGasValvePropertyItem * SOAP_FMAC4 soap_instantiate_ns__getGasValvePropertyItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getGasValvePropertyItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getGasValvePropertyItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getGasValvePropertyItem;
		if (size)
			*size = sizeof(struct ns__getGasValvePropertyItem);
	}
	else
	{	cp->ptr = (void*)new struct ns__getGasValvePropertyItem[n];
		if (size)
			*size = n * sizeof(struct ns__getGasValvePropertyItem);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getGasValvePropertyItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getGasValvePropertyItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getGasValvePropertyItem %p -> %p\n", q, p));
	*(struct ns__getGasValvePropertyItem*)p = *(struct ns__getGasValvePropertyItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getGasValveCount(struct soap *soap, const struct ns__getGasValveCount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getGasValveCount(struct soap *soap, struct ns__getGasValveCount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getGasValveCount(struct soap *soap, const struct ns__getGasValveCount *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getGasValveCount);
	if (soap_out_ns__getGasValveCount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getGasValveCount(struct soap *soap, const char *tag, int id, const struct ns__getGasValveCount *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getGasValveCount), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getGasValveCount * SOAP_FMAC4 soap_get_ns__getGasValveCount(struct soap *soap, struct ns__getGasValveCount *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getGasValveCount(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getGasValveCount * SOAP_FMAC4 soap_in_ns__getGasValveCount(struct soap *soap, const char *tag, struct ns__getGasValveCount *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getGasValveCount *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getGasValveCount, sizeof(struct ns__getGasValveCount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getGasValveCount(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getGasValveCount *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getGasValveCount, 0, sizeof(struct ns__getGasValveCount), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getGasValveCount * SOAP_FMAC6 soap_new_ns__getGasValveCount(struct soap *soap, int n)
{	return soap_instantiate_ns__getGasValveCount(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getGasValveCount(struct soap *soap, struct ns__getGasValveCount *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getGasValveCount * SOAP_FMAC4 soap_instantiate_ns__getGasValveCount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getGasValveCount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getGasValveCount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getGasValveCount;
		if (size)
			*size = sizeof(struct ns__getGasValveCount);
	}
	else
	{	cp->ptr = (void*)new struct ns__getGasValveCount[n];
		if (size)
			*size = n * sizeof(struct ns__getGasValveCount);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getGasValveCount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getGasValveCount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getGasValveCount %p -> %p\n", q, p));
	*(struct ns__getGasValveCount*)p = *(struct ns__getGasValveCount*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getGasValveCountResponse(struct soap *soap, const struct ns__getGasValveCountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getGasValveCountResponse(struct soap *soap, struct ns__getGasValveCountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->out = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getGasValveCountResponse(struct soap *soap, const struct ns__getGasValveCountResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getGasValveCountResponse);
	if (soap_out_ns__getGasValveCountResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getGasValveCountResponse(struct soap *soap, const char *tag, int id, const struct ns__getGasValveCountResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getGasValveCountResponse), type);
	if (a->out)
		soap_element_result(soap, "out");
	soap_out_PointerToint(soap, "out", -1, &a->out, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getGasValveCountResponse * SOAP_FMAC4 soap_get_ns__getGasValveCountResponse(struct soap *soap, struct ns__getGasValveCountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getGasValveCountResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getGasValveCountResponse * SOAP_FMAC4 soap_in_ns__getGasValveCountResponse(struct soap *soap, const char *tag, struct ns__getGasValveCountResponse *a, const char *type)
{
	short soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getGasValveCountResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getGasValveCountResponse, sizeof(struct ns__getGasValveCountResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getGasValveCountResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "out", &a->out, "xsd:int"))
				{	soap_flag_out--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getGasValveCountResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getGasValveCountResponse, 0, sizeof(struct ns__getGasValveCountResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getGasValveCountResponse * SOAP_FMAC6 soap_new_ns__getGasValveCountResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getGasValveCountResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getGasValveCountResponse(struct soap *soap, struct ns__getGasValveCountResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getGasValveCountResponse * SOAP_FMAC4 soap_instantiate_ns__getGasValveCountResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getGasValveCountResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getGasValveCountResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getGasValveCountResponse;
		if (size)
			*size = sizeof(struct ns__getGasValveCountResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__getGasValveCountResponse[n];
		if (size)
			*size = n * sizeof(struct ns__getGasValveCountResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getGasValveCountResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getGasValveCountResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getGasValveCountResponse %p -> %p\n", q, p));
	*(struct ns__getGasValveCountResponse*)p = *(struct ns__getGasValveCountResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd_gasValveProperty(struct soap *soap, const struct xsd_gasValveProperty *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd_gasValveProperty(struct soap *soap, struct xsd_gasValveProperty *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->_gvDo_Close);
	soap_default_unsignedInt(soap, &a->_gvDo_Open);
	soap_default_unsignedInt(soap, &a->_gvAlarm_On);
	soap_default_unsignedInt(soap, &a->_gvAlarm_Off);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd_gasValveProperty(struct soap *soap, const struct xsd_gasValveProperty *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_xsd_gasValveProperty);
	if (soap_out_xsd_gasValveProperty(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd_gasValveProperty(struct soap *soap, const char *tag, int id, const struct xsd_gasValveProperty *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_xsd_gasValveProperty), type);
	soap_out_unsignedInt(soap, "gvDo-Close", -1, &a->_gvDo_Close, "");
	soap_out_unsignedInt(soap, "gvDo-Open", -1, &a->_gvDo_Open, "");
	soap_out_unsignedInt(soap, "gvAlarm-On", -1, &a->_gvAlarm_On, "");
	soap_out_unsignedInt(soap, "gvAlarm-Off", -1, &a->_gvAlarm_Off, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct xsd_gasValveProperty * SOAP_FMAC4 soap_get_xsd_gasValveProperty(struct soap *soap, struct xsd_gasValveProperty *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd_gasValveProperty(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct xsd_gasValveProperty * SOAP_FMAC4 soap_in_xsd_gasValveProperty(struct soap *soap, const char *tag, struct xsd_gasValveProperty *a, const char *type)
{
	short soap_flag__gvDo_Close = 1, soap_flag__gvDo_Open = 1, soap_flag__gvAlarm_On = 1, soap_flag__gvAlarm_Off = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct xsd_gasValveProperty *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_xsd_gasValveProperty, sizeof(struct xsd_gasValveProperty), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xsd_gasValveProperty(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__gvDo_Close && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_gvDo_Close, "xsd:unsignedInt"))
				{	soap_flag__gvDo_Close--;
					continue;
				}
			if (soap_flag__gvDo_Open && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_gvDo_Open, "xsd:unsignedInt"))
				{	soap_flag__gvDo_Open--;
					continue;
				}
			if (soap_flag__gvAlarm_On && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_gvAlarm_On, "xsd:unsignedInt"))
				{	soap_flag__gvAlarm_On--;
					continue;
				}
			if (soap_flag__gvAlarm_Off && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_gvAlarm_Off, "xsd:unsignedInt"))
				{	soap_flag__gvAlarm_Off--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__gvDo_Close > 0 || soap_flag__gvDo_Open > 0 || soap_flag__gvAlarm_On > 0 || soap_flag__gvAlarm_Off > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xsd_gasValveProperty *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_xsd_gasValveProperty, 0, sizeof(struct xsd_gasValveProperty), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct xsd_gasValveProperty * SOAP_FMAC6 soap_new_xsd_gasValveProperty(struct soap *soap, int n)
{	return soap_instantiate_xsd_gasValveProperty(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd_gasValveProperty(struct soap *soap, struct xsd_gasValveProperty *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct xsd_gasValveProperty * SOAP_FMAC4 soap_instantiate_xsd_gasValveProperty(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd_gasValveProperty(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_xsd_gasValveProperty, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct xsd_gasValveProperty;
		if (size)
			*size = sizeof(struct xsd_gasValveProperty);
	}
	else
	{	cp->ptr = (void*)new struct xsd_gasValveProperty[n];
		if (size)
			*size = n * sizeof(struct xsd_gasValveProperty);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct xsd_gasValveProperty*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd_gasValveProperty(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct xsd_gasValveProperty %p -> %p\n", q, p));
	*(struct xsd_gasValveProperty*)p = *(struct xsd_gasValveProperty*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__lightEvent(struct soap *soap, const struct ns__lightEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.soap_serialize(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__lightEvent(struct soap *soap, struct ns__lightEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.ns__light::soap_default(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__lightEvent(struct soap *soap, const struct ns__lightEvent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__lightEvent);
	if (soap_out_ns__lightEvent(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__lightEvent(struct soap *soap, const char *tag, int id, const struct ns__lightEvent *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__lightEvent), type);
	a->in.soap_out(soap, "in", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__lightEvent * SOAP_FMAC4 soap_get_ns__lightEvent(struct soap *soap, struct ns__lightEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__lightEvent(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__lightEvent * SOAP_FMAC4 soap_in_ns__lightEvent(struct soap *soap, const char *tag, struct ns__lightEvent *a, const char *type)
{
	short soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__lightEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__lightEvent, sizeof(struct ns__lightEvent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__lightEvent(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && soap->error == SOAP_TAG_MISMATCH)
				if (a->in.soap_in(soap, "in", "ns:light"))
				{	soap_flag_in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__lightEvent *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__lightEvent, 0, sizeof(struct ns__lightEvent), 0, soap_copy_ns__lightEvent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__lightEvent * SOAP_FMAC6 soap_new_ns__lightEvent(struct soap *soap, int n)
{	return soap_instantiate_ns__lightEvent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__lightEvent(struct soap *soap, struct ns__lightEvent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__lightEvent * SOAP_FMAC4 soap_instantiate_ns__lightEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__lightEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__lightEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__lightEvent;
		if (size)
			*size = sizeof(struct ns__lightEvent);
	}
	else
	{	cp->ptr = (void*)new struct ns__lightEvent[n];
		if (size)
			*size = n * sizeof(struct ns__lightEvent);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__lightEvent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__lightEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__lightEvent %p -> %p\n", q, p));
	*(struct ns__lightEvent*)p = *(struct ns__lightEvent*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__lightEventResponse(struct soap *soap, const struct ns__lightEventResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__lightEventResponse(struct soap *soap, struct ns__lightEventResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->out = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__lightEventResponse(struct soap *soap, const struct ns__lightEventResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__lightEventResponse);
	if (soap_out_ns__lightEventResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__lightEventResponse(struct soap *soap, const char *tag, int id, const struct ns__lightEventResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__lightEventResponse), type);
	if (a->out)
		soap_element_result(soap, "out");
	soap_out_PointerToint(soap, "out", -1, &a->out, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__lightEventResponse * SOAP_FMAC4 soap_get_ns__lightEventResponse(struct soap *soap, struct ns__lightEventResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__lightEventResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__lightEventResponse * SOAP_FMAC4 soap_in_ns__lightEventResponse(struct soap *soap, const char *tag, struct ns__lightEventResponse *a, const char *type)
{
	short soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__lightEventResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__lightEventResponse, sizeof(struct ns__lightEventResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__lightEventResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "out", &a->out, "xsd:int"))
				{	soap_flag_out--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__lightEventResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__lightEventResponse, 0, sizeof(struct ns__lightEventResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__lightEventResponse * SOAP_FMAC6 soap_new_ns__lightEventResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__lightEventResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__lightEventResponse(struct soap *soap, struct ns__lightEventResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__lightEventResponse * SOAP_FMAC4 soap_instantiate_ns__lightEventResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__lightEventResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__lightEventResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__lightEventResponse;
		if (size)
			*size = sizeof(struct ns__lightEventResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__lightEventResponse[n];
		if (size)
			*size = n * sizeof(struct ns__lightEventResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__lightEventResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__lightEventResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__lightEventResponse %p -> %p\n", q, p));
	*(struct ns__lightEventResponse*)p = *(struct ns__lightEventResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setLight(struct soap *soap, const struct ns__setLight *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.soap_serialize(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setLight(struct soap *soap, struct ns__setLight *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.ns__light::soap_default(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setLight(struct soap *soap, const struct ns__setLight *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__setLight);
	if (soap_out_ns__setLight(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setLight(struct soap *soap, const char *tag, int id, const struct ns__setLight *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__setLight), type);
	a->in.soap_out(soap, "in", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setLight * SOAP_FMAC4 soap_get_ns__setLight(struct soap *soap, struct ns__setLight *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setLight(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setLight * SOAP_FMAC4 soap_in_ns__setLight(struct soap *soap, const char *tag, struct ns__setLight *a, const char *type)
{
	short soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setLight *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__setLight, sizeof(struct ns__setLight), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__setLight(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && soap->error == SOAP_TAG_MISMATCH)
				if (a->in.soap_in(soap, "in", "ns:light"))
				{	soap_flag_in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setLight *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__setLight, 0, sizeof(struct ns__setLight), 0, soap_copy_ns__setLight);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setLight * SOAP_FMAC6 soap_new_ns__setLight(struct soap *soap, int n)
{	return soap_instantiate_ns__setLight(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setLight(struct soap *soap, struct ns__setLight *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setLight * SOAP_FMAC4 soap_instantiate_ns__setLight(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setLight(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__setLight, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setLight;
		if (size)
			*size = sizeof(struct ns__setLight);
	}
	else
	{	cp->ptr = (void*)new struct ns__setLight[n];
		if (size)
			*size = n * sizeof(struct ns__setLight);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setLight*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setLight(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setLight %p -> %p\n", q, p));
	*(struct ns__setLight*)p = *(struct ns__setLight*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getLight(struct soap *soap, const struct ns__getLight *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.soap_serialize(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getLight(struct soap *soap, struct ns__getLight *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.ns__light::soap_default(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getLight(struct soap *soap, const struct ns__getLight *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getLight);
	if (soap_out_ns__getLight(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getLight(struct soap *soap, const char *tag, int id, const struct ns__getLight *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getLight), type);
	a->in.soap_out(soap, "in", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getLight * SOAP_FMAC4 soap_get_ns__getLight(struct soap *soap, struct ns__getLight *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getLight(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getLight * SOAP_FMAC4 soap_in_ns__getLight(struct soap *soap, const char *tag, struct ns__getLight *a, const char *type)
{
	short soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getLight *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getLight, sizeof(struct ns__getLight), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__getLight(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && soap->error == SOAP_TAG_MISMATCH)
				if (a->in.soap_in(soap, "in", "ns:light"))
				{	soap_flag_in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getLight *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getLight, 0, sizeof(struct ns__getLight), 0, soap_copy_ns__getLight);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getLight * SOAP_FMAC6 soap_new_ns__getLight(struct soap *soap, int n)
{	return soap_instantiate_ns__getLight(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getLight(struct soap *soap, struct ns__getLight *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getLight * SOAP_FMAC4 soap_instantiate_ns__getLight(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getLight(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getLight, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getLight;
		if (size)
			*size = sizeof(struct ns__getLight);
	}
	else
	{	cp->ptr = (void*)new struct ns__getLight[n];
		if (size)
			*size = n * sizeof(struct ns__getLight);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getLight*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getLight(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getLight %p -> %p\n", q, p));
	*(struct ns__getLight*)p = *(struct ns__getLight*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getLightItem(struct soap *soap, const struct ns__getLightItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->order, SOAP_TYPE_cmxDeviceService_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getLightItem(struct soap *soap, struct ns__getLightItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->order);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getLightItem(struct soap *soap, const struct ns__getLightItem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getLightItem);
	if (soap_out_ns__getLightItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getLightItem(struct soap *soap, const char *tag, int id, const struct ns__getLightItem *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getLightItem), type);
	soap_out_int(soap, "order", -1, &a->order, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getLightItem * SOAP_FMAC4 soap_get_ns__getLightItem(struct soap *soap, struct ns__getLightItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getLightItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getLightItem * SOAP_FMAC4 soap_in_ns__getLightItem(struct soap *soap, const char *tag, struct ns__getLightItem *a, const char *type)
{
	short soap_flag_order = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getLightItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getLightItem, sizeof(struct ns__getLightItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getLightItem(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_order && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "order", &a->order, "xsd:int"))
				{	soap_flag_order--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_order > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getLightItem *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getLightItem, 0, sizeof(struct ns__getLightItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getLightItem * SOAP_FMAC6 soap_new_ns__getLightItem(struct soap *soap, int n)
{	return soap_instantiate_ns__getLightItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getLightItem(struct soap *soap, struct ns__getLightItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getLightItem * SOAP_FMAC4 soap_instantiate_ns__getLightItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getLightItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getLightItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getLightItem;
		if (size)
			*size = sizeof(struct ns__getLightItem);
	}
	else
	{	cp->ptr = (void*)new struct ns__getLightItem[n];
		if (size)
			*size = n * sizeof(struct ns__getLightItem);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getLightItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getLightItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getLightItem %p -> %p\n", q, p));
	*(struct ns__getLightItem*)p = *(struct ns__getLightItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getLightPropertyItem(struct soap *soap, const struct ns__getLightPropertyItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->order, SOAP_TYPE_cmxDeviceService_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getLightPropertyItem(struct soap *soap, struct ns__getLightPropertyItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->order);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getLightPropertyItem(struct soap *soap, const struct ns__getLightPropertyItem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getLightPropertyItem);
	if (soap_out_ns__getLightPropertyItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getLightPropertyItem(struct soap *soap, const char *tag, int id, const struct ns__getLightPropertyItem *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getLightPropertyItem), type);
	soap_out_int(soap, "order", -1, &a->order, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getLightPropertyItem * SOAP_FMAC4 soap_get_ns__getLightPropertyItem(struct soap *soap, struct ns__getLightPropertyItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getLightPropertyItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getLightPropertyItem * SOAP_FMAC4 soap_in_ns__getLightPropertyItem(struct soap *soap, const char *tag, struct ns__getLightPropertyItem *a, const char *type)
{
	short soap_flag_order = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getLightPropertyItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getLightPropertyItem, sizeof(struct ns__getLightPropertyItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getLightPropertyItem(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_order && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "order", &a->order, "xsd:int"))
				{	soap_flag_order--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_order > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getLightPropertyItem *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getLightPropertyItem, 0, sizeof(struct ns__getLightPropertyItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getLightPropertyItem * SOAP_FMAC6 soap_new_ns__getLightPropertyItem(struct soap *soap, int n)
{	return soap_instantiate_ns__getLightPropertyItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getLightPropertyItem(struct soap *soap, struct ns__getLightPropertyItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getLightPropertyItem * SOAP_FMAC4 soap_instantiate_ns__getLightPropertyItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getLightPropertyItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getLightPropertyItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getLightPropertyItem;
		if (size)
			*size = sizeof(struct ns__getLightPropertyItem);
	}
	else
	{	cp->ptr = (void*)new struct ns__getLightPropertyItem[n];
		if (size)
			*size = n * sizeof(struct ns__getLightPropertyItem);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getLightPropertyItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getLightPropertyItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getLightPropertyItem %p -> %p\n", q, p));
	*(struct ns__getLightPropertyItem*)p = *(struct ns__getLightPropertyItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getLightCount(struct soap *soap, const struct ns__getLightCount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getLightCount(struct soap *soap, struct ns__getLightCount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getLightCount(struct soap *soap, const struct ns__getLightCount *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getLightCount);
	if (soap_out_ns__getLightCount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getLightCount(struct soap *soap, const char *tag, int id, const struct ns__getLightCount *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getLightCount), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getLightCount * SOAP_FMAC4 soap_get_ns__getLightCount(struct soap *soap, struct ns__getLightCount *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getLightCount(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getLightCount * SOAP_FMAC4 soap_in_ns__getLightCount(struct soap *soap, const char *tag, struct ns__getLightCount *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getLightCount *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getLightCount, sizeof(struct ns__getLightCount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getLightCount(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getLightCount *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getLightCount, 0, sizeof(struct ns__getLightCount), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getLightCount * SOAP_FMAC6 soap_new_ns__getLightCount(struct soap *soap, int n)
{	return soap_instantiate_ns__getLightCount(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getLightCount(struct soap *soap, struct ns__getLightCount *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getLightCount * SOAP_FMAC4 soap_instantiate_ns__getLightCount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getLightCount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getLightCount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getLightCount;
		if (size)
			*size = sizeof(struct ns__getLightCount);
	}
	else
	{	cp->ptr = (void*)new struct ns__getLightCount[n];
		if (size)
			*size = n * sizeof(struct ns__getLightCount);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getLightCount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getLightCount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getLightCount %p -> %p\n", q, p));
	*(struct ns__getLightCount*)p = *(struct ns__getLightCount*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getLightCountResponse(struct soap *soap, const struct ns__getLightCountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getLightCountResponse(struct soap *soap, struct ns__getLightCountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->out = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getLightCountResponse(struct soap *soap, const struct ns__getLightCountResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getLightCountResponse);
	if (soap_out_ns__getLightCountResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getLightCountResponse(struct soap *soap, const char *tag, int id, const struct ns__getLightCountResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getLightCountResponse), type);
	if (a->out)
		soap_element_result(soap, "out");
	soap_out_PointerToint(soap, "out", -1, &a->out, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getLightCountResponse * SOAP_FMAC4 soap_get_ns__getLightCountResponse(struct soap *soap, struct ns__getLightCountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getLightCountResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getLightCountResponse * SOAP_FMAC4 soap_in_ns__getLightCountResponse(struct soap *soap, const char *tag, struct ns__getLightCountResponse *a, const char *type)
{
	short soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getLightCountResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getLightCountResponse, sizeof(struct ns__getLightCountResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getLightCountResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "out", &a->out, "xsd:int"))
				{	soap_flag_out--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getLightCountResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getLightCountResponse, 0, sizeof(struct ns__getLightCountResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getLightCountResponse * SOAP_FMAC6 soap_new_ns__getLightCountResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getLightCountResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getLightCountResponse(struct soap *soap, struct ns__getLightCountResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getLightCountResponse * SOAP_FMAC4 soap_instantiate_ns__getLightCountResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getLightCountResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getLightCountResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getLightCountResponse;
		if (size)
			*size = sizeof(struct ns__getLightCountResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__getLightCountResponse[n];
		if (size)
			*size = n * sizeof(struct ns__getLightCountResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getLightCountResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getLightCountResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getLightCountResponse %p -> %p\n", q, p));
	*(struct ns__getLightCountResponse*)p = *(struct ns__getLightCountResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd_LightProperty(struct soap *soap, const struct xsd_LightProperty *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd_LightProperty(struct soap *soap, struct xsd_LightProperty *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->_lightBinary);
	soap_default_unsignedInt(soap, &a->_lightDimmable);
	soap_default_unsignedInt(soap, &a->_lightPower_Off);
	soap_default_unsignedInt(soap, &a->_lightPower_On);
	soap_default_unsignedInt(soap, &a->_lightPower_AllOff);
	soap_default_unsignedInt(soap, &a->_lightPower_AllOn);
	soap_default_unsignedInt(soap, &a->dimmerLevelFrom);
	soap_default_unsignedInt(soap, &a->dimmerLevelTo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd_LightProperty(struct soap *soap, const struct xsd_LightProperty *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_xsd_LightProperty);
	if (soap_out_xsd_LightProperty(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd_LightProperty(struct soap *soap, const char *tag, int id, const struct xsd_LightProperty *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_xsd_LightProperty), type);
	soap_out_unsignedInt(soap, "lightBinary", -1, &a->_lightBinary, "");
	soap_out_unsignedInt(soap, "lightDimmable", -1, &a->_lightDimmable, "");
	soap_out_unsignedInt(soap, "lightPower-Off", -1, &a->_lightPower_Off, "");
	soap_out_unsignedInt(soap, "lightPower-On", -1, &a->_lightPower_On, "");
	soap_out_unsignedInt(soap, "lightPower-AllOff", -1, &a->_lightPower_AllOff, "");
	soap_out_unsignedInt(soap, "lightPower-AllOn", -1, &a->_lightPower_AllOn, "");
	soap_out_unsignedInt(soap, "dimmerLevelFrom", -1, &a->dimmerLevelFrom, "");
	soap_out_unsignedInt(soap, "dimmerLevelTo", -1, &a->dimmerLevelTo, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct xsd_LightProperty * SOAP_FMAC4 soap_get_xsd_LightProperty(struct soap *soap, struct xsd_LightProperty *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd_LightProperty(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct xsd_LightProperty * SOAP_FMAC4 soap_in_xsd_LightProperty(struct soap *soap, const char *tag, struct xsd_LightProperty *a, const char *type)
{
	short soap_flag__lightBinary = 1, soap_flag__lightDimmable = 1, soap_flag__lightPower_Off = 1, soap_flag__lightPower_On = 1, soap_flag__lightPower_AllOff = 1, soap_flag__lightPower_AllOn = 1, soap_flag_dimmerLevelFrom = 4, soap_flag_dimmerLevelTo = 4;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct xsd_LightProperty *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_xsd_LightProperty, sizeof(struct xsd_LightProperty), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xsd_LightProperty(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__lightBinary && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_lightBinary, "xsd:unsignedInt"))
				{	soap_flag__lightBinary--;
					continue;
				}
			if (soap_flag__lightDimmable && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_lightDimmable, "xsd:unsignedInt"))
				{	soap_flag__lightDimmable--;
					continue;
				}
			if (soap_flag__lightPower_Off && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_lightPower_Off, "xsd:unsignedInt"))
				{	soap_flag__lightPower_Off--;
					continue;
				}
			if (soap_flag__lightPower_On && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_lightPower_On, "xsd:unsignedInt"))
				{	soap_flag__lightPower_On--;
					continue;
				}
			if (soap_flag__lightPower_AllOff && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_lightPower_AllOff, "xsd:unsignedInt"))
				{	soap_flag__lightPower_AllOff--;
					continue;
				}
			if (soap_flag__lightPower_AllOn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_lightPower_AllOn, "xsd:unsignedInt"))
				{	soap_flag__lightPower_AllOn--;
					continue;
				}
			if (soap_flag_dimmerLevelFrom && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "dimmerLevelFrom", &a->dimmerLevelFrom, "xsd:unsignedInt"))
				{	soap_flag_dimmerLevelFrom--;
					continue;
				}
			if (soap_flag_dimmerLevelTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "dimmerLevelTo", &a->dimmerLevelTo, "xsd:unsignedInt"))
				{	soap_flag_dimmerLevelTo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__lightBinary > 0 || soap_flag__lightDimmable > 0 || soap_flag__lightPower_Off > 0 || soap_flag__lightPower_On > 0 || soap_flag__lightPower_AllOff > 0 || soap_flag__lightPower_AllOn > 0 || soap_flag_dimmerLevelFrom > 3 || soap_flag_dimmerLevelTo > 3))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xsd_LightProperty *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_xsd_LightProperty, 0, sizeof(struct xsd_LightProperty), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct xsd_LightProperty * SOAP_FMAC6 soap_new_xsd_LightProperty(struct soap *soap, int n)
{	return soap_instantiate_xsd_LightProperty(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd_LightProperty(struct soap *soap, struct xsd_LightProperty *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct xsd_LightProperty * SOAP_FMAC4 soap_instantiate_xsd_LightProperty(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd_LightProperty(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_xsd_LightProperty, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct xsd_LightProperty;
		if (size)
			*size = sizeof(struct xsd_LightProperty);
	}
	else
	{	cp->ptr = (void*)new struct xsd_LightProperty[n];
		if (size)
			*size = n * sizeof(struct xsd_LightProperty);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct xsd_LightProperty*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd_LightProperty(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct xsd_LightProperty %p -> %p\n", q, p));
	*(struct xsd_LightProperty*)p = *(struct xsd_LightProperty*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__boilerEvent(struct soap *soap, const struct ns__boilerEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.soap_serialize(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__boilerEvent(struct soap *soap, struct ns__boilerEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.ns__boiler::soap_default(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__boilerEvent(struct soap *soap, const struct ns__boilerEvent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__boilerEvent);
	if (soap_out_ns__boilerEvent(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__boilerEvent(struct soap *soap, const char *tag, int id, const struct ns__boilerEvent *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__boilerEvent), type);
	a->in.soap_out(soap, "in", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__boilerEvent * SOAP_FMAC4 soap_get_ns__boilerEvent(struct soap *soap, struct ns__boilerEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__boilerEvent(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__boilerEvent * SOAP_FMAC4 soap_in_ns__boilerEvent(struct soap *soap, const char *tag, struct ns__boilerEvent *a, const char *type)
{
	short soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__boilerEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__boilerEvent, sizeof(struct ns__boilerEvent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__boilerEvent(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && soap->error == SOAP_TAG_MISMATCH)
				if (a->in.soap_in(soap, "in", "ns:boiler"))
				{	soap_flag_in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__boilerEvent *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__boilerEvent, 0, sizeof(struct ns__boilerEvent), 0, soap_copy_ns__boilerEvent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__boilerEvent * SOAP_FMAC6 soap_new_ns__boilerEvent(struct soap *soap, int n)
{	return soap_instantiate_ns__boilerEvent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__boilerEvent(struct soap *soap, struct ns__boilerEvent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__boilerEvent * SOAP_FMAC4 soap_instantiate_ns__boilerEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__boilerEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__boilerEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__boilerEvent;
		if (size)
			*size = sizeof(struct ns__boilerEvent);
	}
	else
	{	cp->ptr = (void*)new struct ns__boilerEvent[n];
		if (size)
			*size = n * sizeof(struct ns__boilerEvent);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__boilerEvent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__boilerEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__boilerEvent %p -> %p\n", q, p));
	*(struct ns__boilerEvent*)p = *(struct ns__boilerEvent*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__boilerEventResponse(struct soap *soap, const struct ns__boilerEventResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__boilerEventResponse(struct soap *soap, struct ns__boilerEventResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->out = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__boilerEventResponse(struct soap *soap, const struct ns__boilerEventResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__boilerEventResponse);
	if (soap_out_ns__boilerEventResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__boilerEventResponse(struct soap *soap, const char *tag, int id, const struct ns__boilerEventResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__boilerEventResponse), type);
	if (a->out)
		soap_element_result(soap, "out");
	soap_out_PointerToint(soap, "out", -1, &a->out, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__boilerEventResponse * SOAP_FMAC4 soap_get_ns__boilerEventResponse(struct soap *soap, struct ns__boilerEventResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__boilerEventResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__boilerEventResponse * SOAP_FMAC4 soap_in_ns__boilerEventResponse(struct soap *soap, const char *tag, struct ns__boilerEventResponse *a, const char *type)
{
	short soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__boilerEventResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__boilerEventResponse, sizeof(struct ns__boilerEventResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__boilerEventResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "out", &a->out, "xsd:int"))
				{	soap_flag_out--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__boilerEventResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__boilerEventResponse, 0, sizeof(struct ns__boilerEventResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__boilerEventResponse * SOAP_FMAC6 soap_new_ns__boilerEventResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__boilerEventResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__boilerEventResponse(struct soap *soap, struct ns__boilerEventResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__boilerEventResponse * SOAP_FMAC4 soap_instantiate_ns__boilerEventResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__boilerEventResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__boilerEventResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__boilerEventResponse;
		if (size)
			*size = sizeof(struct ns__boilerEventResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__boilerEventResponse[n];
		if (size)
			*size = n * sizeof(struct ns__boilerEventResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__boilerEventResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__boilerEventResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__boilerEventResponse %p -> %p\n", q, p));
	*(struct ns__boilerEventResponse*)p = *(struct ns__boilerEventResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setBoiler(struct soap *soap, const struct ns__setBoiler *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.soap_serialize(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setBoiler(struct soap *soap, struct ns__setBoiler *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.ns__boiler::soap_default(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setBoiler(struct soap *soap, const struct ns__setBoiler *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__setBoiler);
	if (soap_out_ns__setBoiler(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setBoiler(struct soap *soap, const char *tag, int id, const struct ns__setBoiler *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__setBoiler), type);
	a->in.soap_out(soap, "in", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setBoiler * SOAP_FMAC4 soap_get_ns__setBoiler(struct soap *soap, struct ns__setBoiler *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setBoiler(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setBoiler * SOAP_FMAC4 soap_in_ns__setBoiler(struct soap *soap, const char *tag, struct ns__setBoiler *a, const char *type)
{
	short soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setBoiler *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__setBoiler, sizeof(struct ns__setBoiler), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__setBoiler(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && soap->error == SOAP_TAG_MISMATCH)
				if (a->in.soap_in(soap, "in", "ns:boiler"))
				{	soap_flag_in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setBoiler *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__setBoiler, 0, sizeof(struct ns__setBoiler), 0, soap_copy_ns__setBoiler);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setBoiler * SOAP_FMAC6 soap_new_ns__setBoiler(struct soap *soap, int n)
{	return soap_instantiate_ns__setBoiler(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setBoiler(struct soap *soap, struct ns__setBoiler *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setBoiler * SOAP_FMAC4 soap_instantiate_ns__setBoiler(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setBoiler(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__setBoiler, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setBoiler;
		if (size)
			*size = sizeof(struct ns__setBoiler);
	}
	else
	{	cp->ptr = (void*)new struct ns__setBoiler[n];
		if (size)
			*size = n * sizeof(struct ns__setBoiler);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setBoiler*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setBoiler(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setBoiler %p -> %p\n", q, p));
	*(struct ns__setBoiler*)p = *(struct ns__setBoiler*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getBoiler(struct soap *soap, const struct ns__getBoiler *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.soap_serialize(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getBoiler(struct soap *soap, struct ns__getBoiler *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.ns__boiler::soap_default(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getBoiler(struct soap *soap, const struct ns__getBoiler *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getBoiler);
	if (soap_out_ns__getBoiler(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getBoiler(struct soap *soap, const char *tag, int id, const struct ns__getBoiler *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getBoiler), type);
	a->in.soap_out(soap, "in", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getBoiler * SOAP_FMAC4 soap_get_ns__getBoiler(struct soap *soap, struct ns__getBoiler *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getBoiler(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getBoiler * SOAP_FMAC4 soap_in_ns__getBoiler(struct soap *soap, const char *tag, struct ns__getBoiler *a, const char *type)
{
	short soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getBoiler *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getBoiler, sizeof(struct ns__getBoiler), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__getBoiler(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && soap->error == SOAP_TAG_MISMATCH)
				if (a->in.soap_in(soap, "in", "ns:boiler"))
				{	soap_flag_in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getBoiler *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getBoiler, 0, sizeof(struct ns__getBoiler), 0, soap_copy_ns__getBoiler);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getBoiler * SOAP_FMAC6 soap_new_ns__getBoiler(struct soap *soap, int n)
{	return soap_instantiate_ns__getBoiler(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getBoiler(struct soap *soap, struct ns__getBoiler *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getBoiler * SOAP_FMAC4 soap_instantiate_ns__getBoiler(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getBoiler(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getBoiler, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getBoiler;
		if (size)
			*size = sizeof(struct ns__getBoiler);
	}
	else
	{	cp->ptr = (void*)new struct ns__getBoiler[n];
		if (size)
			*size = n * sizeof(struct ns__getBoiler);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getBoiler*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getBoiler(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getBoiler %p -> %p\n", q, p));
	*(struct ns__getBoiler*)p = *(struct ns__getBoiler*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getBoilerItem(struct soap *soap, const struct ns__getBoilerItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->order, SOAP_TYPE_cmxDeviceService_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getBoilerItem(struct soap *soap, struct ns__getBoilerItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->order);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getBoilerItem(struct soap *soap, const struct ns__getBoilerItem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getBoilerItem);
	if (soap_out_ns__getBoilerItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getBoilerItem(struct soap *soap, const char *tag, int id, const struct ns__getBoilerItem *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getBoilerItem), type);
	soap_out_int(soap, "order", -1, &a->order, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getBoilerItem * SOAP_FMAC4 soap_get_ns__getBoilerItem(struct soap *soap, struct ns__getBoilerItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getBoilerItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getBoilerItem * SOAP_FMAC4 soap_in_ns__getBoilerItem(struct soap *soap, const char *tag, struct ns__getBoilerItem *a, const char *type)
{
	short soap_flag_order = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getBoilerItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getBoilerItem, sizeof(struct ns__getBoilerItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getBoilerItem(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_order && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "order", &a->order, "xsd:int"))
				{	soap_flag_order--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_order > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getBoilerItem *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getBoilerItem, 0, sizeof(struct ns__getBoilerItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getBoilerItem * SOAP_FMAC6 soap_new_ns__getBoilerItem(struct soap *soap, int n)
{	return soap_instantiate_ns__getBoilerItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getBoilerItem(struct soap *soap, struct ns__getBoilerItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getBoilerItem * SOAP_FMAC4 soap_instantiate_ns__getBoilerItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getBoilerItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getBoilerItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getBoilerItem;
		if (size)
			*size = sizeof(struct ns__getBoilerItem);
	}
	else
	{	cp->ptr = (void*)new struct ns__getBoilerItem[n];
		if (size)
			*size = n * sizeof(struct ns__getBoilerItem);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getBoilerItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getBoilerItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getBoilerItem %p -> %p\n", q, p));
	*(struct ns__getBoilerItem*)p = *(struct ns__getBoilerItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getBoilerPropertyItem(struct soap *soap, const struct ns__getBoilerPropertyItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->order, SOAP_TYPE_cmxDeviceService_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getBoilerPropertyItem(struct soap *soap, struct ns__getBoilerPropertyItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->order);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getBoilerPropertyItem(struct soap *soap, const struct ns__getBoilerPropertyItem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getBoilerPropertyItem);
	if (soap_out_ns__getBoilerPropertyItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getBoilerPropertyItem(struct soap *soap, const char *tag, int id, const struct ns__getBoilerPropertyItem *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getBoilerPropertyItem), type);
	soap_out_int(soap, "order", -1, &a->order, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getBoilerPropertyItem * SOAP_FMAC4 soap_get_ns__getBoilerPropertyItem(struct soap *soap, struct ns__getBoilerPropertyItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getBoilerPropertyItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getBoilerPropertyItem * SOAP_FMAC4 soap_in_ns__getBoilerPropertyItem(struct soap *soap, const char *tag, struct ns__getBoilerPropertyItem *a, const char *type)
{
	short soap_flag_order = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getBoilerPropertyItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getBoilerPropertyItem, sizeof(struct ns__getBoilerPropertyItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getBoilerPropertyItem(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_order && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "order", &a->order, "xsd:int"))
				{	soap_flag_order--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_order > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getBoilerPropertyItem *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getBoilerPropertyItem, 0, sizeof(struct ns__getBoilerPropertyItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getBoilerPropertyItem * SOAP_FMAC6 soap_new_ns__getBoilerPropertyItem(struct soap *soap, int n)
{	return soap_instantiate_ns__getBoilerPropertyItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getBoilerPropertyItem(struct soap *soap, struct ns__getBoilerPropertyItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getBoilerPropertyItem * SOAP_FMAC4 soap_instantiate_ns__getBoilerPropertyItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getBoilerPropertyItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getBoilerPropertyItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getBoilerPropertyItem;
		if (size)
			*size = sizeof(struct ns__getBoilerPropertyItem);
	}
	else
	{	cp->ptr = (void*)new struct ns__getBoilerPropertyItem[n];
		if (size)
			*size = n * sizeof(struct ns__getBoilerPropertyItem);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getBoilerPropertyItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getBoilerPropertyItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getBoilerPropertyItem %p -> %p\n", q, p));
	*(struct ns__getBoilerPropertyItem*)p = *(struct ns__getBoilerPropertyItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getBoilerCount(struct soap *soap, const struct ns__getBoilerCount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getBoilerCount(struct soap *soap, struct ns__getBoilerCount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getBoilerCount(struct soap *soap, const struct ns__getBoilerCount *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getBoilerCount);
	if (soap_out_ns__getBoilerCount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getBoilerCount(struct soap *soap, const char *tag, int id, const struct ns__getBoilerCount *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getBoilerCount), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getBoilerCount * SOAP_FMAC4 soap_get_ns__getBoilerCount(struct soap *soap, struct ns__getBoilerCount *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getBoilerCount(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getBoilerCount * SOAP_FMAC4 soap_in_ns__getBoilerCount(struct soap *soap, const char *tag, struct ns__getBoilerCount *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getBoilerCount *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getBoilerCount, sizeof(struct ns__getBoilerCount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getBoilerCount(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getBoilerCount *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getBoilerCount, 0, sizeof(struct ns__getBoilerCount), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getBoilerCount * SOAP_FMAC6 soap_new_ns__getBoilerCount(struct soap *soap, int n)
{	return soap_instantiate_ns__getBoilerCount(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getBoilerCount(struct soap *soap, struct ns__getBoilerCount *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getBoilerCount * SOAP_FMAC4 soap_instantiate_ns__getBoilerCount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getBoilerCount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getBoilerCount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getBoilerCount;
		if (size)
			*size = sizeof(struct ns__getBoilerCount);
	}
	else
	{	cp->ptr = (void*)new struct ns__getBoilerCount[n];
		if (size)
			*size = n * sizeof(struct ns__getBoilerCount);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getBoilerCount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getBoilerCount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getBoilerCount %p -> %p\n", q, p));
	*(struct ns__getBoilerCount*)p = *(struct ns__getBoilerCount*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getBoilerCountResponse(struct soap *soap, const struct ns__getBoilerCountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getBoilerCountResponse(struct soap *soap, struct ns__getBoilerCountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->out = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getBoilerCountResponse(struct soap *soap, const struct ns__getBoilerCountResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getBoilerCountResponse);
	if (soap_out_ns__getBoilerCountResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getBoilerCountResponse(struct soap *soap, const char *tag, int id, const struct ns__getBoilerCountResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getBoilerCountResponse), type);
	if (a->out)
		soap_element_result(soap, "out");
	soap_out_PointerToint(soap, "out", -1, &a->out, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getBoilerCountResponse * SOAP_FMAC4 soap_get_ns__getBoilerCountResponse(struct soap *soap, struct ns__getBoilerCountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getBoilerCountResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getBoilerCountResponse * SOAP_FMAC4 soap_in_ns__getBoilerCountResponse(struct soap *soap, const char *tag, struct ns__getBoilerCountResponse *a, const char *type)
{
	short soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getBoilerCountResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getBoilerCountResponse, sizeof(struct ns__getBoilerCountResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getBoilerCountResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "out", &a->out, "xsd:int"))
				{	soap_flag_out--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getBoilerCountResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getBoilerCountResponse, 0, sizeof(struct ns__getBoilerCountResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getBoilerCountResponse * SOAP_FMAC6 soap_new_ns__getBoilerCountResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getBoilerCountResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getBoilerCountResponse(struct soap *soap, struct ns__getBoilerCountResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getBoilerCountResponse * SOAP_FMAC4 soap_instantiate_ns__getBoilerCountResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getBoilerCountResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getBoilerCountResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getBoilerCountResponse;
		if (size)
			*size = sizeof(struct ns__getBoilerCountResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__getBoilerCountResponse[n];
		if (size)
			*size = n * sizeof(struct ns__getBoilerCountResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getBoilerCountResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getBoilerCountResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getBoilerCountResponse %p -> %p\n", q, p));
	*(struct ns__getBoilerCountResponse*)p = *(struct ns__getBoilerCountResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd_BoilerProperty(struct soap *soap, const struct xsd_BoilerProperty *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd_BoilerProperty(struct soap *soap, struct xsd_BoilerProperty *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->_indivisualBoiler);
	soap_default_unsignedInt(soap, &a->_eachBoiler);
	soap_default_unsignedInt(soap, &a->_boilerPower_Off);
	soap_default_unsignedInt(soap, &a->_boilerPower_On);
	soap_default_unsignedInt(soap, &a->_boilerHeatingPower_Off);
	soap_default_unsignedInt(soap, &a->_boilerHeatingPower_On);
	soap_default_unsignedInt(soap, &a->_boilerOutMode_Set);
	soap_default_unsignedInt(soap, &a->_boilerOutMode_Release);
	soap_default_unsignedInt(soap, &a->_boilerDipSwitchMode_Hypocaust);
	soap_default_unsignedInt(soap, &a->_boilerDipSwitchMode_InnerTemperature);
	soap_default_unsignedInt(soap, &a->boilerRequestedTemperature);
	soap_default_unsignedInt(soap, &a->boilerRequestedTemperatureFrom);
	soap_default_unsignedInt(soap, &a->boilerRequestedTemperatureTo);
	soap_default_unsignedInt(soap, &a->boilerCurrentTemperature);
	soap_default_unsignedInt(soap, &a->boilerCurrentTemperatureFrom);
	soap_default_unsignedInt(soap, &a->boilerCurrentTemperatureTo);
	soap_default_unsignedInt(soap, &a->boilerHeatingWaterTemperature);
	soap_default_unsignedInt(soap, &a->boilerHeatingWaterTemperatureFrom);
	soap_default_unsignedInt(soap, &a->boilerHeatingWaterTemperatureTo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd_BoilerProperty(struct soap *soap, const struct xsd_BoilerProperty *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_xsd_BoilerProperty);
	if (soap_out_xsd_BoilerProperty(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd_BoilerProperty(struct soap *soap, const char *tag, int id, const struct xsd_BoilerProperty *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_xsd_BoilerProperty), type);
	soap_out_unsignedInt(soap, "indivisualBoiler", -1, &a->_indivisualBoiler, "");
	soap_out_unsignedInt(soap, "eachBoiler", -1, &a->_eachBoiler, "");
	soap_out_unsignedInt(soap, "boilerPower-Off", -1, &a->_boilerPower_Off, "");
	soap_out_unsignedInt(soap, "boilerPower-On", -1, &a->_boilerPower_On, "");
	soap_out_unsignedInt(soap, "boilerHeatingPower-Off", -1, &a->_boilerHeatingPower_Off, "");
	soap_out_unsignedInt(soap, "boilerHeatingPower-On", -1, &a->_boilerHeatingPower_On, "");
	soap_out_unsignedInt(soap, "boilerOutMode-Set", -1, &a->_boilerOutMode_Set, "");
	soap_out_unsignedInt(soap, "boilerOutMode-Release", -1, &a->_boilerOutMode_Release, "");
	soap_out_unsignedInt(soap, "boilerDipSwitchMode-Hypocaust", -1, &a->_boilerDipSwitchMode_Hypocaust, "");
	soap_out_unsignedInt(soap, "boilerDipSwitchMode-InnerTemperature", -1, &a->_boilerDipSwitchMode_InnerTemperature, "");
	soap_out_unsignedInt(soap, "boilerRequestedTemperature", -1, &a->boilerRequestedTemperature, "");
	soap_out_unsignedInt(soap, "boilerRequestedTemperatureFrom", -1, &a->boilerRequestedTemperatureFrom, "");
	soap_out_unsignedInt(soap, "boilerRequestedTemperatureTo", -1, &a->boilerRequestedTemperatureTo, "");
	soap_out_unsignedInt(soap, "boilerCurrentTemperature", -1, &a->boilerCurrentTemperature, "");
	soap_out_unsignedInt(soap, "boilerCurrentTemperatureFrom", -1, &a->boilerCurrentTemperatureFrom, "");
	soap_out_unsignedInt(soap, "boilerCurrentTemperatureTo", -1, &a->boilerCurrentTemperatureTo, "");
	soap_out_unsignedInt(soap, "boilerHeatingWaterTemperature", -1, &a->boilerHeatingWaterTemperature, "");
	soap_out_unsignedInt(soap, "boilerHeatingWaterTemperatureFrom", -1, &a->boilerHeatingWaterTemperatureFrom, "");
	soap_out_unsignedInt(soap, "boilerHeatingWaterTemperatureTo", -1, &a->boilerHeatingWaterTemperatureTo, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct xsd_BoilerProperty * SOAP_FMAC4 soap_get_xsd_BoilerProperty(struct soap *soap, struct xsd_BoilerProperty *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd_BoilerProperty(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct xsd_BoilerProperty * SOAP_FMAC4 soap_in_xsd_BoilerProperty(struct soap *soap, const char *tag, struct xsd_BoilerProperty *a, const char *type)
{
	short soap_flag__indivisualBoiler = 1, soap_flag__eachBoiler = 1, soap_flag__boilerPower_Off = 1, soap_flag__boilerPower_On = 1, soap_flag__boilerHeatingPower_Off = 1, soap_flag__boilerHeatingPower_On = 1, soap_flag__boilerOutMode_Set = 1, soap_flag__boilerOutMode_Release = 1, soap_flag__boilerDipSwitchMode_Hypocaust = 1, soap_flag__boilerDipSwitchMode_InnerTemperature = 1, soap_flag_boilerRequestedTemperature = 1, soap_flag_boilerRequestedTemperatureFrom = 7, soap_flag_boilerRequestedTemperatureTo = 7, soap_flag_boilerCurrentTemperature = 1, soap_flag_boilerCurrentTemperatureFrom = 7, soap_flag_boilerCurrentTemperatureTo = 7, soap_flag_boilerHeatingWaterTemperature = 1, soap_flag_boilerHeatingWaterTemperatureFrom = 7, soap_flag_boilerHeatingWaterTemperatureTo = 7;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct xsd_BoilerProperty *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_xsd_BoilerProperty, sizeof(struct xsd_BoilerProperty), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xsd_BoilerProperty(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__indivisualBoiler && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_indivisualBoiler, "xsd:unsignedInt"))
				{	soap_flag__indivisualBoiler--;
					continue;
				}
			if (soap_flag__eachBoiler && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_eachBoiler, "xsd:unsignedInt"))
				{	soap_flag__eachBoiler--;
					continue;
				}
			if (soap_flag__boilerPower_Off && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_boilerPower_Off, "xsd:unsignedInt"))
				{	soap_flag__boilerPower_Off--;
					continue;
				}
			if (soap_flag__boilerPower_On && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_boilerPower_On, "xsd:unsignedInt"))
				{	soap_flag__boilerPower_On--;
					continue;
				}
			if (soap_flag__boilerHeatingPower_Off && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_boilerHeatingPower_Off, "xsd:unsignedInt"))
				{	soap_flag__boilerHeatingPower_Off--;
					continue;
				}
			if (soap_flag__boilerHeatingPower_On && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_boilerHeatingPower_On, "xsd:unsignedInt"))
				{	soap_flag__boilerHeatingPower_On--;
					continue;
				}
			if (soap_flag__boilerOutMode_Set && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_boilerOutMode_Set, "xsd:unsignedInt"))
				{	soap_flag__boilerOutMode_Set--;
					continue;
				}
			if (soap_flag__boilerOutMode_Release && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_boilerOutMode_Release, "xsd:unsignedInt"))
				{	soap_flag__boilerOutMode_Release--;
					continue;
				}
			if (soap_flag__boilerDipSwitchMode_Hypocaust && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_boilerDipSwitchMode_Hypocaust, "xsd:unsignedInt"))
				{	soap_flag__boilerDipSwitchMode_Hypocaust--;
					continue;
				}
			if (soap_flag__boilerDipSwitchMode_InnerTemperature && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_boilerDipSwitchMode_InnerTemperature, "xsd:unsignedInt"))
				{	soap_flag__boilerDipSwitchMode_InnerTemperature--;
					continue;
				}
			if (soap_flag_boilerRequestedTemperature && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "boilerRequestedTemperature", &a->boilerRequestedTemperature, "xsd:unsignedInt"))
				{	soap_flag_boilerRequestedTemperature--;
					continue;
				}
			if (soap_flag_boilerRequestedTemperatureFrom && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "boilerRequestedTemperatureFrom", &a->boilerRequestedTemperatureFrom, "xsd:unsignedInt"))
				{	soap_flag_boilerRequestedTemperatureFrom--;
					continue;
				}
			if (soap_flag_boilerRequestedTemperatureTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "boilerRequestedTemperatureTo", &a->boilerRequestedTemperatureTo, "xsd:unsignedInt"))
				{	soap_flag_boilerRequestedTemperatureTo--;
					continue;
				}
			if (soap_flag_boilerCurrentTemperature && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "boilerCurrentTemperature", &a->boilerCurrentTemperature, "xsd:unsignedInt"))
				{	soap_flag_boilerCurrentTemperature--;
					continue;
				}
			if (soap_flag_boilerCurrentTemperatureFrom && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "boilerCurrentTemperatureFrom", &a->boilerCurrentTemperatureFrom, "xsd:unsignedInt"))
				{	soap_flag_boilerCurrentTemperatureFrom--;
					continue;
				}
			if (soap_flag_boilerCurrentTemperatureTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "boilerCurrentTemperatureTo", &a->boilerCurrentTemperatureTo, "xsd:unsignedInt"))
				{	soap_flag_boilerCurrentTemperatureTo--;
					continue;
				}
			if (soap_flag_boilerHeatingWaterTemperature && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "boilerHeatingWaterTemperature", &a->boilerHeatingWaterTemperature, "xsd:unsignedInt"))
				{	soap_flag_boilerHeatingWaterTemperature--;
					continue;
				}
			if (soap_flag_boilerHeatingWaterTemperatureFrom && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "boilerHeatingWaterTemperatureFrom", &a->boilerHeatingWaterTemperatureFrom, "xsd:unsignedInt"))
				{	soap_flag_boilerHeatingWaterTemperatureFrom--;
					continue;
				}
			if (soap_flag_boilerHeatingWaterTemperatureTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "boilerHeatingWaterTemperatureTo", &a->boilerHeatingWaterTemperatureTo, "xsd:unsignedInt"))
				{	soap_flag_boilerHeatingWaterTemperatureTo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__indivisualBoiler > 0 || soap_flag__eachBoiler > 0 || soap_flag__boilerPower_Off > 0 || soap_flag__boilerPower_On > 0 || soap_flag__boilerHeatingPower_Off > 0 || soap_flag__boilerHeatingPower_On > 0 || soap_flag__boilerOutMode_Set > 0 || soap_flag__boilerOutMode_Release > 0 || soap_flag__boilerDipSwitchMode_Hypocaust > 0 || soap_flag__boilerDipSwitchMode_InnerTemperature > 0 || soap_flag_boilerRequestedTemperature > 0 || soap_flag_boilerRequestedTemperatureFrom > 6 || soap_flag_boilerRequestedTemperatureTo > 6 || soap_flag_boilerCurrentTemperature > 0 || soap_flag_boilerCurrentTemperatureFrom > 6 || soap_flag_boilerCurrentTemperatureTo > 6 || soap_flag_boilerHeatingWaterTemperature > 0 || soap_flag_boilerHeatingWaterTemperatureFrom > 6 || soap_flag_boilerHeatingWaterTemperatureTo > 6))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xsd_BoilerProperty *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_xsd_BoilerProperty, 0, sizeof(struct xsd_BoilerProperty), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct xsd_BoilerProperty * SOAP_FMAC6 soap_new_xsd_BoilerProperty(struct soap *soap, int n)
{	return soap_instantiate_xsd_BoilerProperty(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd_BoilerProperty(struct soap *soap, struct xsd_BoilerProperty *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct xsd_BoilerProperty * SOAP_FMAC4 soap_instantiate_xsd_BoilerProperty(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd_BoilerProperty(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_xsd_BoilerProperty, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct xsd_BoilerProperty;
		if (size)
			*size = sizeof(struct xsd_BoilerProperty);
	}
	else
	{	cp->ptr = (void*)new struct xsd_BoilerProperty[n];
		if (size)
			*size = n * sizeof(struct xsd_BoilerProperty);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct xsd_BoilerProperty*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd_BoilerProperty(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct xsd_BoilerProperty %p -> %p\n", q, p));
	*(struct xsd_BoilerProperty*)p = *(struct xsd_BoilerProperty*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__deviceCategoryEvent(struct soap *soap, const struct ns__deviceCategoryEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.soap_serialize(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__deviceCategoryEvent(struct soap *soap, struct ns__deviceCategoryEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.ns__deviceCategory::soap_default(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__deviceCategoryEvent(struct soap *soap, const struct ns__deviceCategoryEvent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__deviceCategoryEvent);
	if (soap_out_ns__deviceCategoryEvent(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__deviceCategoryEvent(struct soap *soap, const char *tag, int id, const struct ns__deviceCategoryEvent *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__deviceCategoryEvent), type);
	a->in.soap_out(soap, "in", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__deviceCategoryEvent * SOAP_FMAC4 soap_get_ns__deviceCategoryEvent(struct soap *soap, struct ns__deviceCategoryEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__deviceCategoryEvent(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__deviceCategoryEvent * SOAP_FMAC4 soap_in_ns__deviceCategoryEvent(struct soap *soap, const char *tag, struct ns__deviceCategoryEvent *a, const char *type)
{
	short soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__deviceCategoryEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__deviceCategoryEvent, sizeof(struct ns__deviceCategoryEvent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__deviceCategoryEvent(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && soap->error == SOAP_TAG_MISMATCH)
				if (a->in.soap_in(soap, "in", "ns:deviceCategory"))
				{	soap_flag_in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__deviceCategoryEvent *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__deviceCategoryEvent, 0, sizeof(struct ns__deviceCategoryEvent), 0, soap_copy_ns__deviceCategoryEvent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__deviceCategoryEvent * SOAP_FMAC6 soap_new_ns__deviceCategoryEvent(struct soap *soap, int n)
{	return soap_instantiate_ns__deviceCategoryEvent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__deviceCategoryEvent(struct soap *soap, struct ns__deviceCategoryEvent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__deviceCategoryEvent * SOAP_FMAC4 soap_instantiate_ns__deviceCategoryEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__deviceCategoryEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__deviceCategoryEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__deviceCategoryEvent;
		if (size)
			*size = sizeof(struct ns__deviceCategoryEvent);
	}
	else
	{	cp->ptr = (void*)new struct ns__deviceCategoryEvent[n];
		if (size)
			*size = n * sizeof(struct ns__deviceCategoryEvent);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__deviceCategoryEvent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__deviceCategoryEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__deviceCategoryEvent %p -> %p\n", q, p));
	*(struct ns__deviceCategoryEvent*)p = *(struct ns__deviceCategoryEvent*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__deviceCategoryEventResponse(struct soap *soap, const struct ns__deviceCategoryEventResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__deviceCategoryEventResponse(struct soap *soap, struct ns__deviceCategoryEventResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->out = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__deviceCategoryEventResponse(struct soap *soap, const struct ns__deviceCategoryEventResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__deviceCategoryEventResponse);
	if (soap_out_ns__deviceCategoryEventResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__deviceCategoryEventResponse(struct soap *soap, const char *tag, int id, const struct ns__deviceCategoryEventResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__deviceCategoryEventResponse), type);
	if (a->out)
		soap_element_result(soap, "out");
	soap_out_PointerToint(soap, "out", -1, &a->out, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__deviceCategoryEventResponse * SOAP_FMAC4 soap_get_ns__deviceCategoryEventResponse(struct soap *soap, struct ns__deviceCategoryEventResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__deviceCategoryEventResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__deviceCategoryEventResponse * SOAP_FMAC4 soap_in_ns__deviceCategoryEventResponse(struct soap *soap, const char *tag, struct ns__deviceCategoryEventResponse *a, const char *type)
{
	short soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__deviceCategoryEventResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__deviceCategoryEventResponse, sizeof(struct ns__deviceCategoryEventResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__deviceCategoryEventResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "out", &a->out, "xsd:int"))
				{	soap_flag_out--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__deviceCategoryEventResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__deviceCategoryEventResponse, 0, sizeof(struct ns__deviceCategoryEventResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__deviceCategoryEventResponse * SOAP_FMAC6 soap_new_ns__deviceCategoryEventResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__deviceCategoryEventResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__deviceCategoryEventResponse(struct soap *soap, struct ns__deviceCategoryEventResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__deviceCategoryEventResponse * SOAP_FMAC4 soap_instantiate_ns__deviceCategoryEventResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__deviceCategoryEventResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__deviceCategoryEventResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__deviceCategoryEventResponse;
		if (size)
			*size = sizeof(struct ns__deviceCategoryEventResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__deviceCategoryEventResponse[n];
		if (size)
			*size = n * sizeof(struct ns__deviceCategoryEventResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__deviceCategoryEventResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__deviceCategoryEventResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__deviceCategoryEventResponse %p -> %p\n", q, p));
	*(struct ns__deviceCategoryEventResponse*)p = *(struct ns__deviceCategoryEventResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__setDeviceCategory(struct soap *soap, const struct ns__setDeviceCategory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.soap_serialize(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__setDeviceCategory(struct soap *soap, struct ns__setDeviceCategory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.ns__deviceCategory::soap_default(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__setDeviceCategory(struct soap *soap, const struct ns__setDeviceCategory *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__setDeviceCategory);
	if (soap_out_ns__setDeviceCategory(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__setDeviceCategory(struct soap *soap, const char *tag, int id, const struct ns__setDeviceCategory *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__setDeviceCategory), type);
	a->in.soap_out(soap, "in", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__setDeviceCategory * SOAP_FMAC4 soap_get_ns__setDeviceCategory(struct soap *soap, struct ns__setDeviceCategory *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__setDeviceCategory(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__setDeviceCategory * SOAP_FMAC4 soap_in_ns__setDeviceCategory(struct soap *soap, const char *tag, struct ns__setDeviceCategory *a, const char *type)
{
	short soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__setDeviceCategory *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__setDeviceCategory, sizeof(struct ns__setDeviceCategory), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__setDeviceCategory(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && soap->error == SOAP_TAG_MISMATCH)
				if (a->in.soap_in(soap, "in", "ns:deviceCategory"))
				{	soap_flag_in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__setDeviceCategory *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__setDeviceCategory, 0, sizeof(struct ns__setDeviceCategory), 0, soap_copy_ns__setDeviceCategory);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__setDeviceCategory * SOAP_FMAC6 soap_new_ns__setDeviceCategory(struct soap *soap, int n)
{	return soap_instantiate_ns__setDeviceCategory(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__setDeviceCategory(struct soap *soap, struct ns__setDeviceCategory *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__setDeviceCategory * SOAP_FMAC4 soap_instantiate_ns__setDeviceCategory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__setDeviceCategory(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__setDeviceCategory, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__setDeviceCategory;
		if (size)
			*size = sizeof(struct ns__setDeviceCategory);
	}
	else
	{	cp->ptr = (void*)new struct ns__setDeviceCategory[n];
		if (size)
			*size = n * sizeof(struct ns__setDeviceCategory);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__setDeviceCategory*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__setDeviceCategory(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__setDeviceCategory %p -> %p\n", q, p));
	*(struct ns__setDeviceCategory*)p = *(struct ns__setDeviceCategory*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getDeviceCategory(struct soap *soap, const struct ns__getDeviceCategory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.soap_serialize(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getDeviceCategory(struct soap *soap, struct ns__getDeviceCategory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in.ns__deviceCategory::soap_default(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getDeviceCategory(struct soap *soap, const struct ns__getDeviceCategory *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategory);
	if (soap_out_ns__getDeviceCategory(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getDeviceCategory(struct soap *soap, const char *tag, int id, const struct ns__getDeviceCategory *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategory), type);
	a->in.soap_out(soap, "in", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getDeviceCategory * SOAP_FMAC4 soap_get_ns__getDeviceCategory(struct soap *soap, struct ns__getDeviceCategory *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getDeviceCategory(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getDeviceCategory * SOAP_FMAC4 soap_in_ns__getDeviceCategory(struct soap *soap, const char *tag, struct ns__getDeviceCategory *a, const char *type)
{
	short soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getDeviceCategory *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategory, sizeof(struct ns__getDeviceCategory), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__getDeviceCategory(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && soap->error == SOAP_TAG_MISMATCH)
				if (a->in.soap_in(soap, "in", "ns:deviceCategory"))
				{	soap_flag_in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_in > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getDeviceCategory *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategory, 0, sizeof(struct ns__getDeviceCategory), 0, soap_copy_ns__getDeviceCategory);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getDeviceCategory * SOAP_FMAC6 soap_new_ns__getDeviceCategory(struct soap *soap, int n)
{	return soap_instantiate_ns__getDeviceCategory(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getDeviceCategory(struct soap *soap, struct ns__getDeviceCategory *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getDeviceCategory * SOAP_FMAC4 soap_instantiate_ns__getDeviceCategory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getDeviceCategory(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategory, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getDeviceCategory;
		if (size)
			*size = sizeof(struct ns__getDeviceCategory);
	}
	else
	{	cp->ptr = (void*)new struct ns__getDeviceCategory[n];
		if (size)
			*size = n * sizeof(struct ns__getDeviceCategory);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getDeviceCategory*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getDeviceCategory(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getDeviceCategory %p -> %p\n", q, p));
	*(struct ns__getDeviceCategory*)p = *(struct ns__getDeviceCategory*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getDeviceCategoryItem(struct soap *soap, const struct ns__getDeviceCategoryItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->order, SOAP_TYPE_cmxDeviceService_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getDeviceCategoryItem(struct soap *soap, struct ns__getDeviceCategoryItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->order);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getDeviceCategoryItem(struct soap *soap, const struct ns__getDeviceCategoryItem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryItem);
	if (soap_out_ns__getDeviceCategoryItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getDeviceCategoryItem(struct soap *soap, const char *tag, int id, const struct ns__getDeviceCategoryItem *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryItem), type);
	soap_out_int(soap, "order", -1, &a->order, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getDeviceCategoryItem * SOAP_FMAC4 soap_get_ns__getDeviceCategoryItem(struct soap *soap, struct ns__getDeviceCategoryItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getDeviceCategoryItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getDeviceCategoryItem * SOAP_FMAC4 soap_in_ns__getDeviceCategoryItem(struct soap *soap, const char *tag, struct ns__getDeviceCategoryItem *a, const char *type)
{
	short soap_flag_order = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getDeviceCategoryItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryItem, sizeof(struct ns__getDeviceCategoryItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getDeviceCategoryItem(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_order && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "order", &a->order, "xsd:int"))
				{	soap_flag_order--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_order > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getDeviceCategoryItem *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryItem, 0, sizeof(struct ns__getDeviceCategoryItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getDeviceCategoryItem * SOAP_FMAC6 soap_new_ns__getDeviceCategoryItem(struct soap *soap, int n)
{	return soap_instantiate_ns__getDeviceCategoryItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getDeviceCategoryItem(struct soap *soap, struct ns__getDeviceCategoryItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getDeviceCategoryItem * SOAP_FMAC4 soap_instantiate_ns__getDeviceCategoryItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getDeviceCategoryItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getDeviceCategoryItem;
		if (size)
			*size = sizeof(struct ns__getDeviceCategoryItem);
	}
	else
	{	cp->ptr = (void*)new struct ns__getDeviceCategoryItem[n];
		if (size)
			*size = n * sizeof(struct ns__getDeviceCategoryItem);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getDeviceCategoryItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getDeviceCategoryItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getDeviceCategoryItem %p -> %p\n", q, p));
	*(struct ns__getDeviceCategoryItem*)p = *(struct ns__getDeviceCategoryItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getDeviceCategoryCount(struct soap *soap, const struct ns__getDeviceCategoryCount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getDeviceCategoryCount(struct soap *soap, struct ns__getDeviceCategoryCount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient _ skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getDeviceCategoryCount(struct soap *soap, const struct ns__getDeviceCategoryCount *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryCount);
	if (soap_out_ns__getDeviceCategoryCount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getDeviceCategoryCount(struct soap *soap, const char *tag, int id, const struct ns__getDeviceCategoryCount *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryCount), type);
	/* transient _ skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getDeviceCategoryCount * SOAP_FMAC4 soap_get_ns__getDeviceCategoryCount(struct soap *soap, struct ns__getDeviceCategoryCount *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getDeviceCategoryCount(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getDeviceCategoryCount * SOAP_FMAC4 soap_in_ns__getDeviceCategoryCount(struct soap *soap, const char *tag, struct ns__getDeviceCategoryCount *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getDeviceCategoryCount *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryCount, sizeof(struct ns__getDeviceCategoryCount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getDeviceCategoryCount(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient _ skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getDeviceCategoryCount *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryCount, 0, sizeof(struct ns__getDeviceCategoryCount), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getDeviceCategoryCount * SOAP_FMAC6 soap_new_ns__getDeviceCategoryCount(struct soap *soap, int n)
{	return soap_instantiate_ns__getDeviceCategoryCount(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getDeviceCategoryCount(struct soap *soap, struct ns__getDeviceCategoryCount *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getDeviceCategoryCount * SOAP_FMAC4 soap_instantiate_ns__getDeviceCategoryCount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getDeviceCategoryCount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryCount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getDeviceCategoryCount;
		if (size)
			*size = sizeof(struct ns__getDeviceCategoryCount);
	}
	else
	{	cp->ptr = (void*)new struct ns__getDeviceCategoryCount[n];
		if (size)
			*size = n * sizeof(struct ns__getDeviceCategoryCount);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getDeviceCategoryCount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getDeviceCategoryCount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getDeviceCategoryCount %p -> %p\n", q, p));
	*(struct ns__getDeviceCategoryCount*)p = *(struct ns__getDeviceCategoryCount*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getDeviceCategoryCountResponse(struct soap *soap, const struct ns__getDeviceCategoryCountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->out);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getDeviceCategoryCountResponse(struct soap *soap, struct ns__getDeviceCategoryCountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->out = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getDeviceCategoryCountResponse(struct soap *soap, const struct ns__getDeviceCategoryCountResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryCountResponse);
	if (soap_out_ns__getDeviceCategoryCountResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getDeviceCategoryCountResponse(struct soap *soap, const char *tag, int id, const struct ns__getDeviceCategoryCountResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryCountResponse), type);
	if (a->out)
		soap_element_result(soap, "out");
	soap_out_PointerToint(soap, "out", -1, &a->out, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__getDeviceCategoryCountResponse * SOAP_FMAC4 soap_get_ns__getDeviceCategoryCountResponse(struct soap *soap, struct ns__getDeviceCategoryCountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getDeviceCategoryCountResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__getDeviceCategoryCountResponse * SOAP_FMAC4 soap_in_ns__getDeviceCategoryCountResponse(struct soap *soap, const char *tag, struct ns__getDeviceCategoryCountResponse *a, const char *type)
{
	short soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__getDeviceCategoryCountResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryCountResponse, sizeof(struct ns__getDeviceCategoryCountResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getDeviceCategoryCountResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "out", &a->out, "xsd:int"))
				{	soap_flag_out--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getDeviceCategoryCountResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryCountResponse, 0, sizeof(struct ns__getDeviceCategoryCountResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns__getDeviceCategoryCountResponse * SOAP_FMAC6 soap_new_ns__getDeviceCategoryCountResponse(struct soap *soap, int n)
{	return soap_instantiate_ns__getDeviceCategoryCountResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns__getDeviceCategoryCountResponse(struct soap *soap, struct ns__getDeviceCategoryCountResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns__getDeviceCategoryCountResponse * SOAP_FMAC4 soap_instantiate_ns__getDeviceCategoryCountResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getDeviceCategoryCountResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryCountResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns__getDeviceCategoryCountResponse;
		if (size)
			*size = sizeof(struct ns__getDeviceCategoryCountResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns__getDeviceCategoryCountResponse[n];
		if (size)
			*size = n * sizeof(struct ns__getDeviceCategoryCountResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getDeviceCategoryCountResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getDeviceCategoryCountResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getDeviceCategoryCountResponse %p -> %p\n", q, p));
	*(struct ns__getDeviceCategoryCountResponse*)p = *(struct ns__getDeviceCategoryCountResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd_devCategory(struct soap *soap, const struct xsd_devCategory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd_devCategory(struct soap *soap, struct xsd_devCategory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->_boiler);
	soap_default_unsignedInt(soap, &a->_light);
	soap_default_unsignedInt(soap, &a->_gasValve);
	soap_default_unsignedInt(soap, &a->_doorLock);
	soap_default_unsignedInt(soap, &a->_outlet);
	soap_default_unsignedInt(soap, &a->_curtain);
	soap_default_unsignedInt(soap, &a->_aroma);
	soap_default_unsignedInt(soap, &a->_airCleaner);
	soap_default_unsignedInt(soap, &a->_bide);
	soap_default_unsignedInt(soap, &a->_rf);
	soap_default_unsignedInt(soap, &a->_plc);
	soap_default_unsignedInt(soap, &a->_bundleLight);
	soap_default_unsignedInt(soap, &a->_systemAircon);
	soap_default_unsignedInt(soap, &a->_fanSystem);
	soap_default_unsignedInt(soap, &a->_aircon);
	soap_default_unsignedInt(soap, &a->_washMachine);
	soap_default_unsignedInt(soap, &a->_dishWashMachine);
	soap_default_unsignedInt(soap, &a->_gasOven);
	soap_default_unsignedInt(soap, &a->_microwave);
	soap_default_unsignedInt(soap, &a->_television);
	soap_default_unsignedInt(soap, &a->_audio);
	soap_default_unsignedInt(soap, &a->_vtr);
	soap_default_unsignedInt(soap, &a->_dvd);
	soap_default_unsignedInt(soap, &a->_refrigerator);
	soap_default_unsignedInt(soap, &a->_kRefrigeator);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd_devCategory(struct soap *soap, const struct xsd_devCategory *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_xsd_devCategory);
	if (soap_out_xsd_devCategory(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd_devCategory(struct soap *soap, const char *tag, int id, const struct xsd_devCategory *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cmxDeviceService_xsd_devCategory), type);
	soap_out_unsignedInt(soap, "boiler", -1, &a->_boiler, "");
	soap_out_unsignedInt(soap, "light", -1, &a->_light, "");
	soap_out_unsignedInt(soap, "gasValve", -1, &a->_gasValve, "");
	soap_out_unsignedInt(soap, "doorLock", -1, &a->_doorLock, "");
	soap_out_unsignedInt(soap, "outlet", -1, &a->_outlet, "");
	soap_out_unsignedInt(soap, "curtain", -1, &a->_curtain, "");
	soap_out_unsignedInt(soap, "aroma", -1, &a->_aroma, "");
	soap_out_unsignedInt(soap, "airCleaner", -1, &a->_airCleaner, "");
	soap_out_unsignedInt(soap, "bide", -1, &a->_bide, "");
	soap_out_unsignedInt(soap, "rf", -1, &a->_rf, "");
	soap_out_unsignedInt(soap, "plc", -1, &a->_plc, "");
	soap_out_unsignedInt(soap, "bundleLight", -1, &a->_bundleLight, "");
	soap_out_unsignedInt(soap, "systemAircon", -1, &a->_systemAircon, "");
	soap_out_unsignedInt(soap, "fanSystem", -1, &a->_fanSystem, "");
	soap_out_unsignedInt(soap, "aircon", -1, &a->_aircon, "");
	soap_out_unsignedInt(soap, "washMachine", -1, &a->_washMachine, "");
	soap_out_unsignedInt(soap, "dishWashMachine", -1, &a->_dishWashMachine, "");
	soap_out_unsignedInt(soap, "gasOven", -1, &a->_gasOven, "");
	soap_out_unsignedInt(soap, "microwave", -1, &a->_microwave, "");
	soap_out_unsignedInt(soap, "television", -1, &a->_television, "");
	soap_out_unsignedInt(soap, "audio", -1, &a->_audio, "");
	soap_out_unsignedInt(soap, "vtr", -1, &a->_vtr, "");
	soap_out_unsignedInt(soap, "dvd", -1, &a->_dvd, "");
	soap_out_unsignedInt(soap, "refrigerator", -1, &a->_refrigerator, "");
	soap_out_unsignedInt(soap, "kRefrigeator", -1, &a->_kRefrigeator, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct xsd_devCategory * SOAP_FMAC4 soap_get_xsd_devCategory(struct soap *soap, struct xsd_devCategory *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd_devCategory(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct xsd_devCategory * SOAP_FMAC4 soap_in_xsd_devCategory(struct soap *soap, const char *tag, struct xsd_devCategory *a, const char *type)
{
	short soap_flag__boiler = 1, soap_flag__light = 1, soap_flag__gasValve = 1, soap_flag__doorLock = 1, soap_flag__outlet = 1, soap_flag__curtain = 1, soap_flag__aroma = 1, soap_flag__airCleaner = 1, soap_flag__bide = 1, soap_flag__rf = 1, soap_flag__plc = 1, soap_flag__bundleLight = 1, soap_flag__systemAircon = 1, soap_flag__fanSystem = 1, soap_flag__aircon = 1, soap_flag__washMachine = 1, soap_flag__dishWashMachine = 1, soap_flag__gasOven = 1, soap_flag__microwave = 1, soap_flag__television = 1, soap_flag__audio = 1, soap_flag__vtr = 1, soap_flag__dvd = 1, soap_flag__refrigerator = 1, soap_flag__kRefrigeator = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct xsd_devCategory *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_xsd_devCategory, sizeof(struct xsd_devCategory), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xsd_devCategory(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__boiler && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_boiler, "xsd:unsignedInt"))
				{	soap_flag__boiler--;
					continue;
				}
			if (soap_flag__light && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_light, "xsd:unsignedInt"))
				{	soap_flag__light--;
					continue;
				}
			if (soap_flag__gasValve && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_gasValve, "xsd:unsignedInt"))
				{	soap_flag__gasValve--;
					continue;
				}
			if (soap_flag__doorLock && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_doorLock, "xsd:unsignedInt"))
				{	soap_flag__doorLock--;
					continue;
				}
			if (soap_flag__outlet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_outlet, "xsd:unsignedInt"))
				{	soap_flag__outlet--;
					continue;
				}
			if (soap_flag__curtain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_curtain, "xsd:unsignedInt"))
				{	soap_flag__curtain--;
					continue;
				}
			if (soap_flag__aroma && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_aroma, "xsd:unsignedInt"))
				{	soap_flag__aroma--;
					continue;
				}
			if (soap_flag__airCleaner && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_airCleaner, "xsd:unsignedInt"))
				{	soap_flag__airCleaner--;
					continue;
				}
			if (soap_flag__bide && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_bide, "xsd:unsignedInt"))
				{	soap_flag__bide--;
					continue;
				}
			if (soap_flag__rf && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_rf, "xsd:unsignedInt"))
				{	soap_flag__rf--;
					continue;
				}
			if (soap_flag__plc && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_plc, "xsd:unsignedInt"))
				{	soap_flag__plc--;
					continue;
				}
			if (soap_flag__bundleLight && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_bundleLight, "xsd:unsignedInt"))
				{	soap_flag__bundleLight--;
					continue;
				}
			if (soap_flag__systemAircon && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_systemAircon, "xsd:unsignedInt"))
				{	soap_flag__systemAircon--;
					continue;
				}
			if (soap_flag__fanSystem && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_fanSystem, "xsd:unsignedInt"))
				{	soap_flag__fanSystem--;
					continue;
				}
			if (soap_flag__aircon && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_aircon, "xsd:unsignedInt"))
				{	soap_flag__aircon--;
					continue;
				}
			if (soap_flag__washMachine && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_washMachine, "xsd:unsignedInt"))
				{	soap_flag__washMachine--;
					continue;
				}
			if (soap_flag__dishWashMachine && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_dishWashMachine, "xsd:unsignedInt"))
				{	soap_flag__dishWashMachine--;
					continue;
				}
			if (soap_flag__gasOven && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_gasOven, "xsd:unsignedInt"))
				{	soap_flag__gasOven--;
					continue;
				}
			if (soap_flag__microwave && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_microwave, "xsd:unsignedInt"))
				{	soap_flag__microwave--;
					continue;
				}
			if (soap_flag__television && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_television, "xsd:unsignedInt"))
				{	soap_flag__television--;
					continue;
				}
			if (soap_flag__audio && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_audio, "xsd:unsignedInt"))
				{	soap_flag__audio--;
					continue;
				}
			if (soap_flag__vtr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_vtr, "xsd:unsignedInt"))
				{	soap_flag__vtr--;
					continue;
				}
			if (soap_flag__dvd && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_dvd, "xsd:unsignedInt"))
				{	soap_flag__dvd--;
					continue;
				}
			if (soap_flag__refrigerator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_refrigerator, "xsd:unsignedInt"))
				{	soap_flag__refrigerator--;
					continue;
				}
			if (soap_flag__kRefrigeator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, NULL, &a->_kRefrigeator, "xsd:unsignedInt"))
				{	soap_flag__kRefrigeator--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__boiler > 0 || soap_flag__light > 0 || soap_flag__gasValve > 0 || soap_flag__doorLock > 0 || soap_flag__outlet > 0 || soap_flag__curtain > 0 || soap_flag__aroma > 0 || soap_flag__airCleaner > 0 || soap_flag__bide > 0 || soap_flag__rf > 0 || soap_flag__plc > 0 || soap_flag__bundleLight > 0 || soap_flag__systemAircon > 0 || soap_flag__fanSystem > 0 || soap_flag__aircon > 0 || soap_flag__washMachine > 0 || soap_flag__dishWashMachine > 0 || soap_flag__gasOven > 0 || soap_flag__microwave > 0 || soap_flag__television > 0 || soap_flag__audio > 0 || soap_flag__vtr > 0 || soap_flag__dvd > 0 || soap_flag__refrigerator > 0 || soap_flag__kRefrigeator > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xsd_devCategory *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_xsd_devCategory, 0, sizeof(struct xsd_devCategory), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct xsd_devCategory * SOAP_FMAC6 soap_new_xsd_devCategory(struct soap *soap, int n)
{	return soap_instantiate_xsd_devCategory(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd_devCategory(struct soap *soap, struct xsd_devCategory *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct xsd_devCategory * SOAP_FMAC4 soap_instantiate_xsd_devCategory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd_devCategory(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_xsd_devCategory, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct xsd_devCategory;
		if (size)
			*size = sizeof(struct xsd_devCategory);
	}
	else
	{	cp->ptr = (void*)new struct xsd_devCategory[n];
		if (size)
			*size = n * sizeof(struct xsd_devCategory);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct xsd_devCategory*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd_devCategory(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct xsd_devCategory %p -> %p\n", q, p));
	*(struct xsd_devCategory*)p = *(struct xsd_devCategory*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__base64Binary(struct soap *soap, struct xsd__base64Binary const*a)
{
	if (a->__ptr)
		soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_cmxDeviceService_xsd__base64Binary);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__base64Binary(struct soap *soap, struct xsd__base64Binary *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__base64Binary(struct soap *soap, const struct xsd__base64Binary *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_cmxDeviceService_xsd__base64Binary);
	if (soap_out_xsd__base64Binary(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const struct xsd__base64Binary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_cmxDeviceService_xsd__base64Binary);
	if (id < 0)
		return soap->error;
	soap_element_begin_out(soap, tag, id, type);
	soap_putbase64(soap, a->__ptr, a->__size);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, struct xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, struct xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct xsd__base64Binary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cmxDeviceService_xsd__base64Binary, sizeof(struct xsd__base64Binary), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xsd__base64Binary(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xsd__base64Binary *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_cmxDeviceService_xsd__base64Binary, 0, sizeof(struct xsd__base64Binary), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct xsd__base64Binary * SOAP_FMAC6 soap_new_xsd__base64Binary(struct soap *soap, int n)
{	return soap_instantiate_xsd__base64Binary(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__base64Binary(struct soap *soap, struct xsd__base64Binary *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct xsd__base64Binary * SOAP_FMAC4 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cmxDeviceService_xsd__base64Binary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct xsd__base64Binary;
		if (size)
			*size = sizeof(struct xsd__base64Binary);
	}
	else
	{	cp->ptr = (void*)new struct xsd__base64Binary[n];
		if (size)
			*size = n * sizeof(struct xsd__base64Binary);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct xsd__base64Binary*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct xsd__base64Binary %p -> %p\n", q, p));
	*(struct xsd__base64Binary*)p = *(struct xsd__base64Binary*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__setSensorEmerResponse(struct soap *soap, ns__setSensorEmerResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__setSensorEmerResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__setSensorEmerResponse(struct soap *soap, ns__setSensorEmerResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__setSensorEmerResponse);
	if (soap_out_PointerTons__setSensorEmerResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__setSensorEmerResponse(struct soap *soap, const char *tag, int id, ns__setSensorEmerResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__setSensorEmerResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__setSensorEmerResponse ** SOAP_FMAC4 soap_get_PointerTons__setSensorEmerResponse(struct soap *soap, ns__setSensorEmerResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__setSensorEmerResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__setSensorEmerResponse ** SOAP_FMAC4 soap_in_PointerTons__setSensorEmerResponse(struct soap *soap, const char *tag, ns__setSensorEmerResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__setSensorEmerResponse **)soap_malloc(soap, sizeof(ns__setSensorEmerResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__setSensorEmerResponse *)soap_instantiate_ns__setSensorEmerResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__setSensorEmerResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__setSensorEmerResponse, sizeof(ns__setSensorEmerResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__getSensorEmerResponse(struct soap *soap, ns__getSensorEmerResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__getSensorEmerResponse(struct soap *soap, ns__getSensorEmerResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__getSensorEmerResponse);
	if (soap_out_PointerTons__getSensorEmerResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__getSensorEmerResponse(struct soap *soap, const char *tag, int id, ns__getSensorEmerResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__getSensorEmerResponse ** SOAP_FMAC4 soap_get_PointerTons__getSensorEmerResponse(struct soap *soap, ns__getSensorEmerResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__getSensorEmerResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__getSensorEmerResponse ** SOAP_FMAC4 soap_in_PointerTons__getSensorEmerResponse(struct soap *soap, const char *tag, ns__getSensorEmerResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__getSensorEmerResponse **)soap_malloc(soap, sizeof(ns__getSensorEmerResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__getSensorEmerResponse *)soap_instantiate_ns__getSensorEmerResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__getSensorEmerResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerResponse, sizeof(ns__getSensorEmerResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__getSensorEmerItemResponse(struct soap *soap, ns__getSensorEmerItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerItemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__getSensorEmerItemResponse(struct soap *soap, ns__getSensorEmerItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__getSensorEmerItemResponse);
	if (soap_out_PointerTons__getSensorEmerItemResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__getSensorEmerItemResponse(struct soap *soap, const char *tag, int id, ns__getSensorEmerItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__getSensorEmerItemResponse ** SOAP_FMAC4 soap_get_PointerTons__getSensorEmerItemResponse(struct soap *soap, ns__getSensorEmerItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__getSensorEmerItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__getSensorEmerItemResponse ** SOAP_FMAC4 soap_in_PointerTons__getSensorEmerItemResponse(struct soap *soap, const char *tag, ns__getSensorEmerItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__getSensorEmerItemResponse **)soap_malloc(soap, sizeof(ns__getSensorEmerItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__getSensorEmerItemResponse *)soap_instantiate_ns__getSensorEmerItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__getSensorEmerItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__getSensorEmerItemResponse, sizeof(ns__getSensorEmerItemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__setFanSystemResponse(struct soap *soap, ns__setFanSystemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__setFanSystemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__setFanSystemResponse(struct soap *soap, ns__setFanSystemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__setFanSystemResponse);
	if (soap_out_PointerTons__setFanSystemResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__setFanSystemResponse(struct soap *soap, const char *tag, int id, ns__setFanSystemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__setFanSystemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__setFanSystemResponse ** SOAP_FMAC4 soap_get_PointerTons__setFanSystemResponse(struct soap *soap, ns__setFanSystemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__setFanSystemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__setFanSystemResponse ** SOAP_FMAC4 soap_in_PointerTons__setFanSystemResponse(struct soap *soap, const char *tag, ns__setFanSystemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__setFanSystemResponse **)soap_malloc(soap, sizeof(ns__setFanSystemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__setFanSystemResponse *)soap_instantiate_ns__setFanSystemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__setFanSystemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__setFanSystemResponse, sizeof(ns__setFanSystemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__getFanSystemResponse(struct soap *soap, ns__getFanSystemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__getFanSystemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__getFanSystemResponse(struct soap *soap, ns__getFanSystemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__getFanSystemResponse);
	if (soap_out_PointerTons__getFanSystemResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__getFanSystemResponse(struct soap *soap, const char *tag, int id, ns__getFanSystemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__getFanSystemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__getFanSystemResponse ** SOAP_FMAC4 soap_get_PointerTons__getFanSystemResponse(struct soap *soap, ns__getFanSystemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__getFanSystemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__getFanSystemResponse ** SOAP_FMAC4 soap_in_PointerTons__getFanSystemResponse(struct soap *soap, const char *tag, ns__getFanSystemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__getFanSystemResponse **)soap_malloc(soap, sizeof(ns__getFanSystemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__getFanSystemResponse *)soap_instantiate_ns__getFanSystemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__getFanSystemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__getFanSystemResponse, sizeof(ns__getFanSystemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__getFanSystemItemResponse(struct soap *soap, ns__getFanSystemItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__getFanSystemItemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__getFanSystemItemResponse(struct soap *soap, ns__getFanSystemItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__getFanSystemItemResponse);
	if (soap_out_PointerTons__getFanSystemItemResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__getFanSystemItemResponse(struct soap *soap, const char *tag, int id, ns__getFanSystemItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__getFanSystemItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__getFanSystemItemResponse ** SOAP_FMAC4 soap_get_PointerTons__getFanSystemItemResponse(struct soap *soap, ns__getFanSystemItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__getFanSystemItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__getFanSystemItemResponse ** SOAP_FMAC4 soap_in_PointerTons__getFanSystemItemResponse(struct soap *soap, const char *tag, ns__getFanSystemItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__getFanSystemItemResponse **)soap_malloc(soap, sizeof(ns__getFanSystemItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__getFanSystemItemResponse *)soap_instantiate_ns__getFanSystemItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__getFanSystemItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__getFanSystemItemResponse, sizeof(ns__getFanSystemItemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__getFanSystemPropertyItemResponse(struct soap *soap, ns__getFanSystemPropertyItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__getFanSystemPropertyItemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__getFanSystemPropertyItemResponse(struct soap *soap, ns__getFanSystemPropertyItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__getFanSystemPropertyItemResponse);
	if (soap_out_PointerTons__getFanSystemPropertyItemResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__getFanSystemPropertyItemResponse(struct soap *soap, const char *tag, int id, ns__getFanSystemPropertyItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__getFanSystemPropertyItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__getFanSystemPropertyItemResponse ** SOAP_FMAC4 soap_get_PointerTons__getFanSystemPropertyItemResponse(struct soap *soap, ns__getFanSystemPropertyItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__getFanSystemPropertyItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__getFanSystemPropertyItemResponse ** SOAP_FMAC4 soap_in_PointerTons__getFanSystemPropertyItemResponse(struct soap *soap, const char *tag, ns__getFanSystemPropertyItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__getFanSystemPropertyItemResponse **)soap_malloc(soap, sizeof(ns__getFanSystemPropertyItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__getFanSystemPropertyItemResponse *)soap_instantiate_ns__getFanSystemPropertyItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__getFanSystemPropertyItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__getFanSystemPropertyItemResponse, sizeof(ns__getFanSystemPropertyItemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__setSystemAirconResponse(struct soap *soap, ns__setSystemAirconResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__setSystemAirconResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__setSystemAirconResponse(struct soap *soap, ns__setSystemAirconResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__setSystemAirconResponse);
	if (soap_out_PointerTons__setSystemAirconResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__setSystemAirconResponse(struct soap *soap, const char *tag, int id, ns__setSystemAirconResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__setSystemAirconResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__setSystemAirconResponse ** SOAP_FMAC4 soap_get_PointerTons__setSystemAirconResponse(struct soap *soap, ns__setSystemAirconResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__setSystemAirconResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__setSystemAirconResponse ** SOAP_FMAC4 soap_in_PointerTons__setSystemAirconResponse(struct soap *soap, const char *tag, ns__setSystemAirconResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__setSystemAirconResponse **)soap_malloc(soap, sizeof(ns__setSystemAirconResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__setSystemAirconResponse *)soap_instantiate_ns__setSystemAirconResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__setSystemAirconResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__setSystemAirconResponse, sizeof(ns__setSystemAirconResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__getSystemAirconResponse(struct soap *soap, ns__getSystemAirconResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__getSystemAirconResponse(struct soap *soap, ns__getSystemAirconResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__getSystemAirconResponse);
	if (soap_out_PointerTons__getSystemAirconResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__getSystemAirconResponse(struct soap *soap, const char *tag, int id, ns__getSystemAirconResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__getSystemAirconResponse ** SOAP_FMAC4 soap_get_PointerTons__getSystemAirconResponse(struct soap *soap, ns__getSystemAirconResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__getSystemAirconResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__getSystemAirconResponse ** SOAP_FMAC4 soap_in_PointerTons__getSystemAirconResponse(struct soap *soap, const char *tag, ns__getSystemAirconResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__getSystemAirconResponse **)soap_malloc(soap, sizeof(ns__getSystemAirconResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__getSystemAirconResponse *)soap_instantiate_ns__getSystemAirconResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__getSystemAirconResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconResponse, sizeof(ns__getSystemAirconResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__getSystemAirconItemResponse(struct soap *soap, ns__getSystemAirconItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconItemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__getSystemAirconItemResponse(struct soap *soap, ns__getSystemAirconItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__getSystemAirconItemResponse);
	if (soap_out_PointerTons__getSystemAirconItemResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__getSystemAirconItemResponse(struct soap *soap, const char *tag, int id, ns__getSystemAirconItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__getSystemAirconItemResponse ** SOAP_FMAC4 soap_get_PointerTons__getSystemAirconItemResponse(struct soap *soap, ns__getSystemAirconItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__getSystemAirconItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__getSystemAirconItemResponse ** SOAP_FMAC4 soap_in_PointerTons__getSystemAirconItemResponse(struct soap *soap, const char *tag, ns__getSystemAirconItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__getSystemAirconItemResponse **)soap_malloc(soap, sizeof(ns__getSystemAirconItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__getSystemAirconItemResponse *)soap_instantiate_ns__getSystemAirconItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__getSystemAirconItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconItemResponse, sizeof(ns__getSystemAirconItemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__getSystemAirconPropertyItemResponse(struct soap *soap, ns__getSystemAirconPropertyItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconPropertyItemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__getSystemAirconPropertyItemResponse(struct soap *soap, ns__getSystemAirconPropertyItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__getSystemAirconPropertyItemResponse);
	if (soap_out_PointerTons__getSystemAirconPropertyItemResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__getSystemAirconPropertyItemResponse(struct soap *soap, const char *tag, int id, ns__getSystemAirconPropertyItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconPropertyItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__getSystemAirconPropertyItemResponse ** SOAP_FMAC4 soap_get_PointerTons__getSystemAirconPropertyItemResponse(struct soap *soap, ns__getSystemAirconPropertyItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__getSystemAirconPropertyItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__getSystemAirconPropertyItemResponse ** SOAP_FMAC4 soap_in_PointerTons__getSystemAirconPropertyItemResponse(struct soap *soap, const char *tag, ns__getSystemAirconPropertyItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__getSystemAirconPropertyItemResponse **)soap_malloc(soap, sizeof(ns__getSystemAirconPropertyItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__getSystemAirconPropertyItemResponse *)soap_instantiate_ns__getSystemAirconPropertyItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__getSystemAirconPropertyItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__getSystemAirconPropertyItemResponse, sizeof(ns__getSystemAirconPropertyItemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__setBundleLightResponse(struct soap *soap, ns__setBundleLightResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__setBundleLightResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__setBundleLightResponse(struct soap *soap, ns__setBundleLightResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__setBundleLightResponse);
	if (soap_out_PointerTons__setBundleLightResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__setBundleLightResponse(struct soap *soap, const char *tag, int id, ns__setBundleLightResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__setBundleLightResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__setBundleLightResponse ** SOAP_FMAC4 soap_get_PointerTons__setBundleLightResponse(struct soap *soap, ns__setBundleLightResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__setBundleLightResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__setBundleLightResponse ** SOAP_FMAC4 soap_in_PointerTons__setBundleLightResponse(struct soap *soap, const char *tag, ns__setBundleLightResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__setBundleLightResponse **)soap_malloc(soap, sizeof(ns__setBundleLightResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__setBundleLightResponse *)soap_instantiate_ns__setBundleLightResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__setBundleLightResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__setBundleLightResponse, sizeof(ns__setBundleLightResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__getBundleLightResponse(struct soap *soap, ns__getBundleLightResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__getBundleLightResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__getBundleLightResponse(struct soap *soap, ns__getBundleLightResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__getBundleLightResponse);
	if (soap_out_PointerTons__getBundleLightResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__getBundleLightResponse(struct soap *soap, const char *tag, int id, ns__getBundleLightResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__getBundleLightResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__getBundleLightResponse ** SOAP_FMAC4 soap_get_PointerTons__getBundleLightResponse(struct soap *soap, ns__getBundleLightResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__getBundleLightResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__getBundleLightResponse ** SOAP_FMAC4 soap_in_PointerTons__getBundleLightResponse(struct soap *soap, const char *tag, ns__getBundleLightResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__getBundleLightResponse **)soap_malloc(soap, sizeof(ns__getBundleLightResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__getBundleLightResponse *)soap_instantiate_ns__getBundleLightResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__getBundleLightResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__getBundleLightResponse, sizeof(ns__getBundleLightResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__getBundleLightItemResponse(struct soap *soap, ns__getBundleLightItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__getBundleLightItemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__getBundleLightItemResponse(struct soap *soap, ns__getBundleLightItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__getBundleLightItemResponse);
	if (soap_out_PointerTons__getBundleLightItemResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__getBundleLightItemResponse(struct soap *soap, const char *tag, int id, ns__getBundleLightItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__getBundleLightItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__getBundleLightItemResponse ** SOAP_FMAC4 soap_get_PointerTons__getBundleLightItemResponse(struct soap *soap, ns__getBundleLightItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__getBundleLightItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__getBundleLightItemResponse ** SOAP_FMAC4 soap_in_PointerTons__getBundleLightItemResponse(struct soap *soap, const char *tag, ns__getBundleLightItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__getBundleLightItemResponse **)soap_malloc(soap, sizeof(ns__getBundleLightItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__getBundleLightItemResponse *)soap_instantiate_ns__getBundleLightItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__getBundleLightItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__getBundleLightItemResponse, sizeof(ns__getBundleLightItemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__getBundleLightPropertyItemResponse(struct soap *soap, ns__getBundleLightPropertyItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__getBundleLightPropertyItemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__getBundleLightPropertyItemResponse(struct soap *soap, ns__getBundleLightPropertyItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__getBundleLightPropertyItemResponse);
	if (soap_out_PointerTons__getBundleLightPropertyItemResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__getBundleLightPropertyItemResponse(struct soap *soap, const char *tag, int id, ns__getBundleLightPropertyItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__getBundleLightPropertyItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__getBundleLightPropertyItemResponse ** SOAP_FMAC4 soap_get_PointerTons__getBundleLightPropertyItemResponse(struct soap *soap, ns__getBundleLightPropertyItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__getBundleLightPropertyItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__getBundleLightPropertyItemResponse ** SOAP_FMAC4 soap_in_PointerTons__getBundleLightPropertyItemResponse(struct soap *soap, const char *tag, ns__getBundleLightPropertyItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__getBundleLightPropertyItemResponse **)soap_malloc(soap, sizeof(ns__getBundleLightPropertyItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__getBundleLightPropertyItemResponse *)soap_instantiate_ns__getBundleLightPropertyItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__getBundleLightPropertyItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__getBundleLightPropertyItemResponse, sizeof(ns__getBundleLightPropertyItemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__setCurtainResponse(struct soap *soap, ns__setCurtainResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__setCurtainResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__setCurtainResponse(struct soap *soap, ns__setCurtainResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__setCurtainResponse);
	if (soap_out_PointerTons__setCurtainResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__setCurtainResponse(struct soap *soap, const char *tag, int id, ns__setCurtainResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__setCurtainResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__setCurtainResponse ** SOAP_FMAC4 soap_get_PointerTons__setCurtainResponse(struct soap *soap, ns__setCurtainResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__setCurtainResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__setCurtainResponse ** SOAP_FMAC4 soap_in_PointerTons__setCurtainResponse(struct soap *soap, const char *tag, ns__setCurtainResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__setCurtainResponse **)soap_malloc(soap, sizeof(ns__setCurtainResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__setCurtainResponse *)soap_instantiate_ns__setCurtainResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__setCurtainResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__setCurtainResponse, sizeof(ns__setCurtainResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__getCurtainResponse(struct soap *soap, ns__getCurtainResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__getCurtainResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__getCurtainResponse(struct soap *soap, ns__getCurtainResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__getCurtainResponse);
	if (soap_out_PointerTons__getCurtainResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__getCurtainResponse(struct soap *soap, const char *tag, int id, ns__getCurtainResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__getCurtainResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__getCurtainResponse ** SOAP_FMAC4 soap_get_PointerTons__getCurtainResponse(struct soap *soap, ns__getCurtainResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__getCurtainResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__getCurtainResponse ** SOAP_FMAC4 soap_in_PointerTons__getCurtainResponse(struct soap *soap, const char *tag, ns__getCurtainResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__getCurtainResponse **)soap_malloc(soap, sizeof(ns__getCurtainResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__getCurtainResponse *)soap_instantiate_ns__getCurtainResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__getCurtainResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__getCurtainResponse, sizeof(ns__getCurtainResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__getCurtainItemResponse(struct soap *soap, ns__getCurtainItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__getCurtainItemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__getCurtainItemResponse(struct soap *soap, ns__getCurtainItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__getCurtainItemResponse);
	if (soap_out_PointerTons__getCurtainItemResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__getCurtainItemResponse(struct soap *soap, const char *tag, int id, ns__getCurtainItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__getCurtainItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__getCurtainItemResponse ** SOAP_FMAC4 soap_get_PointerTons__getCurtainItemResponse(struct soap *soap, ns__getCurtainItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__getCurtainItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__getCurtainItemResponse ** SOAP_FMAC4 soap_in_PointerTons__getCurtainItemResponse(struct soap *soap, const char *tag, ns__getCurtainItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__getCurtainItemResponse **)soap_malloc(soap, sizeof(ns__getCurtainItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__getCurtainItemResponse *)soap_instantiate_ns__getCurtainItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__getCurtainItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__getCurtainItemResponse, sizeof(ns__getCurtainItemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__getCurtainPropertyItemResponse(struct soap *soap, ns__getCurtainPropertyItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__getCurtainPropertyItemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__getCurtainPropertyItemResponse(struct soap *soap, ns__getCurtainPropertyItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__getCurtainPropertyItemResponse);
	if (soap_out_PointerTons__getCurtainPropertyItemResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__getCurtainPropertyItemResponse(struct soap *soap, const char *tag, int id, ns__getCurtainPropertyItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__getCurtainPropertyItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__getCurtainPropertyItemResponse ** SOAP_FMAC4 soap_get_PointerTons__getCurtainPropertyItemResponse(struct soap *soap, ns__getCurtainPropertyItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__getCurtainPropertyItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__getCurtainPropertyItemResponse ** SOAP_FMAC4 soap_in_PointerTons__getCurtainPropertyItemResponse(struct soap *soap, const char *tag, ns__getCurtainPropertyItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__getCurtainPropertyItemResponse **)soap_malloc(soap, sizeof(ns__getCurtainPropertyItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__getCurtainPropertyItemResponse *)soap_instantiate_ns__getCurtainPropertyItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__getCurtainPropertyItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__getCurtainPropertyItemResponse, sizeof(ns__getCurtainPropertyItemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__setGasValveResponse(struct soap *soap, ns__setGasValveResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__setGasValveResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__setGasValveResponse(struct soap *soap, ns__setGasValveResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__setGasValveResponse);
	if (soap_out_PointerTons__setGasValveResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__setGasValveResponse(struct soap *soap, const char *tag, int id, ns__setGasValveResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__setGasValveResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__setGasValveResponse ** SOAP_FMAC4 soap_get_PointerTons__setGasValveResponse(struct soap *soap, ns__setGasValveResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__setGasValveResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__setGasValveResponse ** SOAP_FMAC4 soap_in_PointerTons__setGasValveResponse(struct soap *soap, const char *tag, ns__setGasValveResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__setGasValveResponse **)soap_malloc(soap, sizeof(ns__setGasValveResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__setGasValveResponse *)soap_instantiate_ns__setGasValveResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__setGasValveResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__setGasValveResponse, sizeof(ns__setGasValveResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__getGasValveResponse(struct soap *soap, ns__getGasValveResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__getGasValveResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__getGasValveResponse(struct soap *soap, ns__getGasValveResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__getGasValveResponse);
	if (soap_out_PointerTons__getGasValveResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__getGasValveResponse(struct soap *soap, const char *tag, int id, ns__getGasValveResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__getGasValveResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__getGasValveResponse ** SOAP_FMAC4 soap_get_PointerTons__getGasValveResponse(struct soap *soap, ns__getGasValveResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__getGasValveResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__getGasValveResponse ** SOAP_FMAC4 soap_in_PointerTons__getGasValveResponse(struct soap *soap, const char *tag, ns__getGasValveResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__getGasValveResponse **)soap_malloc(soap, sizeof(ns__getGasValveResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__getGasValveResponse *)soap_instantiate_ns__getGasValveResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__getGasValveResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__getGasValveResponse, sizeof(ns__getGasValveResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__getGasValveItemResponse(struct soap *soap, ns__getGasValveItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__getGasValveItemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__getGasValveItemResponse(struct soap *soap, ns__getGasValveItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__getGasValveItemResponse);
	if (soap_out_PointerTons__getGasValveItemResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__getGasValveItemResponse(struct soap *soap, const char *tag, int id, ns__getGasValveItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__getGasValveItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__getGasValveItemResponse ** SOAP_FMAC4 soap_get_PointerTons__getGasValveItemResponse(struct soap *soap, ns__getGasValveItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__getGasValveItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__getGasValveItemResponse ** SOAP_FMAC4 soap_in_PointerTons__getGasValveItemResponse(struct soap *soap, const char *tag, ns__getGasValveItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__getGasValveItemResponse **)soap_malloc(soap, sizeof(ns__getGasValveItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__getGasValveItemResponse *)soap_instantiate_ns__getGasValveItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__getGasValveItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__getGasValveItemResponse, sizeof(ns__getGasValveItemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__getGasValvePropertyItemResponse(struct soap *soap, ns__getGasValvePropertyItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__getGasValvePropertyItemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__getGasValvePropertyItemResponse(struct soap *soap, ns__getGasValvePropertyItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__getGasValvePropertyItemResponse);
	if (soap_out_PointerTons__getGasValvePropertyItemResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__getGasValvePropertyItemResponse(struct soap *soap, const char *tag, int id, ns__getGasValvePropertyItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__getGasValvePropertyItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__getGasValvePropertyItemResponse ** SOAP_FMAC4 soap_get_PointerTons__getGasValvePropertyItemResponse(struct soap *soap, ns__getGasValvePropertyItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__getGasValvePropertyItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__getGasValvePropertyItemResponse ** SOAP_FMAC4 soap_in_PointerTons__getGasValvePropertyItemResponse(struct soap *soap, const char *tag, ns__getGasValvePropertyItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__getGasValvePropertyItemResponse **)soap_malloc(soap, sizeof(ns__getGasValvePropertyItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__getGasValvePropertyItemResponse *)soap_instantiate_ns__getGasValvePropertyItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__getGasValvePropertyItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__getGasValvePropertyItemResponse, sizeof(ns__getGasValvePropertyItemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__setLightResponse(struct soap *soap, ns__setLightResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__setLightResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__setLightResponse(struct soap *soap, ns__setLightResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__setLightResponse);
	if (soap_out_PointerTons__setLightResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__setLightResponse(struct soap *soap, const char *tag, int id, ns__setLightResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__setLightResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__setLightResponse ** SOAP_FMAC4 soap_get_PointerTons__setLightResponse(struct soap *soap, ns__setLightResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__setLightResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__setLightResponse ** SOAP_FMAC4 soap_in_PointerTons__setLightResponse(struct soap *soap, const char *tag, ns__setLightResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__setLightResponse **)soap_malloc(soap, sizeof(ns__setLightResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__setLightResponse *)soap_instantiate_ns__setLightResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__setLightResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__setLightResponse, sizeof(ns__setLightResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__getLightResponse(struct soap *soap, ns__getLightResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__getLightResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__getLightResponse(struct soap *soap, ns__getLightResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__getLightResponse);
	if (soap_out_PointerTons__getLightResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__getLightResponse(struct soap *soap, const char *tag, int id, ns__getLightResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__getLightResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__getLightResponse ** SOAP_FMAC4 soap_get_PointerTons__getLightResponse(struct soap *soap, ns__getLightResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__getLightResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__getLightResponse ** SOAP_FMAC4 soap_in_PointerTons__getLightResponse(struct soap *soap, const char *tag, ns__getLightResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__getLightResponse **)soap_malloc(soap, sizeof(ns__getLightResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__getLightResponse *)soap_instantiate_ns__getLightResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__getLightResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__getLightResponse, sizeof(ns__getLightResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__getLightItemResponse(struct soap *soap, ns__getLightItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__getLightItemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__getLightItemResponse(struct soap *soap, ns__getLightItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__getLightItemResponse);
	if (soap_out_PointerTons__getLightItemResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__getLightItemResponse(struct soap *soap, const char *tag, int id, ns__getLightItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__getLightItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__getLightItemResponse ** SOAP_FMAC4 soap_get_PointerTons__getLightItemResponse(struct soap *soap, ns__getLightItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__getLightItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__getLightItemResponse ** SOAP_FMAC4 soap_in_PointerTons__getLightItemResponse(struct soap *soap, const char *tag, ns__getLightItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__getLightItemResponse **)soap_malloc(soap, sizeof(ns__getLightItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__getLightItemResponse *)soap_instantiate_ns__getLightItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__getLightItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__getLightItemResponse, sizeof(ns__getLightItemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__getLightPropertyItemResponse(struct soap *soap, ns__getLightPropertyItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__getLightPropertyItemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__getLightPropertyItemResponse(struct soap *soap, ns__getLightPropertyItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__getLightPropertyItemResponse);
	if (soap_out_PointerTons__getLightPropertyItemResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__getLightPropertyItemResponse(struct soap *soap, const char *tag, int id, ns__getLightPropertyItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__getLightPropertyItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__getLightPropertyItemResponse ** SOAP_FMAC4 soap_get_PointerTons__getLightPropertyItemResponse(struct soap *soap, ns__getLightPropertyItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__getLightPropertyItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__getLightPropertyItemResponse ** SOAP_FMAC4 soap_in_PointerTons__getLightPropertyItemResponse(struct soap *soap, const char *tag, ns__getLightPropertyItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__getLightPropertyItemResponse **)soap_malloc(soap, sizeof(ns__getLightPropertyItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__getLightPropertyItemResponse *)soap_instantiate_ns__getLightPropertyItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__getLightPropertyItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__getLightPropertyItemResponse, sizeof(ns__getLightPropertyItemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__setBoilerResponse(struct soap *soap, ns__setBoilerResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__setBoilerResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__setBoilerResponse(struct soap *soap, ns__setBoilerResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__setBoilerResponse);
	if (soap_out_PointerTons__setBoilerResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__setBoilerResponse(struct soap *soap, const char *tag, int id, ns__setBoilerResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__setBoilerResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__setBoilerResponse ** SOAP_FMAC4 soap_get_PointerTons__setBoilerResponse(struct soap *soap, ns__setBoilerResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__setBoilerResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__setBoilerResponse ** SOAP_FMAC4 soap_in_PointerTons__setBoilerResponse(struct soap *soap, const char *tag, ns__setBoilerResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__setBoilerResponse **)soap_malloc(soap, sizeof(ns__setBoilerResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__setBoilerResponse *)soap_instantiate_ns__setBoilerResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__setBoilerResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__setBoilerResponse, sizeof(ns__setBoilerResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__getBoilerResponse(struct soap *soap, ns__getBoilerResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__getBoilerResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__getBoilerResponse(struct soap *soap, ns__getBoilerResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__getBoilerResponse);
	if (soap_out_PointerTons__getBoilerResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__getBoilerResponse(struct soap *soap, const char *tag, int id, ns__getBoilerResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__getBoilerResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__getBoilerResponse ** SOAP_FMAC4 soap_get_PointerTons__getBoilerResponse(struct soap *soap, ns__getBoilerResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__getBoilerResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__getBoilerResponse ** SOAP_FMAC4 soap_in_PointerTons__getBoilerResponse(struct soap *soap, const char *tag, ns__getBoilerResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__getBoilerResponse **)soap_malloc(soap, sizeof(ns__getBoilerResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__getBoilerResponse *)soap_instantiate_ns__getBoilerResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__getBoilerResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__getBoilerResponse, sizeof(ns__getBoilerResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__getBoilerItemResponse(struct soap *soap, ns__getBoilerItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__getBoilerItemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__getBoilerItemResponse(struct soap *soap, ns__getBoilerItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__getBoilerItemResponse);
	if (soap_out_PointerTons__getBoilerItemResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__getBoilerItemResponse(struct soap *soap, const char *tag, int id, ns__getBoilerItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__getBoilerItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__getBoilerItemResponse ** SOAP_FMAC4 soap_get_PointerTons__getBoilerItemResponse(struct soap *soap, ns__getBoilerItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__getBoilerItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__getBoilerItemResponse ** SOAP_FMAC4 soap_in_PointerTons__getBoilerItemResponse(struct soap *soap, const char *tag, ns__getBoilerItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__getBoilerItemResponse **)soap_malloc(soap, sizeof(ns__getBoilerItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__getBoilerItemResponse *)soap_instantiate_ns__getBoilerItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__getBoilerItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__getBoilerItemResponse, sizeof(ns__getBoilerItemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__getBoilerPropertyItemResponse(struct soap *soap, ns__getBoilerPropertyItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__getBoilerPropertyItemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__getBoilerPropertyItemResponse(struct soap *soap, ns__getBoilerPropertyItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__getBoilerPropertyItemResponse);
	if (soap_out_PointerTons__getBoilerPropertyItemResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__getBoilerPropertyItemResponse(struct soap *soap, const char *tag, int id, ns__getBoilerPropertyItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__getBoilerPropertyItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__getBoilerPropertyItemResponse ** SOAP_FMAC4 soap_get_PointerTons__getBoilerPropertyItemResponse(struct soap *soap, ns__getBoilerPropertyItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__getBoilerPropertyItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__getBoilerPropertyItemResponse ** SOAP_FMAC4 soap_in_PointerTons__getBoilerPropertyItemResponse(struct soap *soap, const char *tag, ns__getBoilerPropertyItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__getBoilerPropertyItemResponse **)soap_malloc(soap, sizeof(ns__getBoilerPropertyItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__getBoilerPropertyItemResponse *)soap_instantiate_ns__getBoilerPropertyItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__getBoilerPropertyItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__getBoilerPropertyItemResponse, sizeof(ns__getBoilerPropertyItemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__setDeviceCategoryResponse(struct soap *soap, ns__setDeviceCategoryResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__setDeviceCategoryResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__setDeviceCategoryResponse(struct soap *soap, ns__setDeviceCategoryResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__setDeviceCategoryResponse);
	if (soap_out_PointerTons__setDeviceCategoryResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__setDeviceCategoryResponse(struct soap *soap, const char *tag, int id, ns__setDeviceCategoryResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__setDeviceCategoryResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__setDeviceCategoryResponse ** SOAP_FMAC4 soap_get_PointerTons__setDeviceCategoryResponse(struct soap *soap, ns__setDeviceCategoryResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__setDeviceCategoryResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__setDeviceCategoryResponse ** SOAP_FMAC4 soap_in_PointerTons__setDeviceCategoryResponse(struct soap *soap, const char *tag, ns__setDeviceCategoryResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__setDeviceCategoryResponse **)soap_malloc(soap, sizeof(ns__setDeviceCategoryResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__setDeviceCategoryResponse *)soap_instantiate_ns__setDeviceCategoryResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__setDeviceCategoryResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__setDeviceCategoryResponse, sizeof(ns__setDeviceCategoryResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__getDeviceCategoryResponse(struct soap *soap, ns__getDeviceCategoryResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__getDeviceCategoryResponse(struct soap *soap, ns__getDeviceCategoryResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__getDeviceCategoryResponse);
	if (soap_out_PointerTons__getDeviceCategoryResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__getDeviceCategoryResponse(struct soap *soap, const char *tag, int id, ns__getDeviceCategoryResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__getDeviceCategoryResponse ** SOAP_FMAC4 soap_get_PointerTons__getDeviceCategoryResponse(struct soap *soap, ns__getDeviceCategoryResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__getDeviceCategoryResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__getDeviceCategoryResponse ** SOAP_FMAC4 soap_in_PointerTons__getDeviceCategoryResponse(struct soap *soap, const char *tag, ns__getDeviceCategoryResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__getDeviceCategoryResponse **)soap_malloc(soap, sizeof(ns__getDeviceCategoryResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__getDeviceCategoryResponse *)soap_instantiate_ns__getDeviceCategoryResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__getDeviceCategoryResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryResponse, sizeof(ns__getDeviceCategoryResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__getDeviceCategoryItemResponse(struct soap *soap, ns__getDeviceCategoryItemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryItemResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__getDeviceCategoryItemResponse(struct soap *soap, ns__getDeviceCategoryItemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTons__getDeviceCategoryItemResponse);
	if (soap_out_PointerTons__getDeviceCategoryItemResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__getDeviceCategoryItemResponse(struct soap *soap, const char *tag, int id, ns__getDeviceCategoryItemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryItemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns__getDeviceCategoryItemResponse ** SOAP_FMAC4 soap_get_PointerTons__getDeviceCategoryItemResponse(struct soap *soap, ns__getDeviceCategoryItemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__getDeviceCategoryItemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns__getDeviceCategoryItemResponse ** SOAP_FMAC4 soap_in_PointerTons__getDeviceCategoryItemResponse(struct soap *soap, const char *tag, ns__getDeviceCategoryItemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (ns__getDeviceCategoryItemResponse **)soap_malloc(soap, sizeof(ns__getDeviceCategoryItemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns__getDeviceCategoryItemResponse *)soap_instantiate_ns__getDeviceCategoryItemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns__getDeviceCategoryItemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_ns__getDeviceCategoryItemResponse, sizeof(ns__getDeviceCategoryItemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerToint);
	if (soap_out_PointerToint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_unsignedByte);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cmxDeviceService_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cmxDeviceService_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_cmxDeviceService__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_cmxDeviceService__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_cmxDeviceService_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cmxDeviceService_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_cmxDeviceService_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_cmxDeviceService_string, 1, -1, -1);
}

} // namespace cmxDeviceService


/* End of cmxDeviceServiceC.cpp */
